/* Copyright (c) 2011-2020, The Linux Foundation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *     * Neither the name of The Linux Foundation, nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef LOC_SERVICE_02_H
#define LOC_SERVICE_02_H
/**
  @file location_service_v02.h

  @brief This is the public header file which defines the loc service Data structures.

  This header file defines the types and structures that were defined in
  loc. It contains the constant values defined, enums, structures,
  messages, and service message IDs (in that order) Structures that were
  defined in the IDL as messages contain mandatory elements, optional
  elements, a combination of mandatory and optional elements (mandatory
  always come before optionals in the structure), or nothing (null message)

  An optional element in a message is preceded by a uint8_t value that must be
  set to true if the element is going to be included. When decoding a received
  message, the uint8_t values will be set to true or false by the decode
  routine, and should be checked before accessing the values that they
  correspond to.

  Variable sized arrays are defined as static sized arrays with an unsigned
  integer (32 bit) preceding it that must be set to the number of elements
  in the array that are valid. For Example:

  uint32_t test_opaque_len;
  uint8_t test_opaque[16];

  If only 4 elements are added to test_opaque[] then test_opaque_len must be
  set to 4 before sending the message.  When decoding, the _len value is set
  by the decode routine and should be checked so that the correct number of
  elements in the array will be accessed.

 *====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/
/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*
 *THIS IS AN AUTO GENERATED FILE. DO NOT ALTER IN ANY WAY
 *====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*/

/* This file was generated with Tool version 6.14.7
   It was generated on: Wed Oct 14 2020 (Spin 0)
   From IDL File: location_service_v02.idl */

/** @defgroup loc_qmi_consts Constant values defined in the IDL */
/** @defgroup loc_qmi_msg_ids Constant values for QMI message IDs */
/** @defgroup loc_qmi_enums Enumerated types used in QMI messages */
/** @defgroup loc_qmi_messages Structures sent as QMI messages */
/** @defgroup loc_qmi_aggregates Aggregate types used in QMI messages */
/** @defgroup loc_qmi_accessor Accessor for QMI service object */
/** @defgroup loc_qmi_version Constant values for versioning information */

#include <stdint.h>
#include "qmi_idl_lib.h"
#include "common_v01.h"


#ifdef __cplusplus
extern "C" {
#endif

/** @addtogroup loc_qmi_version
    @{
  */
/** Major Version Number of the IDL used to generate this file */
#define LOC_V02_IDL_MAJOR_VERS 0x02
/** Revision Number of the IDL used to generate this file */
#define LOC_V02_IDL_MINOR_VERS 0x86
/** Major Version Number of the qmi_idl_compiler used to generate this file */
#define LOC_V02_IDL_TOOL_VERS 0x06
/** Maximum Defined Message ID */
#define LOC_V02_MAX_MESSAGE_ID 0x00E2
/**
    @}
  */


/** @addtogroup loc_qmi_consts
    @{
  */

/**  Maximum string length for the client string ID  */
#define QMI_LOC_MAX_CLIENT_ID_STRING_LENGTH_V02 4

/**  Maximum string length for the provider field in the application ID.\n  */
#define QMI_LOC_MAX_APP_ID_PROVIDER_LENGTH_V02 24

/**  Maximum string length for the name field in the application ID. \n */
#define QMI_LOC_MAX_APP_ID_NAME_LENGTH_V02 32

/**  Maximum string length for the version field in the application ID.  */
#define QMI_LOC_MAX_APP_ID_VERSION_LENGTH_V02 8

/**  Maximum length of the list containing the SVs that were used to generate
     a position report.  */
#define QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02 80

/**  Maximum expanded length of the list containing the SVs that were used to generate
     a position report.  */
#define QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02 176

/**  Maximum number of GNSS signal type  */
#define QMI_LOC_MAX_GNSS_SIGNAL_TYPE_V02 19

/**  East, North, up array length  */
#define QMI_LOC_ENU_ARRAY_LENGTH_V02 3

/**  Maximum length of the list containing station IDs providing DGNSS
     correction.  */
#define QMI_LOC_DGNSS_STATION_ID_ARRAY_LENGTH_V02 3

/**  Maximum length of the list containing the SVs Enviroment Aiding Correction
     Data to inject.  */
#define QMI_LOC_ENV_AIDING_CORRECTION_MAX_SV_USED_V02 60

/**  Maximum number of satellites in the satellite report.  */
#define QMI_LOC_SV_INFO_LIST_MAX_SIZE_V02 80

/**  Maximum NMEA string length.  */
#define QMI_LOC_NMEA_STRING_MAX_LENGTH_V02 200

/**  Maximum expanded NMEA string length.  */
#define QMI_LOC_EXPANDED_NMEA_STRING_MAX_LENGTH_V02 4095

/**  Maximum length of the requestor ID string.  */
#define QMI_LOC_NI_MAX_REQUESTOR_ID_LENGTH_V02 200

/**  Session ID byte length.  */
#define QMI_LOC_NI_SUPL_SLP_SESSION_ID_BYTE_LENGTH_V02 4

/**  Maximum client name length allowed.  */
#define QMI_LOC_NI_MAX_CLIENT_NAME_LENGTH_V02 64

/**  Maximum URL length accepted by the location engine.  */
#define QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 255

/**  IPv6 address length in bytes.  */
#define QMI_LOC_IPV6_ADDR_LENGTH_V02 8

/**  SUPL hash length.  */
#define QMI_LOC_NI_SUPL_HASH_LENGTH_V02 8

/**  Maximum client address length allowed.  */
#define QMI_LOC_NI_MAX_EXT_CLIENT_ADDRESS_V02 20

/**  Maximum codeword length allowed.  */
#define QMI_LOC_NI_CODEWORD_MAX_LENGTH_V02 20

/**  Maximum number of NTP Servers sent out with this event. */
#define QMI_LOC_MAX_NTP_SERVERS_V02 3

/**  Maximum number of predicted orbits servers supported in the location
     engine.  */
#define QMI_LOC_MAX_PREDICTED_ORBITS_SERVERS_V02 3

/**  Maximum length of the list, where each element of the list contains the
     continuous range of Geofences that were breached at a given position.  */
#define QMI_LOC_MAX_GEOFENCE_ID_CONTINUOUS_LIST_LENGTH_V02 80

/**  Maximum length of the list that contains a discrete number Geofences that
     were breached at a given position.  */
#define QMI_LOC_MAX_GEOFENCE_ID_DISCRETE_LIST_LENGTH_V02 80

/**  Maximum length that can be injected.   */
#define QMI_LOC_MAX_GDT_PATH_LEN_V02 255

/**  Maximum client information size in bytes.   */
#define QMI_LOC_MAX_GTP_CL_INFO_LEN_V02 1500

/**  Maximum mobile status data size in bytes.   */
#define QMI_LOC_MAX_GTP_MSD_LEN_V02 4000

/**  Maximum GNSS Measurement Engine Firmware Version String length.  */
#define QMI_LOC_GNSS_ME_VERSION_STRING_MAX_LENGTH_V02 127

/**  Maximum GNSS Measurement Engine Hosted Software Version String length.  */
#define QMI_LOC_GNSS_HOSTED_SW_VERSION_STRING_MAX_LENGTH_V02 127

/**  Maximum GNSS Measurement Engine Full Version String length.  */
#define QMI_LOC_GNSS_SW_VERSION_STRING_MAX_LENGTH_V02 255

/**  Maximum part length that can be injected. The client
     also looks at the maxPartSize field in the predicted orbits injection
     request indication and picks the minimum of the two.  */
#define QMI_LOC_MAX_PREDICTED_ORBITS_PART_LEN_V02 1024

/**  Maximum length of the delete SV information list  */
#define QMI_LOC_DELETE_MAX_SV_INFO_LENGTH_V02 128

/**  Maximum length of the delete BDS SV information list.  */
#define QMI_LOC_DELETE_MAX_BDS_SV_INFO_LENGTH_V02 37

/**  Maximum length of the delete GAL SV information list.  */
#define QMI_LOC_DELETE_MAX_GAL_SV_INFO_LENGTH_V02 36

/**  MAC address length in bytes.  */
#define QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02 6

/**  Wi-Fi SSID string maximum length.   */
#define QMI_LOC_MAX_WIFI_AP_SSID_STR_LENGTH_V02 32

/**  Maximum number of APs that the sender can report.  */
#define QMI_LOC_WIFI_MAX_REPORTED_APS_PER_MSG_V02 50

/**  Maximum number of samples that can be injected in a TLV.  */
#define QMI_LOC_SENSOR_DATA_MAX_SAMPLES_V02 50

/**  Maximum APN string length allowed.  */
#define QMI_LOC_MAX_APN_NAME_LENGTH_V02 100

/**  Maximum APN profiles supported. */
#define QMI_LOC_MAX_APN_PROFILES_V02 6

/**  Maximum length of the SUPL certificate. */
#define QMI_LOC_MAX_SUPL_CERT_LENGTH_V02 2000

/**  Maximum number of motion states used by the Geofence engine.  */
#define QMI_LOC_GEOFENCE_MAX_MOTION_STATES_V02 20

/**  Maximum length of the network-initiated Geofence ID
     list.  */
#define QMI_LOC_MAX_NI_GEOFENCE_ID_LIST_LENGTH_V02 16

/**  Maximum value of WDMA frequency for injection of WCDMA cell
     information.  */
#define QMI_LOC_MAX_WCDMA_FREQ_V02 16383

/**  Maximum value of PSC for injection of WCDMA cell information.  */
#define QMI_LOC_MAX_WCDMA_PSC_V02 511

/**  Maximum value of TDSCDMA frequency for injection of TDSCDMA cell
     information.  */
#define QMI_LOC_MAX_TDSCDMA_FREQ_V02 16383

/**  Maximum length of the injected network-initiated message.  */
#define QMI_LOC_MAX_INJECTED_NETWORK_INITIATED_MESSAGE_LENGTH_V02 1024

/**  Maximum number of entries returned from a batch in each indication.  */
#define QMI_LOC_READ_FROM_BATCH_MAX_SIZE_V02 5

/**  Maximum number of vehicle sensor samples that can be injected.  */
#define QMI_LOC_VEHICLE_SENSOR_DATA_MAX_SAMPLES_V02 65

/**  Maximum number of axes that can be provided in each sample.  */
#define QMI_LOC_VEHICLE_SENSOR_DATA_MAX_AXES_V02 3

/**  Maximum number of measurements from an odometer.  */
#define QMI_LOC_VEHICLE_ODOMETRY_MAX_MEASUREMENTS_V02 3
#define QMI_LOC_MEAS_STATUS_DONT_USE_BITS_V02 0xFFC0000000000000

/**  Maximum number of satellites in a measurement block for a specified system.  */
#define QMI_LOC_SV_MEAS_LIST_MAX_SIZE_V02 16

/**  Maximum number of satellites in a extended measurement block.  */
#define QMI_LOC_EXT_SV_MEAS_LIST_MAX_SIZE_V02 8

/**  Maximum length of the Other Code Type Name string, when the code used for the measurement is other.  */
#define QMI_LOC_SV_MEAS_OTHER_CODE_TYPE_NAME_MAX_LEN_V02 8

/**  Maximum number of satellites for which DGNSS corrections are provided.  */
#define QMI_LOC_DGNSS_SV_MEAS_LIST_MAX_SIZE_V02 24
#define QMI_LOC_SV_POLY_VELOCITY_COEF_SIZE_V02 12
#define QMI_LOC_SV_POLY_XYZ_0_TH_ORDER_COEFF_SIZE_V02 3
#define QMI_LOC_SV_POLY_XYZ_N_TH_ORDER_COEFF_SIZE_V02 9
#define QMI_LOC_SV_POLY_SV_CLKBIAS_COEFF_SIZE_V02 4

/**  IBeacon string maximum length.   */
#define QMI_LOC_MAX_IBEACON_UUID_STR_LENGTH_V02 32

/**  Wi-Fi area ID list length.  */
#define QMI_LOC_WIFI_AREA_ID_LIST_LENGTH_V02 20

/**  Cell ID list length.   */
#define QMI_LOC_CELL_ID_LIST_LENGTH_V02 20

/**  IBeacon list length.   */
#define QMI_LOC_IBEACON_LIST_LENGTH_V02 20

/**  Maximum length that can be injected.   */
#define QMI_LOC_MAX_GTP_WWAN_CLIENT_DOWNLOADED_DATA_LEN_V02 512

/**  Maximum length of the OEM ID.  */
#define QMI_LOC_MAX_OEM_ID_LEN_V02 256

/**  Maximum length of the model ID.  */
#define QMI_LOC_MAX_MODEL_ID_LEN_V02 256

/**  Maximum length that can be injected.   */
#define QMI_LOC_MAX_GTP_RLI_LEN_V02 256

/**  Maximum buffer length of the encrypted data blob for the QMI_LOC_SECURE_GET_AVAILABLE_POSITION_REQ request. */
#define QMI_LOC_SECURE_GET_AVAILABLE_POS_REQUEST_ENCRYPTED_MAX_V02 256

/**  Horizontal uncertainty circular
 Altitude With respect to ellipsoid
 Vertical uncertainty
 Horizontal elliptical uncertainty (semi-minor axis)
 Horizontal elliptical uncertainty (semi-major axis)
 Elliptical horizontal uncertainty azimuth
 Horizontal confidence
 Horizontal Elliptical Uncertainty Confidence
 Horizontal Reliability
 Horizontal Speed
 Horizontal Speed Uncertainty
 Altitude with respect to sea level
 Vertical confidence
 Vertical Reliability
 Vertical speed
 Vertical speed uncertainty
 Heading
 Heading uncertainty
 Magnetic Deviation
 Technology used
 Position dilution of precision
 Horizontal dilution of precision
 Vertical dilution of precision
 GPS week
 GPS time of week MS
 Time source
 Sensor data usage MASK
 Position Data aided by sensor
 SVs used to calculate the fix
 Time dilution of precision
 Geometrical dilution of precision */
#define QMI_LOC_SECURE_GET_AVAILABLE_POSITION_IND_ENCRYPTED_MAX_V02 1024

/**  Maximum number of APs that can be injected in a TLV.  */
#define QMI_LOC_APCACHE_DATA_MAX_SAMPLES_V02 80

/**  Maximum part length that can be injected. The client should
     also look at the maxPartSize field in the predicted orbits injection
     request indication and pick the minimum of the two.  */
#define QMI_LOC_MAX_XTRA_PART_LEN_V02 1024
#define QMI_LOC_SUPPORTED_FEATURE_LENGTH_V02 100

/**  The location service internal status report data length in bytes  */
#define QMI_LOC_INTERNAL_STATUS_REPORT_DATA_LENGTH_V02 56

/**  The maximum size of the internal status report list  */
#define QMI_LOC_INTERNAL_STATUS_MAX_LIST_SIZE_V02 67

/**  Maximum number of APs that the sender can report.  */
#define QMI_LOC_SRN_MAX_REPORTED_APS_PER_MSG_V02 64

/**  MAC address length in bytes.  */
#define QMI_LOC_SRN_MAC_ADDR_LENGTH_V02 6
#define QMI_LOC_MAX_WIFI_CROWDSOURCING_SERVER_CONFIG_LEN_V02 512
#define QMI_LOC_MAX_CROWDSOURCING_MODEM_CLIENT_INFO_LEN_V02 512

/**  Maximum number of BS info in the BS list.
  */
#define QMI_LOC_FDCL_BS_LIST_MAX_SIZE_V02 100

/**  FDCL cell-position list length.  */
#define QMI_LOC_FDCL_CELL_POS_LIST_LENGTH_V02 20
#define QMI_LOC_INJECT_FDCL_DATA_ERROR_MSG_LEN_V02 255

/**  Maximum length of Disaster & Crisis report in bits  */
#define QMI_LOC_MAX_DCREPORT_LEN_BITS_V02 512

/**  Maximum length of Disaster & Crisis report. Corresponds to 512 bits of storage  */
#define QMI_LOC_MAX_DCREPORT_LEN_V02 64

/**  Maximum number of satellites in an ephemeris report.  */
#define QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02 8

/**   */
#define QMI_LOC_DEFAULT_CONSTRAINED_TUNC_MS_V02 9.5

/**  Maximum string length for the requestor string ID  */
#define QMI_LOC_MAX_REQUESTOR_ID_STRING_LENGTH_V02 20

/**  Number of filter element size seventeen.  */
#define QMI_LOC_FILTER_ELEMENT_SIZE_SEVENTEEN_V02 17

/**  Number of filter element size six.  */
#define QMI_LOC_FILTER_ELEMENT_SIZE_SIX_V02 6

/**  Number of filter element size three.  */
#define QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02 3

/**  Number of filter element size four.  */
#define QMI_LOC_FILTER_ELEMENT_SIZE_FOUR_V02 4

/**  Number of IPM element size three.  */
#define QMI_LOC_IPM_ELEMENT_SIZE_THREE_V02 3

/**  Number of IPM element size nine.  */
#define QMI_LOC_IPM_ELEMENT_SIZE_NINE_V02 9

/**  Number of INS element size three.  */
#define QMI_LOC_INS_ELEMENT_SIZE_THREE_V02 3

/**  Number of INS element size two.    */
#define QMI_LOC_INS_ELEMENT_SIZE_TWO_V02 2
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUCCESS_V02 = 0, /**<  Request was completed successfully \n  */
  eQMI_LOC_GENERAL_FAILURE_V02 = 1, /**<  Request failed because of a general failure \n  */
  eQMI_LOC_UNSUPPORTED_V02 = 2, /**<  Request failed because it is not supported \n  */
  eQMI_LOC_INVALID_PARAMETER_V02 = 3, /**<  Request failed because it contained invalid parameters \n  */
  eQMI_LOC_ENGINE_BUSY_V02 = 4, /**<  Request failed because the engine is busy \n  */
  eQMI_LOC_PHONE_OFFLINE_V02 = 5, /**<  Request failed because the phone is offline \n  */
  eQMI_LOC_TIMEOUT_V02 = 6, /**<  Request failed because it has timed out \n  */
  eQMI_LOC_CONFIG_NOT_SUPPORTED_V02 = 7, /**<  Request failed because an undefined configuration was requested \n  */
  eQMI_LOC_INSUFFICIENT_MEMORY_V02 = 8, /**<  Request failed because the engine could not allocate sufficient memory for the request \n  */
  eQMI_LOC_MAX_GEOFENCE_PROGRAMMED_V02 = 9, /**<  Request failed because the maximum number of Geofences are already programmed \n  */
  eQMI_LOC_XTRA_VERSION_CHECK_FAILURE_V02 = 10, /**<  Location service failed because of an XTRA version-based file format check failure \n  */
  eQMI_LOC_GNSS_DISABLED_V02 = 11, /**<  Request failed because the location service is disabled   */
  QMILOCSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Generic response definition. This message is used to tell
                    clients whether their message was accepted for further
                    processing or rejected. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGenReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Response Message; Generic response definition. This message is used to tell
                    clients whether their message was accepted for further
                    processing or rejected. */
typedef struct {

  /* Mandatory */
  /*  Result Code */
  qmi_response_type_v01 resp;
}qmiLocGenRespMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Generic response definition. This message is used to tell
                    clients whether their message was accepted for further
                    processing or rejected. */
typedef struct {

  /* Mandatory */
  /*  Success / Failure Status of QMI Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGenReqStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Informs the service of the minor revision of the interface
                    definition that the control point implements. */
typedef struct {

  /* Mandatory */
  /*  Revision */
  uint32_t revision;
  /**<   Revision that the control point is using. */
}qmiLocInformClientRevisionReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocEventRegMaskT_v02;
#define QMI_LOC_EVENT_MASK_POSITION_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x00000001ull) /**<  Position report event indications. \n  */
#define QMI_LOC_EVENT_MASK_GNSS_SV_INFO_V02 ((qmiLocEventRegMaskT_v02)0x00000002ull) /**<  Satellite report event indications. These reports are sent at a 1 Hz rate. \n */
#define QMI_LOC_EVENT_MASK_NMEA_V02 ((qmiLocEventRegMaskT_v02)0x00000004ull) /**<  NMEA reports for
       position and satellites in view. The report is at a 1 Hz rate. \n  */
#define QMI_LOC_EVENT_MASK_NI_NOTIFY_VERIFY_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000008ull) /**<  NI Notify/Verify request event indications. \n  */
#define QMI_LOC_EVENT_MASK_INJECT_TIME_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000010ull) /**<  Time injection request event indications. \n  */
#define QMI_LOC_EVENT_MASK_INJECT_PREDICTED_ORBITS_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000020ull) /**<  Predicted orbits request
       event indications. \n  */
#define QMI_LOC_EVENT_MASK_INJECT_POSITION_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000040ull) /**<  Position injection request event indications. \n  */
#define QMI_LOC_EVENT_MASK_ENGINE_STATE_V02 ((qmiLocEventRegMaskT_v02)0x00000080ull) /**<  Engine state report
       event indications. \n  */
#define QMI_LOC_EVENT_MASK_FIX_SESSION_STATE_V02 ((qmiLocEventRegMaskT_v02)0x00000100ull) /**<  Fix session status report event indications. \n  */
#define QMI_LOC_EVENT_MASK_WIFI_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000200ull) /**<  Wi-Fi position request event indications. \n  */
#define QMI_LOC_EVENT_MASK_SENSOR_STREAMING_READY_STATUS_V02 ((qmiLocEventRegMaskT_v02)0x00000400ull) /**<  Notifications from the location engine indicating its readiness to accept data from the
       sensors (accelerometer, gyroscope, and so on). \n  */
#define QMI_LOC_EVENT_MASK_TIME_SYNC_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00000800ull) /**<  Time sync requests
       from the GPS engine. Time sync enables the GPS engine to synchronize
       its clock with the sensor processor's clock. \n  */
#define QMI_LOC_EVENT_MASK_SET_SPI_STREAMING_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x00001000ull) /**<  Stationary Position Indicator (SPI) streaming report indications. \n  */
#define QMI_LOC_EVENT_MASK_LOCATION_SERVER_CONNECTION_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00002000ull) /**<  Location server requests; generated when the service wishes to
       establish a connection with a location server. \n */
#define QMI_LOC_EVENT_MASK_NI_GEOFENCE_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x00004000ull) /**<  Notifications related to network-initiated Geofences. These events notify the client
       when a network-initiated Geofence is added, deleted, or edited. \n */
#define QMI_LOC_EVENT_MASK_GEOFENCE_GEN_ALERT_V02 ((qmiLocEventRegMaskT_v02)0x00008000ull) /**<  Geofence alerts; generated to inform the client of the changes that can
       affect a Geofence, for example, if GPS is turned off or if the network is
       unavailable. \n  */
#define QMI_LOC_EVENT_MASK_GEOFENCE_BREACH_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x00010000ull) /**<  Geofence breach; when a UE enters or leaves the perimeter of a Geofence.
      This breach report is for a single Geofence. \n */
#define QMI_LOC_EVENT_MASK_PEDOMETER_CONTROL_V02 ((qmiLocEventRegMaskT_v02)0x00020000ull) /**<  Pedometer control requests from the location engine. The location engine sends
       this event to control the injection of pedometer reports. \n  */
#define QMI_LOC_EVENT_MASK_MOTION_DATA_CONTROL_V02 ((qmiLocEventRegMaskT_v02)0x00040000ull) /**<  Motion data control requests from the location engine. The location engine sends
       this event to control the injection of motion data. \n  */
#define QMI_LOC_EVENT_MASK_BATCH_FULL_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x00080000ull) /**<  Notification when a batch is full. The location engine sends this event to
      notify of batch full for ongoing batching session. \n  */
#define QMI_LOC_EVENT_MASK_LIVE_BATCHED_POSITION_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x00100000ull) /**<  Position report indications along with an ongoing batching session.
       The location engine sends this event to notify the batched position
       report while a batching session is ongoing. \n  */
#define QMI_LOC_EVENT_MASK_INJECT_WIFI_AP_DATA_REQ_V02 ((qmiLocEventRegMaskT_v02)0x00200000ull) /**<  Wi-Fi AP data inject request event indications. \n  */
#define QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_BREACH_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x00400000ull) /**<  Notifications when a Geofence is breached. These events are generated when a UE enters
       or leaves the perimeter of a Geofence. This breach notification is for
       multiple Geofences. Breaches from multiple Geofences are all batched and
       sent in the same notification.  \n  */
#define QMI_LOC_EVENT_MASK_VEHICLE_DATA_READY_STATUS_V02 ((qmiLocEventRegMaskT_v02)0x00800000ull) /**<  Notifications from the
       location engine indicating its readiness to accept vehicle data (vehicle
       accelerometer, vehicle angular rate, vehicle odometry, and so on).\n */
#define QMI_LOC_EVENT_MASK_GNSS_MEASUREMENT_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x01000000ull) /**<  System clock and satellite measurement report events (system clock, SV time,
       Doppler, and so on). Reports are generated only for the GNSS satellite constellations
       that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n  */
#define QMI_LOC_EVENT_MASK_GNSS_SV_POLYNOMIAL_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x02000000ull) /**<  Satellite position reports as polynomials. Reports are generated only for the GNSS satellite
        constellations that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n  */
#define QMI_LOC_EVENT_MASK_GEOFENCE_PROXIMITY_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x04000000ull) /**<  Notifications when a Geofence proximity is entered and exited. The proximity of
      a Geofence might be due to different contexts. These contexts are identified
      using the context ID in this indication. The context of a Geofence can contain Wi-Fi area
      ID lists, IBeacon lists, Cell-ID list, and so forth. \n   */
#define QMI_LOC_EVENT_MASK_GDT_UPLOAD_BEGIN_REQ_V02 ((qmiLocEventRegMaskT_v02)0x08000000ull) /**<  Generic Data Transport (GDT) upload session begin request event indications. \n */
#define QMI_LOC_EVENT_MASK_GDT_UPLOAD_END_REQ_V02 ((qmiLocEventRegMaskT_v02)0x10000000ull) /**<  GDT upload session end request event indications. \n  */
#define QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_DWELL_NOTIFICATION_V02 ((qmiLocEventRegMaskT_v02)0x20000000ull) /**<  Notifications when a Geofence is dwelled. These events are generated when a UE enters
       or leaves the perimeter of a Geofence and dwells inside or outside for a specified time.
       This dwell notification is for multiple Geofences. Dwells from multiple Geofences are all batched and
       sent in the same notification. \n  */
#define QMI_LOC_EVENT_MASK_GET_TIME_ZONE_REQ_V02 ((qmiLocEventRegMaskT_v02)0x40000000ull) /**<  Requests for time zone information from the service.
       These events are generated when there is a need for time zone information in the
       service. \n  */
#define QMI_LOC_EVENT_MASK_BATCHING_STATUS_V02 ((qmiLocEventRegMaskT_v02)0x80000000ull) /**<  Asynchronous events related to batching. n  */
#define QMI_LOC_EVENT_MASK_INTERNAL_STATUS_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x100000000ull) /**<  The location service internal status report mask. \n */
#define QMI_LOC_EVENT_MASK_INJECT_SRN_AP_DATA_REQ_V02 ((qmiLocEventRegMaskT_v02)0x200000000ull) /**<  Asynchronous events for
       short range node (SRN) RSSI scans, for example, BT, BTLE, NFC, and so on. \n  */
#define QMI_LOC_EVENT_MASK_GNSS_ONLY_POSITION_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x400000000ull) /**<  Position report event indications that contain a GNSS only position. \n  */
#define QMI_LOC_EVENT_MASK_FDCL_SERVICE_REQ_V02 ((qmiLocEventRegMaskT_v02)0x800000000ull) /**<  FDCL service request. \n  */
#define QMI_LOC_EVENT_MASK_DC_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x1000000000ull) /**<  DC report event indications that contains disaster and crisis reports. \n  */
#define QMI_LOC_EVENT_MASK_ENGINE_LOCK_STATE_V02 ((qmiLocEventRegMaskT_v02)0x2000000000ull) /**<  Asynchronous events related to the engine lock state. \n  */
#define QMI_LOC_EVENT_MASK_UNPROPAGATED_POSITION_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x4000000000ull) /**<  Unpropagated fix. \n  */
#define QMI_LOC_EVENT_MASK_BS_OBS_DATA_SERVICE_REQ_V02 ((qmiLocEventRegMaskT_v02)0x8000000000ull) /**<  Base station observed data service request. \n  */
#define QMI_LOC_EVENT_MASK_EPHEMERIS_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x10000000000ull) /**<  Ephemeris data for all GNSS constellations. \n  */
#define QMI_LOC_EVENT_MASK_NEXT_LS_INFO_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x20000000000ull) /**<  Upcoming leap second information from the service. \n  */
#define QMI_LOC_EVENT_MASK_GET_BAND_MEASUREMENT_METRICS_V02 ((qmiLocEventRegMaskT_v02)0x40000000000ull) /**<  The band measurement metrics from the ME. \n */
#define QMI_LOC_EVENT_MASK_GNSS_NHZ_MEASUREMENT_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x80000000000ull) /**<  System clock and satellite
       measurement report events (system clock, SV time, Doppler, and so on) at a rate greater
       than 1 Hz.
       Reports are generated only for the GNSS satellite constellations that are enabled using
       QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG.  \n  */
#define QMI_LOC_EVENT_MASK_GNSS_EVENT_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x100000000000ull) /**<  The QMI_LOC_EVENT_REPORT indication. \n  */
#define QMI_LOC_EVENT_MASK_QUERY_XTRA_INFO_V02 ((qmiLocEventRegMaskT_v02)0x200000000000ull) /**<  Event indication to trigger XTRA config query from the control point. \n */
#define QMI_LOC_EVENT_MASK_SAP_INS_PARAMETERS_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x400000000000ull) /**<  QMI_LOC_EVENT_SAP_INS_PARAMETERS indication. \n  */
#define QMI_LOC_EVENT_MASK_LATENCY_INFORMATION_REPORT_V02 ((qmiLocEventRegMaskT_v02)0x800000000000ull) /**<  QMI_LOC_LATENCY_INFORMATION indication.        */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCLIENTTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_CLIENT_AFW_V02 = 1, /**<  Application FrameWork client \n  */
  eQMI_LOC_CLIENT_NFW_V02 = 2, /**<  Non-AFW client \n */
  eQMI_LOC_CLIENT_PRIVILEGED_V02 = 3, /**<  Privileged client  */
  QMILOCCLIENTTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocClientTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to register for events from the
                    location subsystem. */
typedef struct {

  /* Mandatory */
  /*  Event Registration Mask */
  qmiLocEventRegMaskT_v02 eventRegMask;
  /**<   Specifies the events that the control point is interested in receiving.
 The control point must enable the following masks to receive the events:\n
      - QMI_LOC_EVENT_MASK_POSITION_REPORT (0x00000001) --  Position report event indications. \n
      - QMI_LOC_EVENT_MASK_GNSS_SV_INFO (0x00000002) --  Satellite report event indications. These reports are sent at a 1 Hz rate. \n
      - QMI_LOC_EVENT_MASK_NMEA (0x00000004) --  NMEA reports for
       position and satellites in view. The report is at a 1 Hz rate. \n
      - QMI_LOC_EVENT_MASK_NI_NOTIFY_VERIFY_REQ (0x00000008) --  NI Notify/Verify request event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_TIME_REQ (0x00000010) --  Time injection request event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_PREDICTED_ORBITS_REQ (0x00000020) --  Predicted orbits request
       event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_POSITION_REQ (0x00000040) --  Position injection request event indications. \n
      - QMI_LOC_EVENT_MASK_ENGINE_STATE (0x00000080) --  Engine state report
       event indications. \n
      - QMI_LOC_EVENT_MASK_FIX_SESSION_STATE (0x00000100) --  Fix session status report event indications. \n
      - QMI_LOC_EVENT_MASK_WIFI_REQ (0x00000200) --  Wi-Fi position request event indications. \n
      - QMI_LOC_EVENT_MASK_SENSOR_STREAMING_READY_STATUS (0x00000400) --  Notifications from the location engine indicating its readiness to accept data from the
       sensors (accelerometer, gyroscope, and so on). \n
      - QMI_LOC_EVENT_MASK_TIME_SYNC_REQ (0x00000800) --  Time sync requests
       from the GPS engine. Time sync enables the GPS engine to synchronize
       its clock with the sensor processor's clock. \n
      - QMI_LOC_EVENT_MASK_SET_SPI_STREAMING_REPORT (0x00001000) --  Stationary Position Indicator (SPI) streaming report indications. \n
      - QMI_LOC_EVENT_MASK_LOCATION_SERVER_CONNECTION_REQ (0x00002000) --  Location server requests; generated when the service wishes to
       establish a connection with a location server. \n
      - QMI_LOC_EVENT_MASK_NI_GEOFENCE_NOTIFICATION (0x00004000) --  Notifications related to network-initiated Geofences. These events notify the client
       when a network-initiated Geofence is added, deleted, or edited. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_GEN_ALERT (0x00008000) --  Geofence alerts; generated to inform the client of the changes that can
       affect a Geofence, for example, if GPS is turned off or if the network is
       unavailable. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BREACH_NOTIFICATION (0x00010000) --  Geofence breach; when a UE enters or leaves the perimeter of a Geofence.
      This breach report is for a single Geofence. \n
      - QMI_LOC_EVENT_MASK_PEDOMETER_CONTROL (0x00020000) --  Pedometer control requests from the location engine. The location engine sends
       this event to control the injection of pedometer reports. \n
      - QMI_LOC_EVENT_MASK_MOTION_DATA_CONTROL (0x00040000) --  Motion data control requests from the location engine. The location engine sends
       this event to control the injection of motion data. \n
      - QMI_LOC_EVENT_MASK_BATCH_FULL_NOTIFICATION (0x00080000) --  Notification when a batch is full. The location engine sends this event to
      notify of batch full for ongoing batching session. \n
      - QMI_LOC_EVENT_MASK_LIVE_BATCHED_POSITION_REPORT (0x00100000) --  Position report indications along with an ongoing batching session.
       The location engine sends this event to notify the batched position
       report while a batching session is ongoing. \n
      - QMI_LOC_EVENT_MASK_INJECT_WIFI_AP_DATA_REQ (0x00200000) --  Wi-Fi AP data inject request event indications. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_BREACH_NOTIFICATION (0x00400000) --  Notifications when a Geofence is breached. These events are generated when a UE enters
       or leaves the perimeter of a Geofence. This breach notification is for
       multiple Geofences. Breaches from multiple Geofences are all batched and
       sent in the same notification.  \n
      - QMI_LOC_EVENT_MASK_VEHICLE_DATA_READY_STATUS (0x00800000) --  Notifications from the
       location engine indicating its readiness to accept vehicle data (vehicle
       accelerometer, vehicle angular rate, vehicle odometry, and so on).\n
      - QMI_LOC_EVENT_MASK_GNSS_MEASUREMENT_REPORT (0x01000000) --  System clock and satellite measurement report events (system clock, SV time,
       Doppler, and so on). Reports are generated only for the GNSS satellite constellations
       that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n
      - QMI_LOC_EVENT_MASK_GNSS_SV_POLYNOMIAL_REPORT (0x02000000) --  Satellite position reports as polynomials. Reports are generated only for the GNSS satellite
        constellations that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_PROXIMITY_NOTIFICATION (0x04000000) --  Notifications when a Geofence proximity is entered and exited. The proximity of
      a Geofence might be due to different contexts. These contexts are identified
      using the context ID in this indication. The context of a Geofence can contain Wi-Fi area
      ID lists, IBeacon lists, Cell-ID list, and so forth. \n
      - QMI_LOC_EVENT_MASK_GDT_UPLOAD_BEGIN_REQ (0x08000000) --  Generic Data Transport (GDT) upload session begin request event indications. \n
      - QMI_LOC_EVENT_MASK_GDT_UPLOAD_END_REQ (0x10000000) --  GDT upload session end request event indications. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_DWELL_NOTIFICATION (0x20000000) --  Notifications when a Geofence is dwelled. These events are generated when a UE enters
       or leaves the perimeter of a Geofence and dwells inside or outside for a specified time.
       This dwell notification is for multiple Geofences. Dwells from multiple Geofences are all batched and
       sent in the same notification. \n
      - QMI_LOC_EVENT_MASK_GET_TIME_ZONE_REQ (0x40000000) --  Requests for time zone information from the service.
       These events are generated when there is a need for time zone information in the
       service. \n
      - QMI_LOC_EVENT_MASK_BATCHING_STATUS (0x80000000) --  Asynchronous events related to batching. n
      - QMI_LOC_EVENT_MASK_INTERNAL_STATUS_REPORT (0x100000000) --  The location service internal status report mask. \n
      - QMI_LOC_EVENT_MASK_INJECT_SRN_AP_DATA_REQ (0x200000000) --  Asynchronous events for
       short range node (SRN) RSSI scans, for example, BT, BTLE, NFC, and so on. \n
      - QMI_LOC_EVENT_MASK_GNSS_ONLY_POSITION_REPORT (0x400000000) --  Position report event indications that contain a GNSS only position. \n
      - QMI_LOC_EVENT_MASK_FDCL_SERVICE_REQ (0x800000000) --  FDCL service request. \n
      - QMI_LOC_EVENT_MASK_DC_REPORT (0x1000000000) --  DC report event indications that contains disaster and crisis reports. \n
      - QMI_LOC_EVENT_MASK_ENGINE_LOCK_STATE (0x2000000000) --  Asynchronous events related to the engine lock state. \n
      - QMI_LOC_EVENT_MASK_UNPROPAGATED_POSITION_REPORT (0x4000000000) --  Unpropagated fix. \n
      - QMI_LOC_EVENT_MASK_BS_OBS_DATA_SERVICE_REQ (0x8000000000) --  Base station observed data service request. \n
      - QMI_LOC_EVENT_MASK_EPHEMERIS_REPORT (0x10000000000) --  Ephemeris data for all GNSS constellations. \n
      - QMI_LOC_EVENT_MASK_NEXT_LS_INFO_REPORT (0x20000000000) --  Upcoming leap second information from the service. \n
      - QMI_LOC_EVENT_MASK_GET_BAND_MEASUREMENT_METRICS (0x40000000000) --  The band measurement metrics from the ME. \n
      - QMI_LOC_EVENT_MASK_GNSS_NHZ_MEASUREMENT_REPORT (0x80000000000) --  System clock and satellite
       measurement report events (system clock, SV time, Doppler, and so on) at a rate greater
       than 1 Hz.
       Reports are generated only for the GNSS satellite constellations that are enabled using
       QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG.  \n
      - QMI_LOC_EVENT_MASK_GNSS_EVENT_REPORT (0x100000000000) --  The QMI_LOC_EVENT_REPORT indication. \n
      - QMI_LOC_EVENT_MASK_QUERY_XTRA_INFO (0x200000000000) --  Event indication to trigger XTRA config query from the control point. \n
      - QMI_LOC_EVENT_MASK_SAP_INS_PARAMETERS_REPORT (0x400000000000) --  QMI_LOC_EVENT_SAP_INS_PARAMETERS indication. \n
      - QMI_LOC_EVENT_MASK_LATENCY_INFORMATION_REPORT (0x800000000000) --  QMI_LOC_LATENCY_INFORMATION indication.

 Multiple events can be registered by ORing the individual masks and
 sending them in this TLV. Set all unused bits in this mask to 0.

 */

  /* Optional */
  /*  Client Identification String */
  uint8_t clientStrId_valid;  /**< Must be set to true if clientStrId is being passed */
  char clientStrId[QMI_LOC_MAX_CLIENT_ID_STRING_LENGTH_V02 + 1];
  /**<   String identification of this client.
       This string is sent to the application framework in the
       QMI_LOC_LOCATION_REQUEST_NOTIFICATION_IND indication.
       */

  /* Optional */
  /*  Client Type */
  uint8_t clientType_valid;  /**< Must be set to true if clientType is being passed */
  qmiLocClientTypeEnumT_v02 clientType;
  /**<   If not specified, defaults to NFW client.
 If specifically set as the NFW or PRIVILEGED client, the control point
 must set the value for enablePosRequestNotification.\n
 Note: Location requests from privileged client(s) are always allowed,
 regardless of user privacy settings. This might violate OEM, carrier,
 or government privacy requirements. Contact privacy counsel
 for advice before choosing privileged as the clientType. \n
 Values: \n
      - eQMI_LOC_CLIENT_AFW (1) --  Application FrameWork client \n
      - eQMI_LOC_CLIENT_NFW (2) --  Non-AFW client \n
      - eQMI_LOC_CLIENT_PRIVILEGED (3) --  Privileged client
 */

  /* Optional */
  /*  Enable Positioning Request Notification */
  uint8_t enablePosRequestNotification_valid;  /**< Must be set to true if enablePosRequestNotification is being passed */
  uint8_t enablePosRequestNotification;
  /**<   If not specified, defaults to FALSE.
       If set to TRUE, each positioning request made by this client
       generates a notification to the application framework.
       The value is ignored when the client registers as an AFW client.
      */
}qmiLocRegEventsReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCFIXRECURRENCEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_RECURRENCE_PERIODIC_V02 = 1, /**<  Request periodic position fixes \n */
  eQMI_LOC_RECURRENCE_SINGLE_V02 = 2, /**<  Request a single position fix  */
  QMILOCFIXRECURRENCEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocFixRecurrenceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCACCURACYLEVELENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ACCURACY_LOW_V02 = 1, /**<  Low accuracy \n */
  eQMI_LOC_ACCURACY_MED_V02 = 2, /**<  Medium accuracy \n */
  eQMI_LOC_ACCURACY_HIGH_V02 = 3, /**<  High accuracy  */
  QMILOCACCURACYLEVELENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocAccuracyLevelEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCINTERMEDIATEREPORTSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_INTERMEDIATE_REPORTS_ON_V02 = 1, /**<  Intermediate reports are turned on \n */
  eQMI_LOC_INTERMEDIATE_REPORTS_OFF_V02 = 2, /**<  Intermediate reports are turned off  */
  QMILOCINTERMEDIATEREPORTSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocIntermediateReportStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCONFIGINCLUDEALTITUDEASSUMEDINGNSSSVINFOENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_ENABLED_V02 = 1, /**<  Enable altitude assumed information in GNSS SV Info Event.\n  */
  eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_DISABLED_V02 = 2, /**<  Disable altitude assumed information in GNSS SV Info Event.  */
  QMILOCCONFIGINCLUDEALTITUDEASSUMEDINGNSSSVINFOENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocConfigIncludeAltitudeAssumedInGnssSvInfoEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  char applicationProvider[QMI_LOC_MAX_APP_ID_PROVIDER_LENGTH_V02 + 1];
  /**<   Application provider. */

  char applicationName[QMI_LOC_MAX_APP_ID_NAME_LENGTH_V02 + 1];
  /**<   Application name. */

  uint8_t applicationVersion_valid;
  /**<   Specifies whether the application version string contains
        a valid value: \n
        - 0x00 (FALSE) -- Application version string is invalid \n
        - 0x01 (TRUE) -- Application version string is valid
        */

  char applicationVersion[QMI_LOC_MAX_APP_ID_VERSION_LENGTH_V02 + 1];
  /**<   Application version. */
}qmiLocApplicationIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPOWERMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POWER_MODE_IMPROVED_ACCURACY_V02 = 1, /**<  The GNSS receiver operates in full power mode (non-DPO). \n  */
  eQMI_LOC_POWER_MODE_NORMAL_V02 = 2, /**<  The GNSS receiver operates with GNSS receiver autonomously
       duty cycling while meeting position criteria. \n */
  eQMI_LOC_POWER_MODE_BACKGROUND_DEFINED_POWER_V02 = 3, /**<  The GNSS receiver duty cycles at a variable rate to meet
       the target power budget. The power budget is defined as 1/N
       of the GNSS full power during 1 Hz navigation.\n
       N = timeBetweenMeasurement/1000. \n */
  eQMI_LOC_POWER_MODE_BACKGROUND_DEFINED_TIME_V02 = 4, /**<  The GNSS receiver duty cycles at a fixed time interval. \n */
  eQMI_LOC_POWER_MODE_BACKGROUND_KEEP_WARM_V02 = 5, /**<  The GNSS receiver operates in very-low power (less than 1mA)
       duty cycling mode, to keep GNSS receiver warm for faster signal
       acquisition & tracking.  */
  QMILOCPOWERMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPowerModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocPowerModeEnumT_v02 powerMode;
  /**<   GNSS power mode option to let the client choose the power-accuracy trade-off.
 Values: \n
      - eQMI_LOC_POWER_MODE_IMPROVED_ACCURACY (1) --  The GNSS receiver operates in full power mode (non-DPO). \n
      - eQMI_LOC_POWER_MODE_NORMAL (2) --  The GNSS receiver operates with GNSS receiver autonomously
       duty cycling while meeting position criteria. \n
      - eQMI_LOC_POWER_MODE_BACKGROUND_DEFINED_POWER (3) --  The GNSS receiver duty cycles at a variable rate to meet
       the target power budget. The power budget is defined as 1/N
       of the GNSS full power during 1 Hz navigation.\n
       N = timeBetweenMeasurement/1000. \n
      - eQMI_LOC_POWER_MODE_BACKGROUND_DEFINED_TIME (4) --  The GNSS receiver duty cycles at a fixed time interval. \n
      - eQMI_LOC_POWER_MODE_BACKGROUND_KEEP_WARM (5) --  The GNSS receiver operates in very-low power (less than 1mA)
       duty cycling mode, to keep GNSS receiver warm for faster signal
       acquisition & tracking.
 */

  uint32_t timeBetweenMeasurement;
  /**<   Maximum time interval between measurements,
       applies to the BACKGROUND_DEFINED_POWER and BACKGROUND_DEFINED_TIME
       power modes. For BACKGROUND_DEFINED_POWER, set timeBetweenMeasurement to 1000 * N;
       timeBetweenMeasurement is ignored for the other power modes. \n
       - Units -- Milliseconds
  */
}qmiLocPowerModeStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSPECIALREQENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SPECIAL_REQUEST_SHORT_CODE_V02 = 1, /**<  The QMI_LOC client requests for location fix with Special
       Service type set with Short Code, allow even when GPS and privacy NVs
       do not allow fix requests for this client.  */
  QMILOCSPECIALREQENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSpecialReqEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to initiate a GPS session. */
typedef struct {

  /* Mandatory */
  /*  Session ID */
  uint8_t sessionId;
  /**<   ID of the session as identified by the control point. The session ID
       is reported back in the position reports. The control point must
       specify the same session ID in the QMI_LOC_STOP_REQ request. \n
       - Range: 0 to 255
  */

  /* Optional */
  /*  Recurrence Type */
  uint8_t fixRecurrence_valid;  /**< Must be set to true if fixRecurrence is being passed */
  qmiLocFixRecurrenceEnumT_v02 fixRecurrence;
  /**<   Specifies the type of session in which the control point is interested.
 If this TLV is not specified, recurrence defaults to single. \n
 Values: \n
      - eQMI_LOC_RECURRENCE_PERIODIC (1) --  Request periodic position fixes \n
      - eQMI_LOC_RECURRENCE_SINGLE (2) --  Request a single position fix
 */

  /* Optional */
  /*  Horizontal Accuracy */
  uint8_t horizontalAccuracyLevel_valid;  /**< Must be set to true if horizontalAccuracyLevel is being passed */
  qmiLocAccuracyLevelEnumT_v02 horizontalAccuracyLevel;
  /**<   Specifies the horizontal accuracy level required by the control point.
 If not specified, accuracy defaults to LOW.
 Values: \n
      - eQMI_LOC_ACCURACY_LOW (1) --  Low accuracy \n
      - eQMI_LOC_ACCURACY_MED (2) --  Medium accuracy \n
      - eQMI_LOC_ACCURACY_HIGH (3) --  High accuracy
 */

  /* Optional */
  /*  Enable/Disable Intermediate Reports */
  uint8_t intermediateReportState_valid;  /**< Must be set to true if intermediateReportState is being passed */
  qmiLocIntermediateReportStateEnumT_v02 intermediateReportState;
  /**<   Specifies whether the control point is interested in receiving intermediate
 reports. The control point must explicitly set this field to OFF if it
 does not wish to receive intermediate position reports. Intermediate
 position reports are generated at 1 Hz and are ON by default. If
 intermediate reports are turned ON, the client receives position reports
 even if the accuracy criteria are not met. The status in such a position
 report is set to IN_PROGRESS for the control point to identify
 intermediate reports.
 Values: \n
      - eQMI_LOC_INTERMEDIATE_REPORTS_ON (1) --  Intermediate reports are turned on \n
      - eQMI_LOC_INTERMEDIATE_REPORTS_OFF (2) --  Intermediate reports are turned off
 */

  /* Optional */
  /*  Minimum Interval Between Final Position Reports */
  uint8_t minInterval_valid;  /**< Must be set to true if minInterval is being passed */
  uint32_t minInterval;
  /**<   Minimum time interval, specified by the control point, that must elapse between
       final position reports. \n
       - Units -- Milliseconds \n
       - Default -- 1000 ms
  */

  /* Optional */
  /*  ID of the Application that Sent this Request */
  uint8_t applicationId_valid;  /**< Must be set to true if applicationId is being passed */
  qmiLocApplicationIdStructT_v02 applicationId;
  /**<   \n Application provider, name, and version.*/

  /* Optional */
  /*  Configuration for Altitude Assumed Info in GNSS SV Info Event */
  uint8_t configAltitudeAssumed_valid;  /**< Must be set to true if configAltitudeAssumed is being passed */
  qmiLocConfigIncludeAltitudeAssumedInGnssSvInfoEnumT_v02 configAltitudeAssumed;
  /**<   Specifies the configuration to include altitude assumed information in the GNSS SV Info event.
 When enabled, an additional GNSS SV Info event indication is sent to the control
 point that also includes the altitude assumed information.
 If not specified, the configuration defaults to enabled.\n
 Values: \n
      - eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_ENABLED (1) --  Enable altitude assumed information in GNSS SV Info Event.\n
      - eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_DISABLED (2) --  Disable altitude assumed information in GNSS SV Info Event.
 */

  /* Optional */
  /*  Minimum Interval Between Intermediate Position Reports */
  uint8_t minIntermediatePositionReportInterval_valid;  /**< Must be set to true if minIntermediatePositionReportInterval is being passed */
  uint32_t minIntermediatePositionReportInterval;
  /**<   Minimum time interval for intermediate position reports, specified by the control point,
       that, between the position reports elapsed time, must be longer than the interval time.
       If this optional value is not set or set to the default value (0), the intermediate position
       is reported when it is ready. \n
       - Units -- Milliseconds \n
       - Default -- 0 milliseconds
  */

  /* Optional */
  /*  Maximum Wait Time to Get a Position Report */
  uint8_t positionReportTimeout_valid;  /**< Must be set to true if positionReportTimeout is being passed */
  uint32_t positionReportTimeout;
  /**<   Maximum time to work on each fix, specified by the control point.
       The GPS engine returns QMI_ERR_INTERNAL if a position cannot be obtained
       within the positionReportTimeout value. \n
       - Units -- Milliseconds \n
       - Default -- 255*1000 ms \n
       - Range -- 1000 - 255*1000 ms
  */

  /* Optional */
  /*  Share Position Report with Other Clients */
  uint8_t sharePosition_valid;  /**< Must be set to true if sharePosition is being passed */
  uint8_t sharePosition;
  /**<   Indicates whether to share the position report with the other QMI_LOC clients: \n
       - 0x00 (FALSE) -- Do not share \n
       - 0x01 (TRUE) -- Share \n
       If this optional TLV is not set, the GPS engine allows the position sharing.
  */

  /* Optional */
  /*  Report GNSS Only Position */
  uint8_t reportGnssOnlyPosition_valid;  /**< Must be set to true if reportGnssOnlyPosition is being passed */
  uint8_t reportGnssOnlyPosition;
  /**<   Requests the GPS engine to report positions that could be GNSS only or
       combined with other technologies, such as sensors. Values: \n
       - 0x00 (FALSE) -- Report GNSS only positions is disabled (default) \n
       - 0x01 (TRUE)  -- Report GNSS only positions is enabled
  */

  /* Optional */
  /*  GNSS Power Mode */
  uint8_t powerMode_valid;  /**< Must be set to true if powerMode is being passed */
  qmiLocPowerModeStructT_v02 powerMode;
  /**<   \n When the power mode is not set by the client,
       eQMI_LOC_POWER_MODE_NORMAL is the default value.
       When there are other clients with different powerMode settings,
       the GNSS receiver is configured as powerMode with the highest
       power consumption among the requesting clients.
  */

  /* Optional */
  /*  GNSS Special Request Type */
  uint8_t specialReqType_valid;  /**< Must be set to true if specialReqType is being passed */
  qmiLocSpecialReqEnumT_v02 specialReqType;
  /**<   QMI_LOC client requests for location fix with Special
 Service request types set, honor even when GPS and Privacy NVs
 do not allow fix requests for this client.
 If not set, ignore the field and process the client request
 according to GPS lock and privacy settings.
 Values: \n
      - eQMI_LOC_SPECIAL_REQUEST_SHORT_CODE (1) --  The QMI_LOC client requests for location fix with Special
       Service type set with Short Code, allow even when GPS and privacy NVs
       do not allow fix requests for this client.
 */
}qmiLocStartReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to stop a GPS session. */
typedef struct {

  /* Mandatory */
  /*   Session ID */
  uint8_t sessionId;
  /**<   ID of the session that was specified in the QMI_LOC_START_REQ request. \n
       - Range -- 0 to 255 */
}qmiLocStopReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocPosTechMaskT_v02;
#define QMI_LOC_POS_TECH_MASK_SATELLITE_V02 ((qmiLocPosTechMaskT_v02)0x00000001) /**<  Satellites were used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_CELLID_V02 ((qmiLocPosTechMaskT_v02)0x00000002) /**<  Cell towers were used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_WIFI_V02 ((qmiLocPosTechMaskT_v02)0x00000004) /**<  Wi-Fi access points were used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_SENSORS_V02 ((qmiLocPosTechMaskT_v02)0x00000008) /**<  Sensors were used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_REFERENCE_LOCATION_V02 ((qmiLocPosTechMaskT_v02)0x00000010) /**<  Reference location was used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION_V02 ((qmiLocPosTechMaskT_v02)0x00000020) /**<  Coarse position injected into the location engine was used to
        generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_AFLT_V02 ((qmiLocPosTechMaskT_v02)0x00000040) /**<  AFLT was used to generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_HYBRID_V02 ((qmiLocPosTechMaskT_v02)0x00000080) /**<  GNSS and network-provided measurements were used to
        generate the fix. \n  */
#define QMI_LOC_POS_TECH_MASK_DRE_V02 ((qmiLocPosTechMaskT_v02)0x00000100) /**<  Dead reckoning engine (DRE) was used to generate the fix.  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSESSIONSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SESS_STATUS_SUCCESS_V02 = 0, /**<  Session was successful \n  */
  eQMI_LOC_SESS_STATUS_IN_PROGRESS_V02 = 1, /**<  Session is still in progress; further position reports are generated
       until either the fix criteria specified by the client are met or the
       client response timeout occurs \n */
  eQMI_LOC_SESS_STATUS_GENERAL_FAILURE_V02 = 2, /**<  Session failed \n */
  eQMI_LOC_SESS_STATUS_TIMEOUT_V02 = 3, /**<  Fix request failed because the session timed out \n  */
  eQMI_LOC_SESS_STATUS_USER_END_V02 = 4, /**<  Fix request failed because the session was ended by the user \n  */
  eQMI_LOC_SESS_STATUS_BAD_PARAMETER_V02 = 5, /**<  Fix request failed due to bad parameters in the request \n */
  eQMI_LOC_SESS_STATUS_PHONE_OFFLINE_V02 = 6, /**<  Fix request failed because the phone is offline \n  */
  eQMI_LOC_SESS_STATUS_ENGINE_LOCKED_V02 = 7, /**<  Fix request failed because the engine is locked  */
  QMILOCSESSIONSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSessionStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gpsWeek;
  /**<   Current GPS week as calculated from midnight, Jan. 6, 1980. \n
       - Units -- Weeks */

  uint32_t gpsTimeOfWeekMs;
  /**<   Amount of time into the current GPS week. \n
       - Units -- Milliseconds */
}qmiLocGPSTimeStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  float PDOP;
  /**<   Position dilution of precision. \n
       - Range -- 0 (highest accuracy) to 50 (lowest accuracy) \n
       - PDOP = square root of (HDOP^2 + VDOP^2)
      */

  float HDOP;
  /**<   Horizontal dilution of precision. \n
       - Range -- 0 (highest accuracy) to 50 (lowest accuracy)
    */

  float VDOP;
  /**<   Vertical dilution of precision. \n
       - Range -- 0 (highest accuracy) to 50 (lowest accuracy)
       */
}qmiLocDOPStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  float PDOP;
  /**<   Position dilution of precision. \n
       - Range: 0 (highest accuracy) to 50 (lowest accuracy) \n
       - PDOP = square root of (HDOP\textsuperscript{2} + VDOP\textsuperscript{2})
     */

  float HDOP;
  /**<   Horizontal dilution of precision. \n
       - Range: 0 (highest accuracy) to 50 (lowest accuracy)
    */

  float VDOP;
  /**<   Vertical dilution of precision. \n
       - Range: 0 (highest accuracy) to 50 (lowest accuracy)
    */

  float GDOP;
  /**<   Geometric  dilution of precision. \n
       - Range -- 0 (highest accuracy) to 50 (lowest accuracy)
    */

  float TDOP;
  /**<   Time dilution of precision. \n
       - Range -- 0 (highest accuracy) to 50 (lowest accuracy)
    */
}qmiLocExtDOPStructT_v02;  /* Type */
/**
    @}
  */

typedef uint32_t qmiLocSensorUsageMaskT_v02;
#define QMI_LOC_SENSOR_MASK_USED_ACCEL_V02 ((qmiLocSensorUsageMaskT_v02)0x00000001) /**<  Bitmask specifying whether an accelerometer was used.  */
#define QMI_LOC_SENSOR_MASK_USED_GYRO_V02 ((qmiLocSensorUsageMaskT_v02)0x00000002) /**<  Bitmask specifying whether a gyroscope was used.  */
typedef uint32_t qmiLocSensorAidedMaskT_v02;
#define QMI_LOC_SENSOR_AIDED_MASK_HEADING_V02 ((qmiLocSensorAidedMaskT_v02)0x00000001) /**<  Bitmask specifying whether a sensor was used to calculate heading. \n  */
#define QMI_LOC_SENSOR_AIDED_MASK_SPEED_V02 ((qmiLocSensorAidedMaskT_v02)0x00000002) /**<  Bitmask specifying whether a sensor was used to calculate speed. \n */
#define QMI_LOC_SENSOR_AIDED_MASK_POSITION_V02 ((qmiLocSensorAidedMaskT_v02)0x00000004) /**<  Bitmask specifying whether a sensor was used to calculate position. \n   */
#define QMI_LOC_SENSOR_AIDED_MASK_VELOCITY_V02 ((qmiLocSensorAidedMaskT_v02)0x00000008) /**<  Bitmask specifying whether a sensor was used to calculate velocity.   */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSensorUsageMaskT_v02 usageMask;
  /**<   Specifies the sensors used in calculating the position in the
 position report.
 Valid bitmasks: \n
      - QMI_LOC_SENSOR_MASK_USED_ACCEL (0x00000001) --  Bitmask specifying whether an accelerometer was used.
      - QMI_LOC_SENSOR_MASK_USED_GYRO (0x00000002) --  Bitmask specifying whether a gyroscope was used.  */

  qmiLocSensorAidedMaskT_v02 aidingIndicatorMask;
  /**<   Specifies the results aided by sensors.
 Valid bitmasks: \n
      - QMI_LOC_SENSOR_AIDED_MASK_HEADING (0x00000001) --  Bitmask specifying whether a sensor was used to calculate heading. \n
      - QMI_LOC_SENSOR_AIDED_MASK_SPEED (0x00000002) --  Bitmask specifying whether a sensor was used to calculate speed. \n
      - QMI_LOC_SENSOR_AIDED_MASK_POSITION (0x00000004) --  Bitmask specifying whether a sensor was used to calculate position. \n
      - QMI_LOC_SENSOR_AIDED_MASK_VELOCITY (0x00000008) --  Bitmask specifying whether a sensor was used to calculate velocity.   */
}qmiLocSensorUsageIndicatorStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCTIMESOURCEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_TIME_SRC_INVALID_V02 = 0, /**<  Invalid time \n  */
  eQMI_LOC_TIME_SRC_NETWORK_TIME_TRANSFER_V02 = 1, /**<  Time is set by the 1X system \n  */
  eQMI_LOC_TIME_SRC_NETWORK_TIME_TAGGING_V02 = 2, /**<  Time is set by WCDMA/GSM time tagging (that is,
       associating network time with GPS time) \n  */
  eQMI_LOC_TIME_SRC_EXTERNAL_INPUT_V02 = 3, /**<  Time is set by an external injection \n  */
  eQMI_LOC_TIME_SRC_TOW_DECODE_V02 = 4, /**<  Time is set after decoding over-the-air GPS navigation data
       from one GPS satellite \n */
  eQMI_LOC_TIME_SRC_TOW_CONFIRMED_V02 = 5, /**<  Time is set after decoding over-the-air GPS navigation data
       from multiple satellites \n  */
  eQMI_LOC_TIME_SRC_TOW_AND_WEEK_CONFIRMED_V02 = 6, /**<  Both time of the week and the GPS week number are known \n  */
  eQMI_LOC_TIME_SRC_NAV_SOLUTION_V02 = 7, /**<  Time is set by the position engine after the fix is obtained \n */
  eQMI_LOC_TIME_SRC_SOLVE_FOR_TIME_V02 = 8, /**<  Time is set by the position engine after performing SFT;
       this is done when the clock time uncertainty is large \n  */
  eQMI_LOC_TIME_SRC_GLO_TOW_DECODE_V02 = 9, /**<  Time is set after decoding GLO satellites \n */
  eQMI_LOC_TIME_SRC_TIME_TRANSFORM_V02 = 10, /**<  Time is set after transforming the GPS to GLO time \n  */
  eQMI_LOC_TIME_SRC_WCDMA_SLEEP_TIME_TAGGING_V02 = 11, /**<  Time is set by the sleep time tag provided by the WCDMA network \n  */
  eQMI_LOC_TIME_SRC_GSM_SLEEP_TIME_TAGGING_V02 = 12, /**<  Time is set by the sleep time tag provided by the GSM network \n  */
  eQMI_LOC_TIME_SRC_UNKNOWN_V02 = 13, /**<  Source of the time is unknown \n */
  eQMI_LOC_TIME_SRC_SYSTEM_TIMETICK_V02 = 14, /**<  Time is derived from the system clock (better known as the slow clock);
       GNSS time is maintained irrespective of the GNSS receiver state \n  */
  eQMI_LOC_TIME_SRC_QZSS_TOW_DECODE_V02 = 15, /**<  Time is set after decoding QZSS satellites \n  */
  eQMI_LOC_TIME_SRC_BDS_TOW_DECODE_V02 = 16, /**<  Time is set after decoding BDS satellites \n  */
  eQMI_LOC_TIME_SRC_GAL_TOW_DECODE_V02 = 17, /**<  Time is set after decoding Galileo satellites \n   */
  eQMI_LOC_TIME_SRC_NAVIC_TOW_DECODE_V02 = 18, /**<  Time is set after decoding NavIC satellites  */
  QMILOCTIMESOURCEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocTimeSourceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCRELIABILITYENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_RELIABILITY_NOT_SET_V02 = 0, /**<  Location reliability is not set \n */
  eQMI_LOC_RELIABILITY_VERY_LOW_V02 = 1, /**<  Location reliability is very low; use it at your own risk \n  */
  eQMI_LOC_RELIABILITY_LOW_V02 = 2, /**<  Location reliability is low; little or no cross-checking is possible \n */
  eQMI_LOC_RELIABILITY_MEDIUM_V02 = 3, /**<  Location reliability is medium; limited cross-check passed \n  */
  eQMI_LOC_RELIABILITY_HIGH_V02 = 4, /**<  Location reliability is high; strong cross-check passed  */
  QMILOCRELIABILITYENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocReliabilityEnumT_v02;
/**
    @}
  */

typedef uint64_t qmiLocNavSolutionMaskT_v02;
#define QMI_LOC_NAV_MASK_SBAS_CORRECTION_IONO_V02 ((qmiLocNavSolutionMaskT_v02)0x00000001ull) /**<  Indicates SBAS ionospheric correction \n */
#define QMI_LOC_NAV_MASK_SBAS_CORRECTION_FAST_V02 ((qmiLocNavSolutionMaskT_v02)0x00000002ull) /**<  Indicates SBAS fast correction  \n  */
#define QMI_LOC_NAV_MASK_SBAS_CORRECTION_LONG_V02 ((qmiLocNavSolutionMaskT_v02)0x00000004ull) /**<  Indicates long-tem correction \n  */
#define QMI_LOC_NAV_MASK_SBAS_INTEGRITY_V02 ((qmiLocNavSolutionMaskT_v02)0x00000008ull) /**<  Indicates SBAS integrity information \n  */
#define QMI_LOC_NAV_MASK_CORRECTION_DGNSS_V02 ((qmiLocNavSolutionMaskT_v02)0x00000010ull) /**<  Indicates DGNSS information is used \n  */
#define QMI_LOC_NAV_MASK_ONLY_SBAS_CORRECTED_SV_USED_V02 ((qmiLocNavSolutionMaskT_v02)0x00000020ull) /**<  Only SBAS corrected SVs are used for the fix; \n
       if mask is not set, all-in-view SVs are used for fix    */
typedef uint32_t qmiLocSensorSubTechnologyMaskT_v02;
#define QMI_LOC_SENSOR_SUB_MASK_PDR_ENABLED_V02 ((qmiLocSensorSubTechnologyMaskT_v02)0x00000001) /**<  Indicates whether PDR is enabled \n */
#define QMI_LOC_SENSOR_SUB_MASK_PEDOMETER_ENABLED_V02 ((qmiLocSensorSubTechnologyMaskT_v02)0x00000002) /**<  Indicates whether a pedometer was used \n */
#define QMI_LOC_SENSOR_SUB_MASK_VEHICULAR_ENABLED_V02 ((qmiLocSensorSubTechnologyMaskT_v02)0x00000004) /**<  Indicates whether vehicular sensor assistance is enabled  */
typedef uint64_t qmiLocSpoofMaskT_v02;
#define QMI_LOC_POSITION_SPOOFED_V02 ((qmiLocSpoofMaskT_v02)0x00000001ull) /**<  Position \n  */
#define QMI_LOC_TIME_SPOOFED_V02 ((qmiLocSpoofMaskT_v02)0x00000002ull) /**<  Time \n */
#define QMI_LOC_NAVIGATION_DATA_SPOOFED_V02 ((qmiLocSpoofMaskT_v02)0x00000004ull) /**<  Navigation data  */
typedef uint64_t qmiLocGnssSignalTypeMaskT_v02;
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000001ull) /**<  GPS L1CA RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000002ull) /**<  GPS L1C RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000004ull) /**<  GPS L2C_L RF band \n  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000008ull) /**<  GPS L5_Q RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000010ull) /**<  GLONASS G1 (L1OF) RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000020ull) /**<  GLONASS G2 (L2OF) RF band \n  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000040ull) /**<  Galileo E1_C RF band \n  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000080ull) /**<  Galileo E5A_Q RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000100ull) /**<  Galileo E5B_Q RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000200ull) /**<  BeiDou B1_I RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000400ull) /**<  BeiDou B1C RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00000800ull) /**<  BeiDou B2_I RF band  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00001000ull) /**<  BeiDou B2A_I RF band \n  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00002000ull) /**<  QZSS L1CA RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00004000ull) /**<  QZSS L1S RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00008000ull) /**<  QZSS L2C_L RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00010000ull) /**<  QZSS L5_Q RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00020000ull) /**<  SBAS L1_CA RF band  */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00040000ull) /**<  NavIC L5 RF band \n */
#define QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q_V02 ((qmiLocGnssSignalTypeMaskT_v02)0x00080000ull) /**<  BeiDou B2A_Q RF band  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGNSSSIGNALTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GNSS_SIGNAL_TYPE_INVALID_V02 = 0, /**<  Invalid RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GPS_L1CA_V02 = 1, /**<  GPS L1CA RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GPS_L1C_V02 = 2, /**<  GPS L1C RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GPS_L2C_L_V02 = 3, /**<  GPS L2C_L RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GPS_L5_Q_V02 = 4, /**<  GPS L5_Q RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GLONASS_G1_V02 = 5, /**<  GLONASS G1 (L1OF) RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GLONASS_G2_V02 = 6, /**<  GLONASS G2 (L2OF) RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GALILEO_E1_C_V02 = 7, /**<  Galileo E1_C RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q_V02 = 8, /**<  Galileo E5A_Q RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q_V02 = 9, /**<  Galileo E5B_Q RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_BEIDOU_B1_I_V02 = 10, /**<  BeiDou B1_I RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_BEIDOU_B1C_V02 = 11, /**<  BeiDou B1C RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_BEIDOU_B2_I_V02 = 12, /**<  BeiDou B2_I RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I_V02 = 13, /**<  BeiDou B2A_I RF band \n  */
  eQMI_LOC_GNSS_SIGNAL_TYPE_QZSS_L1CA_V02 = 14, /**<  QZSS L1CA RF band\n  */
  eQMI_LOC_GNSS_SIGNAL_TYPE_QZSS_L1S_V02 = 15, /**<  QZSS L1S RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_QZSS_L2C_L_V02 = 16, /**<  QZSS L2C_L RF band \n  */
  eQMI_LOC_GNSS_SIGNAL_TYPE_QZSS_L5_Q_V02 = 17, /**<  QZSS L5_Q RF band \n  */
  eQMI_LOC_GNSS_SIGNAL_TYPE_SBAS_L1_CA_V02 = 18, /**<  SBAS L1_CA RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_NAVIC_L5_V02 = 19, /**<  NavIC L5 RF band \n */
  eQMI_LOC_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q_V02 = 20, /**<  BeiDou B2A_Q RF band  */
  QMILOCGNSSSIGNALTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGnssSignalTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  int32_t agcMetricDb;
  /**<   AGC metric in 0.01 dB */

  int32_t bpMetricDb;
  /**<   BP metric in 0.01 dB */
}qmiLocJammerIndicatorStructT_v02;  /* Type */
/**
    @}
  */

typedef uint64_t qmiLocGNSSConstellEnumT_v02;
#define eQMI_SYSTEM_GPS_V02 ((qmiLocGNSSConstellEnumT_v02)0x01ull) /**<  Enable GPS \n  */
#define eQMI_SYSTEM_GLO_V02 ((qmiLocGNSSConstellEnumT_v02)0x02ull) /**<  Enable GLONASS \n  */
#define eQMI_SYSTEM_BDS_V02 ((qmiLocGNSSConstellEnumT_v02)0x04ull) /**<  Enable BDS \n  */
#define eQMI_SYSTEM_GAL_V02 ((qmiLocGNSSConstellEnumT_v02)0x08ull) /**<  Enable Galileo \n */
#define eQMI_SYSTEM_QZSS_V02 ((qmiLocGNSSConstellEnumT_v02)0x10ull) /**<  Enable QZSS \n */
#define eQMI_SYSTEM_NAVIC_V02 ((qmiLocGNSSConstellEnumT_v02)0x20ull) /**<  Enable NavIC  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDGNSSCORRECTIONSOURCETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_INVALID_V02 = 0, /**<  Invalid DGNSS correction source type \n */
  eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_RTCM_V02 = 1, /**<  DGNSS correction source type RTCM \n */
  eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_3GPP_V02 = 2, /**<  DGNSS correction source type 3GPP  */
  QMILOCDGNSSCORRECTIONSOURCETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDgnssCorrectionSourceTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the position report to the control point. */
typedef struct {

  /* Mandatory */
  /*  Session Status */
  qmiLocSessionStatusEnumT_v02 sessionStatus;
  /**<   Session status. Values: \n
      - eQMI_LOC_SESS_STATUS_SUCCESS (0) --  Session was successful \n
      - eQMI_LOC_SESS_STATUS_IN_PROGRESS (1) --  Session is still in progress; further position reports are generated
       until either the fix criteria specified by the client are met or the
       client response timeout occurs \n
      - eQMI_LOC_SESS_STATUS_GENERAL_FAILURE (2) --  Session failed \n
      - eQMI_LOC_SESS_STATUS_TIMEOUT (3) --  Fix request failed because the session timed out \n
      - eQMI_LOC_SESS_STATUS_USER_END (4) --  Fix request failed because the session was ended by the user \n
      - eQMI_LOC_SESS_STATUS_BAD_PARAMETER (5) --  Fix request failed due to bad parameters in the request \n
      - eQMI_LOC_SESS_STATUS_PHONE_OFFLINE (6) --  Fix request failed because the phone is offline \n
      - eQMI_LOC_SESS_STATUS_ENGINE_LOCKED (7) --  Fix request failed because the engine is locked
 */

  /* Mandatory */
  /*  Session ID */
  uint8_t sessionId;
  /**<    ID of the session specified in the QMI_LOC_START_REQ request. \n
        - Range: 0 to 255 */

  /* Optional */
  /*  Latitude */
  uint8_t latitude_valid;  /**< Must be set to true if latitude is being passed */
  double latitude;
  /**<   Latitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0 \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
    */

  /* Optional */
  /*  Longitude */
  uint8_t longitude_valid;  /**< Must be set to true if longitude is being passed */
  double longitude;
  /**<   Longitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0  \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
     */

  /* Optional */
  /*  Circular Horizontal Position Uncertainty */
  uint8_t horUncCircular_valid;  /**< Must be set to true if horUncCircular is being passed */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty (Semi-Minor Axis) */
  uint8_t horUncEllipseSemiMinor_valid;  /**< Must be set to true if horUncEllipseSemiMinor is being passed */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty (Semi-Major Axis) */
  uint8_t horUncEllipseSemiMajor_valid;  /**< Must be set to true if horUncEllipseSemiMajor is being passed */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  Elliptical Horizontal Uncertainty Azimuth */
  uint8_t horUncEllipseOrientAzimuth_valid;  /**< Must be set to true if horUncEllipseOrientAzimuth is being passed */
  float horUncEllipseOrientAzimuth;
  /**<   Elliptical horizontal uncertainty azimuth of orientation.\n
       - Units -- Decimal degrees \n
       - Range -- 0 to 180 */

  /* Optional */
  /*  Horizontal Confidence */
  uint8_t horConfidence_valid;  /**< Must be set to true if horConfidence is being passed */
  uint8_t horConfidence;
  /**<   Horizontal uncertainty confidence.
       If both elliptical and horizontal uncertainties are specified in this message,
       the confidence corresponds to the elliptical uncertainty. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horReliability_valid;  /**< Must be set to true if horReliability is being passed */
  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Horizontal Speed */
  uint8_t speedHorizontal_valid;  /**< Must be set to true if speedHorizontal is being passed */
  float speedHorizontal;
  /**<   Horizontal speed.\n
       - Units -- Meters per second  */

  /* Optional */
  /*  Speed Uncertainty */
  uint8_t speedUnc_valid;  /**< Must be set to true if speedUnc is being passed */
  float speedUnc;
  /**<   3D speed uncertainty.\n
       - Units -- Meters per second */

  /* Optional */
  /*  Altitude With Respect to Ellipsoid */
  uint8_t altitudeWrtEllipsoid_valid;  /**< Must be set to true if altitudeWrtEllipsoid is being passed */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range-- -500 to 15883 */

  /* Optional */
  /*  Altitude With Respect to Sea Level */
  uint8_t altitudeWrtMeanSeaLevel_valid;  /**< Must be set to true if altitudeWrtMeanSeaLevel is being passed */
  float altitudeWrtMeanSeaLevel;
  /**<   Altitude with respect to mean sea level.\n
       - Units -- Meters */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   - Units -- Meters */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Reliability */
  uint8_t vertReliability_valid;  /**< Must be set to true if vertReliability is being passed */
  qmiLocReliabilityEnumT_v02 vertReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Vertical Speed */
  uint8_t speedVertical_valid;  /**< Must be set to true if speedVertical is being passed */
  float speedVertical;
  /**<   Units -- Meters per second. */

  /* Optional */
  /*  Heading */
  uint8_t heading_valid;  /**< Must be set to true if heading is being passed */
  float heading;
  /**<   - Units -- Degrees \n
         - Range -- 0 to 359.999  */

  /* Optional */
  /*  Heading Uncertainty */
  uint8_t headingUnc_valid;  /**< Must be set to true if headingUnc is being passed */
  float headingUnc;
  /**<   - Units -- Degrees \n
       - Range -- 0 to 359.999 */

  /* Optional */
  /*  Magnetic Deviation */
  uint8_t magneticDeviation_valid;  /**< Must be set to true if magneticDeviation is being passed */
  float magneticDeviation;
  /**<   Difference between the bearing to true north and the bearing shown
      on a magnetic compass. The deviation is positive when the magnetic
      north is east of true north. */

  /* Optional */
  /*  Technology Used */
  uint8_t technologyMask_valid;  /**< Must be set to true if technologyMask is being passed */
  qmiLocPosTechMaskT_v02 technologyMask;
  /**<   Technology used in computing this fix.
 Valid bitmasks: \n
      - QMI_LOC_POS_TECH_MASK_SATELLITE (0x00000001) --  Satellites were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_CELLID (0x00000002) --  Cell towers were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_WIFI (0x00000004) --  Wi-Fi access points were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_SENSORS (0x00000008) --  Sensors were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_REFERENCE_LOCATION (0x00000010) --  Reference location was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION (0x00000020) --  Coarse position injected into the location engine was used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_AFLT (0x00000040) --  AFLT was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_HYBRID (0x00000080) --  GNSS and network-provided measurements were used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_DRE (0x00000100) --  Dead reckoning engine (DRE) was used to generate the fix.
 */

  /* Optional */
  /*  Dilution of Precision */
  uint8_t DOP_valid;  /**< Must be set to true if DOP is being passed */
  qmiLocDOPStructT_v02 DOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds since Jan. 1, 1970. */

  /* Optional */
  /*  Leap Seconds */
  uint8_t leapSeconds_valid;  /**< Must be set to true if leapSeconds is being passed */
  uint8_t leapSeconds;
  /**<   Leap second information. If leapSeconds is not available,
         timestampUtc is calculated based on a hard-coded value
         for leap seconds. \n
         - Units -- Seconds */

  /* Optional */
  /*  GPS Time */
  uint8_t gpsTime_valid;  /**< Must be set to true if gpsTime is being passed */
  qmiLocGPSTimeStructT_v02 gpsTime;
  /**<   \vspace{0.06in} \n The number of weeks since Jan. 6, 1980, and
       milliseconds into the current week. */

  /* Optional */
  /*  Time Uncertainty */
  uint8_t timeUnc_valid;  /**< Must be set to true if timeUnc is being passed */
  float timeUnc;
  /**<   Units -- Milliseconds. */

  /* Optional */
  /*  Time Source */
  uint8_t timeSrc_valid;  /**< Must be set to true if timeSrc is being passed */
  qmiLocTimeSourceEnumT_v02 timeSrc;
  /**<   Values: \n
      - eQMI_LOC_TIME_SRC_INVALID (0) --  Invalid time \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TRANSFER (1) --  Time is set by the 1X system \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TAGGING (2) --  Time is set by WCDMA/GSM time tagging (that is,
       associating network time with GPS time) \n
      - eQMI_LOC_TIME_SRC_EXTERNAL_INPUT (3) --  Time is set by an external injection \n
      - eQMI_LOC_TIME_SRC_TOW_DECODE (4) --  Time is set after decoding over-the-air GPS navigation data
       from one GPS satellite \n
      - eQMI_LOC_TIME_SRC_TOW_CONFIRMED (5) --  Time is set after decoding over-the-air GPS navigation data
       from multiple satellites \n
      - eQMI_LOC_TIME_SRC_TOW_AND_WEEK_CONFIRMED (6) --  Both time of the week and the GPS week number are known \n
      - eQMI_LOC_TIME_SRC_NAV_SOLUTION (7) --  Time is set by the position engine after the fix is obtained \n
      - eQMI_LOC_TIME_SRC_SOLVE_FOR_TIME (8) --  Time is set by the position engine after performing SFT;
       this is done when the clock time uncertainty is large \n
      - eQMI_LOC_TIME_SRC_GLO_TOW_DECODE (9) --  Time is set after decoding GLO satellites \n
      - eQMI_LOC_TIME_SRC_TIME_TRANSFORM (10) --  Time is set after transforming the GPS to GLO time \n
      - eQMI_LOC_TIME_SRC_WCDMA_SLEEP_TIME_TAGGING (11) --  Time is set by the sleep time tag provided by the WCDMA network \n
      - eQMI_LOC_TIME_SRC_GSM_SLEEP_TIME_TAGGING (12) --  Time is set by the sleep time tag provided by the GSM network \n
      - eQMI_LOC_TIME_SRC_UNKNOWN (13) --  Source of the time is unknown \n
      - eQMI_LOC_TIME_SRC_SYSTEM_TIMETICK (14) --  Time is derived from the system clock (better known as the slow clock);
       GNSS time is maintained irrespective of the GNSS receiver state \n
      - eQMI_LOC_TIME_SRC_QZSS_TOW_DECODE (15) --  Time is set after decoding QZSS satellites \n
      - eQMI_LOC_TIME_SRC_BDS_TOW_DECODE (16) --  Time is set after decoding BDS satellites \n
      - eQMI_LOC_TIME_SRC_GAL_TOW_DECODE (17) --  Time is set after decoding Galileo satellites \n
      - eQMI_LOC_TIME_SRC_NAVIC_TOW_DECODE (18) --  Time is set after decoding NavIC satellites  */

  /* Optional */
  /*  Sensor Data Usage */
  uint8_t sensorDataUsage_valid;  /**< Must be set to true if sensorDataUsage is being passed */
  qmiLocSensorUsageIndicatorStructT_v02 sensorDataUsage;
  /**<   \vspace{0.06in} \n Indicates whether sensor data was used in computing the position in this
       position report. */

  /* Optional */
  /*  Fix Count for This Session */
  uint8_t fixId_valid;  /**< Must be set to true if fixId is being passed */
  uint32_t fixId;
  /**<   Fix count for the session; starts with 0 and increments by one
       for each successive position report for a particular session. */

  /* Optional */
  /*  SVs Used to Calculate the Fix */
  uint8_t gnssSvUsedList_valid;  /**< Must be set to true if gnssSvUsedList is being passed */
  uint32_t gnssSvUsedList_len;  /**< Must be set to # of elements in gnssSvUsedList */
  uint16_t gnssSvUsedList[QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
      used for calculating this position report. The following
      information is associated with each SV ID: \n
      Range: \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96 \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414
      */

  /* Optional */
  /*  Altitude Assumed */
  uint8_t altitudeAssumed_valid;  /**< Must be set to true if altitudeAssumed is being passed */
  uint8_t altitudeAssumed;
  /**<   Indicates whether altitude is assumed or calculated: \n
       - 0x00 (FALSE) -- Calculated \n
       - 0x01 (TRUE) -- Assumed; there might not be enough
                                 satellites to determine the precise altitude
        */

  /* Optional */
  /*  Velocity ENU (East, North, Up) */
  uint8_t velEnu_valid;  /**< Must be set to true if velEnu is being passed */
  float velEnu[QMI_LOC_ENU_ARRAY_LENGTH_V02];
  /**<   East, North, up velocity. \n
       - Units -- Meters per second */

  /* Optional */
  /*  Velocity Uncertainty ENU */
  uint8_t velUncEnu_valid;  /**< Must be set to true if velUncEnu is being passed */
  float velUncEnu[QMI_LOC_ENU_ARRAY_LENGTH_V02];
  /**<   East, North, up velocity uncertainty. \n
       - Units -- Meters per second */

  /* Optional */
  /*  Navigation solution */
  uint8_t navSolutionMask_valid;  /**< Must be set to true if navSolutionMask is being passed */
  qmiLocNavSolutionMaskT_v02 navSolutionMask;
  /**<   Navigation solutions that are used to calculate
 the GNSS position report.
 Valid bitmasks specifying whether the following is used: \n
      - QMI_LOC_NAV_MASK_SBAS_CORRECTION_IONO (0x00000001) --  Indicates SBAS ionospheric correction \n
      - QMI_LOC_NAV_MASK_SBAS_CORRECTION_FAST (0x00000002) --  Indicates SBAS fast correction  \n
      - QMI_LOC_NAV_MASK_SBAS_CORRECTION_LONG (0x00000004) --  Indicates long-tem correction \n
      - QMI_LOC_NAV_MASK_SBAS_INTEGRITY (0x00000008) --  Indicates SBAS integrity information \n
      - QMI_LOC_NAV_MASK_CORRECTION_DGNSS (0x00000010) --  Indicates DGNSS information is used \n
      - QMI_LOC_NAV_MASK_ONLY_SBAS_CORRECTED_SV_USED (0x00000020) --  Only SBAS corrected SVs are used for the fix; \n
       if mask is not set, all-in-view SVs are used for fix
 */

  /* Optional */
  /*  Sensor Subtechnology Information */
  uint8_t sensorSubTechnologyMask_valid;  /**< Must be set to true if sensorSubTechnologyMask is being passed */
  qmiLocSensorSubTechnologyMaskT_v02 sensorSubTechnologyMask;
  /**<   Valid bitmasks: \n
      - QMI_LOC_SENSOR_SUB_MASK_PDR_ENABLED (0x00000001) --  Indicates whether PDR is enabled \n
      - QMI_LOC_SENSOR_SUB_MASK_PEDOMETER_ENABLED (0x00000002) --  Indicates whether a pedometer was used \n
      - QMI_LOC_SENSOR_SUB_MASK_VEHICULAR_ENABLED (0x00000004) --  Indicates whether vehicular sensor assistance is enabled
 */

  /* Optional */
  /*  GNSS Only Position Report */
  uint8_t gnssOnlyPosition_valid;  /**< Must be set to true if gnssOnlyPosition is being passed */
  uint8_t gnssOnlyPosition;
  /**<   Indicates whether this position report is generated from GNSS only technology.
       Values: \n
       - 0x00 (FALSE) -- Generated with other technologies (default) \n
       - 0x01 (TRUE)  -- Generated from GNSS technology only
  */

  /* Optional */
  /*  Extended Dilution of Precision */
  uint8_t extDOP_valid;  /**< Must be set to true if extDOP is being passed */
  qmiLocExtDOPStructT_v02 extDOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  Differential correction source ID */
  uint8_t dgnssStationId_valid;  /**< Must be set to true if dgnssStationId is being passed */
  uint32_t dgnssStationId_len;  /**< Must be set to # of elements in dgnssStationId */
  uint16_t dgnssStationId[QMI_LOC_DGNSS_STATION_ID_ARRAY_LENGTH_V02];
  /**<   List of DGNSS station IDs providing corrections. \n
       Range:   \n
       - SBAS --  120 to 158 and 183 to 191. \n
       - Monitoring station -- 1000-2023 (Station ID biased by 1000). \n
       - Other values reserved.
  */

  /* Optional */
  /*  Spoof Report */
  uint8_t spoofReportMask_valid;  /**< Must be set to true if spoofReportMask is being passed */
  qmiLocSpoofMaskT_v02 spoofReportMask;
  /**<   The set bit indicates the domain that is suspected to be spoofed.
 Valid bitmasks: \n
      - QMI_LOC_POSITION_SPOOFED (0x00000001) --  Position \n
      - QMI_LOC_TIME_SPOOFED (0x00000002) --  Time \n
      - QMI_LOC_NAVIGATION_DATA_SPOOFED (0x00000004) --  Navigation data
 */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   If the service reports expandedGnssSvUsedList, gnssSvUsedList is
       not reported. Each entry in the list contains the SV ID of a satellite
       used to calculate this position report. The following
       information is associated with each SV ID. \n
       Range: \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96 \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414
      */

  /* Optional */
  /*  SVs Signal Types in the SVs Used list */
  uint8_t gnssSvUsedSignalTypeList_valid;  /**< Must be set to true if gnssSvUsedSignalTypeList is being passed */
  uint32_t gnssSvUsedSignalTypeList_len;  /**< Must be set to # of elements in gnssSvUsedSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSvUsedSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedGnssSvUsedList. The
 signal type list is aligned with the SVs in expandedGnssSvUsedList. Value of 0
 means invalid.
 Valid bitmasks: \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band
 */

  /* Optional */
  /*  Jammer Indicator of each GNSS Signal */
  uint8_t jammerIndicatorList_valid;  /**< Must be set to true if jammerIndicatorList is being passed */
  uint32_t jammerIndicatorList_len;  /**< Must be set to # of elements in jammerIndicatorList */
  qmiLocJammerIndicatorStructT_v02 jammerIndicatorList[QMI_LOC_MAX_GNSS_SIGNAL_TYPE_V02];
  /**<   Indicates the jammer indicator of each signal.
  */

  /* Optional */
  /*  DGNSS Correction Source  */
  uint8_t dgnssCorrectionSource_valid;  /**< Must be set to true if dgnssCorrectionSource is being passed */
  qmiLocDgnssCorrectionSourceTypeEnumT_v02 dgnssCorrectionSource;
  /**<   DGNSS correction source for position report.\n
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_INVALID (0) --  Invalid DGNSS correction source type \n
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_RTCM (1) --  DGNSS correction source type RTCM \n
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_3GPP (2) --  DGNSS correction source type 3GPP
 */

  /* Optional */
  /*  DGNSS Correction Source ID */
  uint8_t dgnssCorrectionSourceID_valid;  /**< Must be set to true if dgnssCorrectionSourceID is being passed */
  uint32_t dgnssCorrectionSourceID;
  /**<   SourceID is a 32-bit number identifying the DGNSS source ID for position report.
  */

  /* Optional */
  /*  DGNSS Constellation Usage */
  uint8_t dgnssConstellationUsage_valid;  /**< Must be set to true if dgnssConstellationUsage is being passed */
  qmiLocGNSSConstellEnumT_v02 dgnssConstellationUsage;
  /**<   Constellation mask providing the constellations used
       along with DGNSS to produce the position report.
  */

  /* Optional */
  /*  DGNSS Reference Station ID */
  uint8_t dgnssRefStationId_valid;  /**< Must be set to true if dgnssRefStationId is being passed */
  uint16_t dgnssRefStationId;
  /**<   Reference station ID used to produce the position report.
       Range: \n
       - 0 -- 4095
  */

  /* Optional */
  /*  DGNSS Data Age  */
  uint8_t dgnssDataAgeMsec_valid;  /**< Must be set to true if dgnssDataAgeMsec is being passed */
  uint32_t dgnssDataAgeMsec;
  /**<   Age of differential data in milliseconds with reference to the fix time.
  */

  /* Optional */
  /*  Conformity Index */
  uint8_t conformityIndex_valid;  /**< Must be set to true if conformityIndex is being passed */
  float conformityIndex;
  /**<   Indicates how well the various input data considered for navigation solution conforms to expectations. \n
       - Range -- 0 (least conforming) to 1 (most conforming)
  */

  /* Optional */
  /*  System Tick at GPS Time */
  uint8_t systemTick_valid;  /**< Must be set to true if systemTick is being passed */
  uint64_t systemTick;
  /**<   System tick at GPS time of week. */

  /* Optional */
  /*  Uncertainty for System Tick at GPS Time */
  uint8_t systemTickUnc_valid;  /**< Must be set to true if systemTickUnc is being passed */
  float systemTickUnc;
  /**<   Uncertainty for system tick at GPS time of week. \n
       - Units -- milliseconds
  */

  /* Optional */
  /*  System Clock Time Bias */
  uint8_t systemClkTimeBias_valid;  /**< Must be set to true if systemClkTimeBias is being passed */
  float systemClkTimeBias;
  /**<   System clock time bias (submilliseconds). \n
         - Units -- Milliseconds
        (system time = systemMsec - systemClkTimeBias)
    */

  /* Optional */
  /*  Uncertainty for System Clock Time Bias */
  uint8_t systemClkTimeBiasUnc_valid;  /**< Must be set to true if systemClkTimeBiasUnc is being passed */
  float systemClkTimeBiasUnc;
  /**<   Single-sided maximum time bias uncertainty.\n
       - Units -- Milliseconds
  */
}qmiLocEventPositionReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSVSYSTEMENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SV_SYSTEM_GPS_V02 = 1, /**<  GPS satellite \n */
  eQMI_LOC_SV_SYSTEM_GALILEO_V02 = 2, /**<  Galileo satellite \n */
  eQMI_LOC_SV_SYSTEM_SBAS_V02 = 3, /**<  SBAS satellite \n */
  eQMI_LOC_SV_SYSTEM_COMPASS_V02 = 4, /**<  COMPASS satellite (Deprecated) \n */
  eQMI_LOC_SV_SYSTEM_GLONASS_V02 = 5, /**<  GLONASS satellite \n */
  eQMI_LOC_SV_SYSTEM_BDS_V02 = 6, /**<  BDS satellite \n */
  eQMI_LOC_SV_SYSTEM_QZSS_V02 = 7, /**<  QZSS satellite \n */
  eQMI_LOC_SV_SYSTEM_NAVIC_V02 = 8, /**<  NavIC satellite  */
  QMILOCSVSYSTEMENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSvSystemEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSVSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SV_STATUS_IDLE_V02 = 1, /**<  SV is not being actively processed \n  */
  eQMI_LOC_SV_STATUS_SEARCH_V02 = 2, /**<  The system is searching for this SV \n */
  eQMI_LOC_SV_STATUS_TRACK_V02 = 3, /**<  SV is being tracked  */
  QMILOCSVSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSvStatusEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocSvInfoValidMaskT_v02;
#define QMI_LOC_SV_INFO_MASK_VALID_SYSTEM_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000001) /**<  System field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_GNSS_SVID_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000002) /**<  gnssSvId field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_HEALTH_STATUS_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000004) /**<  healthStatus field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_PROCESS_STATUS_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000008) /**<  processStatus field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_SVINFO_MASK_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000010) /**<  svInfoMask field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_ELEVATION_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000020) /**<  Elevation field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_AZIMUTH_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000040) /**<  Azimuth field is valid in SV information  */
#define QMI_LOC_SV_INFO_MASK_VALID_SNR_V02 ((qmiLocSvInfoValidMaskT_v02)0x00000080) /**<  SNR field is valid in SV information  */
typedef uint8_t qmiLocSvInfoMaskT_v02;
#define QMI_LOC_SVINFO_MASK_HAS_EPHEMERIS_V02 ((qmiLocSvInfoMaskT_v02)0x01) /**<  Ephemeris is available for this SV  */
#define QMI_LOC_SVINFO_MASK_HAS_ALMANAC_V02 ((qmiLocSvInfoMaskT_v02)0x02) /**<  Almanac is available for this SV  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSvInfoValidMaskT_v02 validMask;
  /**<   Bitmask indicating which of the fields in this TLV are valid.\n
 Valid bitmasks:
      - QMI_LOC_SV_INFO_MASK_VALID_SYSTEM (0x00000001) --  System field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_GNSS_SVID (0x00000002) --  gnssSvId field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_HEALTH_STATUS (0x00000004) --  healthStatus field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_PROCESS_STATUS (0x00000008) --  processStatus field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_SVINFO_MASK (0x00000010) --  svInfoMask field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_ELEVATION (0x00000020) --  Elevation field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_AZIMUTH (0x00000040) --  Azimuth field is valid in SV information
      - QMI_LOC_SV_INFO_MASK_VALID_SNR (0x00000080) --  SNR field is valid in SV information */

  qmiLocSvSystemEnumT_v02 system;
  /**<   Indicates to which constellation this SV belongs.\n
 Values: \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite
 */

  uint16_t gnssSvId;
  /**<   GNSS SV ID.
         Range:  \n
         - GPS --    1 to 32 \n
         - GLONASS -- 1 to 32 \n
         - SBAS --   120 to 158 and 183 to 191 \n
         - QZSS --   193 to 197 \n
         - BDS --    201 to 263 \n
         - Galileo -- 301 to 336 \n
         - NavIC --  401 to 414 \n

        The GPS and GLONASS SVs can be disambiguated using the system field. */

  uint8_t healthStatus;
  /**<   Health status.
         Range -- 0 to 1 \n
         - 0 -- Unhealthy \n
         - 1 -- Healthy
         */

  qmiLocSvStatusEnumT_v02 svStatus;
  /**<   SV processing status.
 Values: \n
      - eQMI_LOC_SV_STATUS_IDLE (1) --  SV is not being actively processed \n
      - eQMI_LOC_SV_STATUS_SEARCH (2) --  The system is searching for this SV \n
      - eQMI_LOC_SV_STATUS_TRACK (3) --  SV is being tracked
 */

  qmiLocSvInfoMaskT_v02 svInfoMask;
  /**<   Indicates whether almanac and ephemeris information is available. \n
         Valid bitmasks:\n
           - 0x01 -- SVINFO_HAS_EPHEMERIS \n
           - 0x02 -- SVINFO_HAS_ALMANAC
    */

  float elevation;
  /**<   SV elevation angle.\n
         - Units -- Degrees \n
         - Range -- 0 to 90 */

  float azimuth;
  /**<   SV azimuth angle.\n
         - Units -- Degrees \n
         - Range -- 0 to 360 */

  float snr;
  /**<   SV signal-to-noise ratio at antenna. \n
         - Units -- dB-Hz */
}qmiLocSvInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSvInfoStructT_v02 svInfo;
  /**<   SV information. */

  uint8_t gloFrequency;
  /**<   GLONASS frequency number + 8.
       Valid only for GLONASS systems and
       must be ignored for all other systems. \n
       - Range -- 1 to 14
  */
}qmiLocExpandedSvInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a satellite report to the control point. */
typedef struct {

  /* Mandatory */
  /*  Altitude Assumed */
  uint8_t altitudeAssumed;
  /**<   Indicates whether altitude is assumed or calculated: \n
         -  0x00 (FALSE) -- Valid altitude is calculated \n
         -  0x01 (TRUE) -- Valid altitude is assumed; there might not be
                                 enough satellites to determine precise altitude
         */

  /* Optional */
  /*  Satellite Information */
  uint8_t svList_valid;  /**< Must be set to true if svList is being passed */
  uint32_t svList_len;  /**< Must be set to # of elements in svList */
  qmiLocSvInfoStructT_v02 svList[QMI_LOC_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   \vspace{0.06in} \n SV information list. */

  /* Optional */
  /*  Expanded Satellite Information */
  uint8_t expandedSvList_valid;  /**< Must be set to true if expandedSvList is being passed */
  uint32_t expandedSvList_len;  /**< Must be set to # of elements in expandedSvList */
  qmiLocExpandedSvInfoStructT_v02 expandedSvList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   \vspace{0.06in} \n Expanded SV information list. If the service reports
       expandedSvList, svList is not reported.*/

  /* Optional */
  /*  Satellite Signal Type */
  uint8_t gnssSignalTypeList_valid;  /**< Must be set to true if gnssSignalTypeList is being passed */
  uint32_t gnssSignalTypeList_len;  /**< Must be set to # of elements in gnssSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedSvList. The
 signal type list is aligned with the SVs in svList. Value of 0 means
 invalid.
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */

  /* Optional */
  /*  RF Loss from Antenna to Baseband */
  uint8_t rfLoss_valid;  /**< Must be set to true if rfLoss is being passed */
  uint32_t rfLoss_len;  /**< Must be set to # of elements in rfLoss */
  float rfLoss[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the RF loss from antenna to baseband of each satellite in expandedSvList.
       rfLoss is aligned with the SVs in expandedSvList.\n
       - Units -- dB-Hz \n
  */
}qmiLocEventGnssSvInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends NMEA sentences to the control point. */
typedef struct {

  /* Mandatory */
  /*  NMEA String */
  char nmea[QMI_LOC_NMEA_STRING_MAX_LENGTH_V02 + 1];
  /**<   NMEA string. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL-terminator) -- 201
    */

  /* Optional */
  /*  Expanded NMEA String */
  uint8_t expandedNmea_valid;  /**< Must be set to true if expandedNmea is being passed */
  char expandedNmea[QMI_LOC_EXPANDED_NMEA_STRING_MAX_LENGTH_V02 + 1];
  /**<   Expanded NMEA string; when the service reports expandedNmea, the
       mandatory NMEA string is empty. \n
       - Type -- NULL-terminated string \n
       - Expanded maximum string length (including NULL-terminator) -- 4096
    */
}qmiLocEventNmeaIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNINOTIFYVERIFYENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_USER_NO_NOTIFY_NO_VERIFY_V02 = 1, /**<  No notification and no verification required \n */
  eQMI_LOC_NI_USER_NOTIFY_ONLY_V02 = 2, /**<  Notify only; no verification required \n  */
  eQMI_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP_V02 = 3, /**<  Notify and verify, but no response required. \n */
  eQMI_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP_V02 = 4, /**<  Notify and verify, and require a response \n */
  eQMI_LOC_NI_USER_NOTIFY_VERIFY_PRIVACY_OVERRIDE_V02 = 5, /**<  Notify and verify; privacy override  */
  QMILOCNINOTIFYVERIFYENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiNotifyVerifyEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNIVXPOSMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_VX_MS_ASSISTED_ONLY_V02 = 1, /**<  MS-assisted only allowed \n */
  eQMI_LOC_NI_VX_MS_BASED_ONLY_V02 = 2, /**<  MS-based only allowed \n */
  eQMI_LOC_NI_VX_MS_ASSISTED_PREFERRED_MS_BASED_ALLOWED_V02 = 3, /**<  MS-assisted preferred, but MS-based allowed \n */
  eQMI_LOC_NI_VX_MS_BASED_PREFERRED_MS_ASSISTED_ALLOWED_V02 = 4, /**<  MS-based preferred, but MS-assisted allowed  */
  QMILOCNIVXPOSMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiVxPosModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNIVXREQUESTORIDENCODINGSCHEMEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_VX_OCTET_V02 = 0, /**<  Encoding is Octet \n */
  eQMI_LOC_NI_VX_EXN_PROTOCOL_MSG_V02 = 1, /**<  Encoding is EXN protocol message \n  */
  eQMI_LOC_NI_VX_ASCII_V02 = 2, /**<  Encoding is ASCII \n */
  eQMI_LOC_NI_VX_IA5_V02 = 3, /**<  Encoding is IA5 \n  */
  eQMI_LOC_NI_VX_UNICODE_V02 = 4, /**<  Encoding is Unicode \n */
  eQMI_LOC_NI_VX_SHIFT_JIS_V02 = 5, /**<  Encoding is Shift JIS \n */
  eQMI_LOC_NI_VX_KOREAN_V02 = 6, /**<  Encoding is Korean \n */
  eQMI_LOC_NI_VX_LATIN_HEBREW_V02 = 7, /**<  Encoding is Latin Hebrew \n */
  eQMI_LOC_NI_VX_LATIN_V02 = 8, /**<  Encoding is Latin \n  */
  eQMI_LOC_NI_VX_GSM_V02 = 9, /**<  Encoding is GSM  */
  QMILOCNIVXREQUESTORIDENCODINGSCHEMEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiVxRequestorIdEncodingSchemeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t posQosIncl;
  /**<   Indicates whether quality of service is included:\n
         - 0x01 (TRUE) --  QoS is included \n
         - 0x00 (FALSE) -- QoS is not included */

  uint8_t posQos;
  /**<   Position QoS timeout. \n
         - Units -- Seconds \n
         - Range-- 0 to 255 */

  uint32_t numFixes;
  /**<   Number of fixes allowed. */

  uint32_t timeBetweenFixes;
  /**<   Time between fixes. \n
         - Units -- Seconds */

  qmiLocNiVxPosModeEnumT_v02 posMode;
  /**<   Position mode.
 Values: \n
      - eQMI_LOC_NI_VX_MS_ASSISTED_ONLY (1) --  MS-assisted only allowed \n
      - eQMI_LOC_NI_VX_MS_BASED_ONLY (2) --  MS-based only allowed \n
      - eQMI_LOC_NI_VX_MS_ASSISTED_PREFERRED_MS_BASED_ALLOWED (3) --  MS-assisted preferred, but MS-based allowed \n
      - eQMI_LOC_NI_VX_MS_BASED_PREFERRED_MS_ASSISTED_ALLOWED (4) --  MS-based preferred, but MS-assisted allowed
 */

  qmiLocNiVxRequestorIdEncodingSchemeEnumT_v02 encodingScheme;
  /**<   VX encoding scheme.
 Values:\n
      - eQMI_LOC_NI_VX_OCTET (0) --  Encoding is Octet \n
      - eQMI_LOC_NI_VX_EXN_PROTOCOL_MSG (1) --  Encoding is EXN protocol message \n
      - eQMI_LOC_NI_VX_ASCII (2) --  Encoding is ASCII \n
      - eQMI_LOC_NI_VX_IA5 (3) --  Encoding is IA5 \n
      - eQMI_LOC_NI_VX_UNICODE (4) --  Encoding is Unicode \n
      - eQMI_LOC_NI_VX_SHIFT_JIS (5) --  Encoding is Shift JIS \n
      - eQMI_LOC_NI_VX_KOREAN (6) --  Encoding is Korean \n
      - eQMI_LOC_NI_VX_LATIN_HEBREW (7) --  Encoding is Latin Hebrew \n
      - eQMI_LOC_NI_VX_LATIN (8) --  Encoding is Latin \n
      - eQMI_LOC_NI_VX_GSM (9) --  Encoding is GSM
 */

  uint32_t requestorId_len;  /**< Must be set to # of elements in requestorId */
  uint8_t requestorId[QMI_LOC_NI_MAX_REQUESTOR_ID_LENGTH_V02];
  /**<   Requestor ID. \n
       - Type:  Array of bytes \n
       - Maximum array length: 200
  */

  uint16_t userRespTimerInSeconds;
  /**<   Time to wait for the user to respond. \n
         - Units -- Seconds */
}qmiLocNiVxNotifyVerifyStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNISUPLPOSMETHODENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETASSISTED_V02 = 1, /**<  Set assisted \n  */
  eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETBASED_V02 = 2, /**<  Set based \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETASSISTED_PREF_V02 = 3, /**<  Set assisted preferred \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETBASED_PREF_V02 = 4, /**<  Set based preferred \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_AUTONOMOUS_GPS_V02 = 5, /**<  Standalone GPS \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_AFLT_V02 = 6, /**<  Advanced forward link trilateration \n  */
  eQMI_LOC_NI_SUPL_POSMETHOD_ECID_V02 = 7, /**<  Exclusive chip ID \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_EOTD_V02 = 8, /**<  Enhanced observed time difference \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_OTDOA_V02 = 9, /**<  Observed time delay of arrival \n */
  eQMI_LOC_NI_SUPL_POSMETHOD_NO_POSITION_V02 = 10, /**<  No position  */
  QMILOCNISUPLPOSMETHODENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiSuplPosMethodEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNIDATACODINGSCHEMEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_SS_GERMAN_V02 = 12, /**<  Language is German \n  */
  eQMI_LOC_NI_SS_ENGLISH_V02 = 13, /**<  Language is English \n */
  eQMI_LOC_NI_SS_ITALIAN_V02 = 14, /**<  Language is Italian \n */
  eQMI_LOC_NI_SS_FRENCH_V02 = 15, /**<  Language is French \n */
  eQMI_LOC_NI_SS_SPANISH_V02 = 16, /**<  Language is Spanish \n */
  eQMI_LOC_NI_SS_DUTCH_V02 = 17, /**<  Language is Dutch \n */
  eQMI_LOC_NI_SS_SWEDISH_V02 = 18, /**<  Language is Swedish \n */
  eQMI_LOC_NI_SS_DANISH_V02 = 19, /**<  Language is Danish \n */
  eQMI_LOC_NI_SS_PORTUGUESE_V02 = 20, /**<  Language is Portuguese \n */
  eQMI_LOC_NI_SS_FINNISH_V02 = 21, /**<  Language is Finnish \n */
  eQMI_LOC_NI_SS_NORWEGIAN_V02 = 22, /**<  Language is Norwegian \n */
  eQMI_LOC_NI_SS_GREEK_V02 = 23, /**<  Language is Greek \n */
  eQMI_LOC_NI_SS_TURKISH_V02 = 24, /**<  Language is Turkish \n */
  eQMI_LOC_NI_SS_HUNGARIAN_V02 = 25, /**<  Language is Hungarian \n */
  eQMI_LOC_NI_SS_POLISH_V02 = 26, /**<  Language is Polish \n */
  eQMI_LOC_NI_SS_LANGUAGE_UNSPEC_V02 = 27, /**<  Language is unspecified \n */
  eQMI_LOC_NI_SUPL_UTF8_V02 = 28, /**<  Encoding is UTF 8 \n */
  eQMI_LOC_NI_SUPL_UCS2_V02 = 29, /**<  Encoding is UCS 2 \n */
  eQMI_LOC_NI_SUPL_GSM_DEFAULT_V02 = 30, /**<  Encoding is GSM default  */
  QMILOCNIDATACODINGSCHEMEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiDataCodingSchemeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNISUPLFORMATENUMTYPE_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_SUPL_FORMAT_LOGICAL_NAME_V02 = 0, /**<  SUPL logical name format \n */
  eQMI_LOC_NI_SUPL_FORMAT_EMAIL_ADDRESS_V02 = 1, /**<  SUPL email address format \n */
  eQMI_LOC_NI_SUPL_FORMAT_MSISDN_V02 = 2, /**<  SUPL MS-ISDN format \n */
  eQMI_LOC_NI_SUPL_FORMAT_URL_V02 = 3, /**<  SUPL URL format \n */
  eQMI_LOC_NI_SUPL_FORMAT_SIP_URL_V02 = 4, /**<  SUPL SIP URL format \n  */
  eQMI_LOC_NI_SUPL_FORMAT_MIN_V02 = 5, /**<  SUPL MIN format \n */
  eQMI_LOC_NI_SUPL_FORMAT_MDN_V02 = 6, /**<  SUPL MDN format \n  */
  eQMI_LOC_NI_SUPL_FORMAT_IMSPUBLIC_IDENTITY_V02 = 7, /**<  SUPL IMS public identity \n  */
  eQMI_LOC_NI_SUPL_FORMAT_OSS_UNKNOWN_V02 = 2147483647, /**<  SUPL unknown format  */
  QMILOCNISUPLFORMATENUMTYPE_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiSuplFormatEnumType_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiSuplFormatEnumType_v02 formatType;
  /**<   Format of the formatted string.
 Values: \n
      - eQMI_LOC_NI_SUPL_FORMAT_LOGICAL_NAME (0) --  SUPL logical name format \n
      - eQMI_LOC_NI_SUPL_FORMAT_EMAIL_ADDRESS (1) --  SUPL email address format \n
      - eQMI_LOC_NI_SUPL_FORMAT_MSISDN (2) --  SUPL MS-ISDN format \n
      - eQMI_LOC_NI_SUPL_FORMAT_URL (3) --  SUPL URL format \n
      - eQMI_LOC_NI_SUPL_FORMAT_SIP_URL (4) --  SUPL SIP URL format \n
      - eQMI_LOC_NI_SUPL_FORMAT_MIN (5) --  SUPL MIN format \n
      - eQMI_LOC_NI_SUPL_FORMAT_MDN (6) --  SUPL MDN format \n
      - eQMI_LOC_NI_SUPL_FORMAT_IMSPUBLIC_IDENTITY (7) --  SUPL IMS public identity \n
      - eQMI_LOC_NI_SUPL_FORMAT_OSS_UNKNOWN (2147483647) --  SUPL unknown format
 */

  uint32_t formattedString_len;  /**< Must be set to # of elements in formattedString */
  uint8_t formattedString[QMI_LOC_NI_MAX_CLIENT_NAME_LENGTH_V02];
  /**<   Formatted string. \n
        - Type -- Byte array \n
        - Maximum string length -- 64
   */
}qmiLocNiSuplFormattedStringStructT_v02;  /* Type */
/**
    @}
  */

typedef uint8_t qmiLocSuplQopValidMaskT_v02;
#define QMI_LOC_NI_SUPL_MASK_QOP_HORZ_ACC_VALID_V02 ((qmiLocSuplQopValidMaskT_v02)0x01) /**<  Horizontal accuracy is valid in the Quality of Position (QoP) \n  */
#define QMI_LOC_NI_SUPL_MASK_QOP_VER_ACC_VALID_V02 ((qmiLocSuplQopValidMaskT_v02)0x02) /**<  Vertical accuracy is valid in the QoP \n  */
#define QMI_LOC_NI_SUPL_MASK_QOP_MAXAGE_VALID_V02 ((qmiLocSuplQopValidMaskT_v02)0x04) /**<  Vertical accuracy is valid in the QoP \n  */
#define QMI_LOC_NI_SUPL_MASK_QOP_DELAY_VALID_V02 ((qmiLocSuplQopValidMaskT_v02)0x08) /**<  Vertical accuracy is valid in the QoP  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSuplQopValidMaskT_v02 validMask;
  /**<   Bit field indicating which fields are valid in this value.
        Valid bitmasks: \n
          - 0x01 -- QOP_HORZ_ACC_VALID \n
          - 0x02 -- QOP_VER_ACC_VALID \n
          - 0x04 -- QOP_MAXAGE_VALID \n
          - 0x08 -- QOP_DELAY_VALID*/

  uint8_t horizontalAccuracy;
  /**<   Horizontal accuracy. \n
        - Units -- Meters */

  uint8_t verticalAccuracy;
  /**<   Vertical accuracy. \n
        - Units -- Meters */

  uint16_t maxLocAge;
  /**<   Maximum age of the location if the engine sends a previously
        computed position. \n
        - Units -- Seconds */

  uint8_t delay;
  /**<   Delay the server is willing to tolerate for the fix. \n
        - Units -- Seconds */
}qmiLocNiSuplQopStructT_v02;  /* Type */
/**
    @}
  */

typedef uint8_t qmiLocServerAddrTypeMaskT_v02;
#define QMI_LOC_SERVER_ADDR_TYPE_IPV4_MASK_V02 ((qmiLocServerAddrTypeMaskT_v02)0x01) /**<  IPv4  \n  */
#define QMI_LOC_SERVER_ADDR_TYPE_IPV6_MASK_V02 ((qmiLocServerAddrTypeMaskT_v02)0x02) /**<  IPv6  \n  */
#define QMI_LOC_SERVER_ADDR_TYPE_URL_MASK_V02 ((qmiLocServerAddrTypeMaskT_v02)0x04) /**<  URL  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t addr;
  /**<   IPv4 address. */

  uint16_t port;
  /**<   IPv4 port. */
}qmiLocIpV4AddrStructType_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t addr[QMI_LOC_IPV6_ADDR_LENGTH_V02];
  /**<   IPv6 address. \n
       - Type -- Array of unsigned integers \n
       - Maximum length of the array -- 8 */

  uint32_t port;
  /**<   IPv6 port. */
}qmiLocIpV6AddrStructType_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocServerAddrTypeMaskT_v02 suplServerAddrTypeMask;
  /**<   Mask specifying the valid fields in this value.
 Valid bitmasks: \n
      - QMI_LOC_SERVER_ADDR_TYPE_IPV4_MASK (0x01) --  IPv4  \n
      - QMI_LOC_SERVER_ADDR_TYPE_IPV6_MASK (0x02) --  IPv6  \n
      - QMI_LOC_SERVER_ADDR_TYPE_URL_MASK (0x04) --  URL
 */

  qmiLocIpV4AddrStructType_v02 ipv4Addr;
  /**<   IPv4 address and port. */

  qmiLocIpV6AddrStructType_v02 ipv6Addr;
  /**<   IPv6 address and port. */

  char urlAddr[QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 + 1];
  /**<   URL.\n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 256
    */
}qmiLocNiSuplServerInfoStructT_v02;  /* Type */
/**
    @}
  */

typedef uint32_t qmiLocNiSuplNotifyVerifyValidMaskT_v02;
#define QMI_LOC_SUPL_SERVER_INFO_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000001) /**<  Indicates presence of the server information
       in an NI SUPL Notify/Verify request event. This mask is set in
       the valid_flags field of a Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_SESSION_ID_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000002) /**<  Indicates presence of the SUPL session ID
       in an NI SUPL Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_HASH_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000004) /**<  Indicates presence of the SUPL hash
       in an NI Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_POS_METHOD_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000008) /**<  Indicates presence of the position method
       in an NI SUPL Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_DATA_CODING_SCHEME_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000010) /**<  Indicates presence of the data coding scheme
       in an NI SUPL Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_REQUESTOR_ID_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000020) /**<  Indicates presence of the requestor ID
       in an NI Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_CLIENT_NAME_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000040) /**<  Indicates presence of the requestor ID
       in an NI Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_QOP_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000080) /**<  Indicates presence of the quality of position
       in an NI Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_SUPL_USER_RESP_TIMER_MASK_V02 ((qmiLocNiSuplNotifyVerifyValidMaskT_v02)0x00000100) /**<  Mask indicating that the user response timer
       is present in an NI Notify/Verify request event.
       This mask is set in the valid_flags field of a
       Notify/Verify structure.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiSuplNotifyVerifyValidMaskT_v02 valid_flags;
  /**<   Indicates which of the following fields are present in this value.
        Valid bitmasks: \n
        - 0x00000001 -- SUPL_SERVER_INFO \n
        - 0x00000002 -- SUPL_SESSION_ID \n
        - 0x00000004 -- SUPL_HASH \n
        - 0x00000008 -- SUPL_POS_METHOD \n
        - 0x00000010 -- SUPL_DATA_ CODING_SCHEME \n
        - 0x00000020 -- SUPL_REQUESTOR_ ID \n
        - 0x00000040 -- SUPL_CLIENT_ NAME \n
        - 0x00000080 -- SUPL_QOP \n
        - 0x00000100 -- SUPL_USER_RESP_ TIMER
  */

  qmiLocNiSuplServerInfoStructT_v02 suplServerInfo;
  /**<   SUPL server information. */

  uint8_t suplSessionId[QMI_LOC_NI_SUPL_SLP_SESSION_ID_BYTE_LENGTH_V02];
  /**<   SUPL session ID. \n
       - Type -- Array of unsigned integers \n
       - Maximum length of the array -- 4 */

  uint8_t suplHash[QMI_LOC_NI_SUPL_HASH_LENGTH_V02];
  /**<   Hash for SUPL_INIT; validates that the message is not
       corrupt. \n
       - Type -- Array of unsigned integers \n
       - Length of the array -- 8 */

  qmiLocNiSuplPosMethodEnumT_v02 posMethod;
  /**<   GPS mode to use for the fix.
 Values: \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETASSISTED (1) --  Set assisted \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETBASED (2) --  Set based \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETASSISTED_PREF (3) --  Set assisted preferred \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AGPS_SETBASED_PREF (4) --  Set based preferred \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AUTONOMOUS_GPS (5) --  Standalone GPS \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_AFLT (6) --  Advanced forward link trilateration \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_ECID (7) --  Exclusive chip ID \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_EOTD (8) --  Enhanced observed time difference \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_OTDOA (9) --  Observed time delay of arrival \n
      - eQMI_LOC_NI_SUPL_POSMETHOD_NO_POSITION (10) --  No position
 */

  qmiLocNiDataCodingSchemeEnumT_v02 dataCodingScheme;
  /**<   Data coding scheme applies to both the requestor ID and the client
 name.
 Values: \n
      - eQMI_LOC_NI_SS_GERMAN (12) --  Language is German \n
      - eQMI_LOC_NI_SS_ENGLISH (13) --  Language is English \n
      - eQMI_LOC_NI_SS_ITALIAN (14) --  Language is Italian \n
      - eQMI_LOC_NI_SS_FRENCH (15) --  Language is French \n
      - eQMI_LOC_NI_SS_SPANISH (16) --  Language is Spanish \n
      - eQMI_LOC_NI_SS_DUTCH (17) --  Language is Dutch \n
      - eQMI_LOC_NI_SS_SWEDISH (18) --  Language is Swedish \n
      - eQMI_LOC_NI_SS_DANISH (19) --  Language is Danish \n
      - eQMI_LOC_NI_SS_PORTUGUESE (20) --  Language is Portuguese \n
      - eQMI_LOC_NI_SS_FINNISH (21) --  Language is Finnish \n
      - eQMI_LOC_NI_SS_NORWEGIAN (22) --  Language is Norwegian \n
      - eQMI_LOC_NI_SS_GREEK (23) --  Language is Greek \n
      - eQMI_LOC_NI_SS_TURKISH (24) --  Language is Turkish \n
      - eQMI_LOC_NI_SS_HUNGARIAN (25) --  Language is Hungarian \n
      - eQMI_LOC_NI_SS_POLISH (26) --  Language is Polish \n
      - eQMI_LOC_NI_SS_LANGUAGE_UNSPEC (27) --  Language is unspecified \n
      - eQMI_LOC_NI_SUPL_UTF8 (28) --  Encoding is UTF 8 \n
      - eQMI_LOC_NI_SUPL_UCS2 (29) --  Encoding is UCS 2 \n
      - eQMI_LOC_NI_SUPL_GSM_DEFAULT (30) --  Encoding is GSM default
 */

  qmiLocNiSuplFormattedStringStructT_v02 requestorId;
  /**<   Requestor ID; the encoding scheme for requestor_id is specified in
       the dataCodingScheme field. */

  qmiLocNiSuplFormattedStringStructT_v02 clientName;
  /**<   Client name; the encoding scheme for client_name is specified in
       the dataCodingScheme field. */

  qmiLocNiSuplQopStructT_v02 suplQop;
  /**<   SUPL QoP. */

  uint16_t userResponseTimer;
  /**<   Time to wait for the user to respond. \n
       - Units -- Seconds*/
}qmiLocNiSuplNotifyVerifyStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNILOCATIONTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION_V02 = 1, /**<  Current location \n */
  eQMI_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION_V02 = 2, /**<  Last known location; might be the current location \n  */
  eQMI_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION_V02 = 3, /**<  Initial location  */
  QMILOCNILOCATIONTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiLocationTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiDataCodingSchemeEnumT_v02 dataCodingScheme;
  /**<   Identifies the coding scheme of the coded string.
 Values: \n
      - eQMI_LOC_NI_SS_GERMAN (12) --  Language is German \n
      - eQMI_LOC_NI_SS_ENGLISH (13) --  Language is English \n
      - eQMI_LOC_NI_SS_ITALIAN (14) --  Language is Italian \n
      - eQMI_LOC_NI_SS_FRENCH (15) --  Language is French \n
      - eQMI_LOC_NI_SS_SPANISH (16) --  Language is Spanish \n
      - eQMI_LOC_NI_SS_DUTCH (17) --  Language is Dutch \n
      - eQMI_LOC_NI_SS_SWEDISH (18) --  Language is Swedish \n
      - eQMI_LOC_NI_SS_DANISH (19) --  Language is Danish \n
      - eQMI_LOC_NI_SS_PORTUGUESE (20) --  Language is Portuguese \n
      - eQMI_LOC_NI_SS_FINNISH (21) --  Language is Finnish \n
      - eQMI_LOC_NI_SS_NORWEGIAN (22) --  Language is Norwegian \n
      - eQMI_LOC_NI_SS_GREEK (23) --  Language is Greek \n
      - eQMI_LOC_NI_SS_TURKISH (24) --  Language is Turkish \n
      - eQMI_LOC_NI_SS_HUNGARIAN (25) --  Language is Hungarian \n
      - eQMI_LOC_NI_SS_POLISH (26) --  Language is Polish \n
      - eQMI_LOC_NI_SS_LANGUAGE_UNSPEC (27) --  Language is unspecified \n
      - eQMI_LOC_NI_SUPL_UTF8 (28) --  Encoding is UTF 8 \n
      - eQMI_LOC_NI_SUPL_UCS2 (29) --  Encoding is UCS 2 \n
      - eQMI_LOC_NI_SUPL_GSM_DEFAULT (30) --  Encoding is GSM default
 */

  uint32_t codedString_len;  /**< Must be set to # of elements in codedString */
  uint8_t codedString[QMI_LOC_NI_CODEWORD_MAX_LENGTH_V02];
  /**<   Coded string. \n
       - Type: Array of bytes \n
       - Maximum string length: 20 */
}qmiLocNiUmtsCpCodedStringStructT_v02;  /* Type */
/**
    @}
  */

typedef uint16_t qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02;
#define QMI_LOC_UMTS_CP_INVOKE_ID_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0001) /**<  Indicates presence of the invoke ID
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n */
#define QMI_LOC_UMTS_CP_DATA_CODING_SCHEME_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0002) /**<  Indicates presence of the data coding scheme
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_NOTIFICATION_TEXT_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0004) /**<  Indicates presence of the notification text
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_CLIENT_ADDRESS_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0008) /**<  Indicates presence of the client address
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_LOCATION_TYPE_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0010) /**<  Indicates presence of the location type
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_REQUESTOR_ID_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0020) /**<  Indicates presence of the requestor ID
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_CODEWORD_STRING_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0040) /**<  Indicates presence of the code word string
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure.  */
#define QMI_LOC_UMTS_CP_SERVICE_TYPE_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0080) /**<  Indicates presence of the service type
        in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure. \n  */
#define QMI_LOC_UMTS_CP_USER_RESP_TIMER_MASK_V02 ((qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02)0x0100) /**<  Indicates presence of the user response timer
       in an NI Notify/Verify request event.
       This mask is set in the valid flags field of a
       Notify/Verify structure.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiUmtsCpNotifyVerifyValidMaskT_v02 valid_flags;
  /**<   Valid bitmasks: \n
       - 0x0001 -- INVOKE_ID_MASK \n
       - 0x0002 -- DATA_CODING_ SCHEME_MASK \n
       - 0x0004 -- NOTIFICATION_TEXT_ MASK \n
       - 0x0008 -- CLIENT_ADDRESS_ MASK \n
       - 0x0010 -- LOCATION_TYPE_ MASK \n
       - 0x0020 -- REQUESTOR_ID_MASK \n
       - 0x0040 -- CODEWORD_STRING_ MASK \n
       - 0x0080 -- SERVICE_TYPE_MASK \n
       - 0x0100 -- USER_RESP_TIMER_ MASK
  */

  uint8_t invokeId;
  /**<   Supplementary services invoke ID. */

  qmiLocNiDataCodingSchemeEnumT_v02 dataCodingScheme;
  /**<   Type of data encoding scheme for the text.
 Applies to both the notification text and the client address.
 Values: \n
      - eQMI_LOC_NI_SS_GERMAN (12) --  Language is German \n
      - eQMI_LOC_NI_SS_ENGLISH (13) --  Language is English \n
      - eQMI_LOC_NI_SS_ITALIAN (14) --  Language is Italian \n
      - eQMI_LOC_NI_SS_FRENCH (15) --  Language is French \n
      - eQMI_LOC_NI_SS_SPANISH (16) --  Language is Spanish \n
      - eQMI_LOC_NI_SS_DUTCH (17) --  Language is Dutch \n
      - eQMI_LOC_NI_SS_SWEDISH (18) --  Language is Swedish \n
      - eQMI_LOC_NI_SS_DANISH (19) --  Language is Danish \n
      - eQMI_LOC_NI_SS_PORTUGUESE (20) --  Language is Portuguese \n
      - eQMI_LOC_NI_SS_FINNISH (21) --  Language is Finnish \n
      - eQMI_LOC_NI_SS_NORWEGIAN (22) --  Language is Norwegian \n
      - eQMI_LOC_NI_SS_GREEK (23) --  Language is Greek \n
      - eQMI_LOC_NI_SS_TURKISH (24) --  Language is Turkish \n
      - eQMI_LOC_NI_SS_HUNGARIAN (25) --  Language is Hungarian \n
      - eQMI_LOC_NI_SS_POLISH (26) --  Language is Polish \n
      - eQMI_LOC_NI_SS_LANGUAGE_UNSPEC (27) --  Language is unspecified \n
      - eQMI_LOC_NI_SUPL_UTF8 (28) --  Encoding is UTF 8 \n
      - eQMI_LOC_NI_SUPL_UCS2 (29) --  Encoding is UCS 2 \n
      - eQMI_LOC_NI_SUPL_GSM_DEFAULT (30) --  Encoding is GSM default
 */

  uint32_t notificationText_len;  /**< Must be set to # of elements in notificationText */
  uint8_t notificationText[QMI_LOC_NI_MAX_CLIENT_NAME_LENGTH_V02];
  /**<   Notification text; the encoding method is specified in
       dataCodingScheme. \n
       - Type -- Array of bytes \n
       - Maximum array length -- 64 */

  uint32_t clientAddress_len;  /**< Must be set to # of elements in clientAddress */
  uint8_t clientAddress[QMI_LOC_NI_MAX_EXT_CLIENT_ADDRESS_V02];
  /**<   Client address; the encoding method is specified in
       dataCodingScheme. \n
       - Maximum array length -- 20 */

  qmiLocNiLocationTypeEnumT_v02 locationType;
  /**<   Location type.
 Values: \n
      - eQMI_LOC_NI_LOCATIONTYPE_CURRENT_LOCATION (1) --  Current location \n
      - eQMI_LOC_NI_LOCATIONTYPE_CURRENT_OR_LAST_KNOWN_LOCATION (2) --  Last known location; might be the current location \n
      - eQMI_LOC_NI_LOCATIONTYPE_INITIAL_LOCATION (3) --  Initial location
 */

  qmiLocNiUmtsCpCodedStringStructT_v02 requestorId;
  /**<   Requestor ID; the encoding method is specified in the
       qmiLocNiUmtsCpCodedStringStructT.dataCodingScheme field. */

  qmiLocNiUmtsCpCodedStringStructT_v02 codewordString;
  /**<   Codeword string; the encoding method is specified in the
       qmiLocNiUmtsCpCodedStringStructT.dataCodingScheme field. */

  uint8_t lcsServiceTypeId;
  /**<   Service type ID. */

  uint16_t userResponseTimer;
  /**<   Time to wait for the user to respond. \n
       - Units -- Seconds */
}qmiLocNiUmtsCpNotifyVerifyStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNISERVICEINTERACTIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO_V02 = 1, /**<  Service interaction between ongoing NI and incoming MO sessions.  */
  QMILOCNISERVICEINTERACTIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiServiceInteractionEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiVxNotifyVerifyStructT_v02 niVxReq;
  /**<   Ongoing NI session request; this information is not filled. */

  qmiLocNiServiceInteractionEnumT_v02 serviceInteractionType;
  /**<   Service interaction type specified in qmiLocNiServiceInteractionEnumT.
 Values: \n
      - eQMI_LOC_NI_SERVICE_INTERACTION_ONGOING_NI_INCOMING_MO (1) --  Service interaction between ongoing NI and incoming MO sessions.
 */
}qmiLocNiVxServiceInteractionStructT_v02;  /* Type */
/**
    @}
  */

typedef uint16_t qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02;
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_WLAN_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0001) /**<  WLAN measurements are allowed as part of location ID
       and multiple location IDs in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_GSM_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0002) /**<  GSM measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_WCDMA_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0004) /**<  WCDMA measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_CDMA_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0008) /**<  CDMA measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_HRDP_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0010) /**<  HRDP measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_UMB_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0020) /**<  UMB measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_LTE_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0040) /**<  LTE measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_WIMAX_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0080) /**<  WIMAX measurements are allowed as part of location ID
       and multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_HISTORIC_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0100) /**<  Historical information is allowed as part of
       multiple location ID in the SUPL_POS_INIT message.  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_SUPPORTED_NETWORK_NONSVRV_V02 ((qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02)0x0200) /**<  Information about nonserving cells is allowed
       as part of multiple location ID in the SUPL_POS_INIT message.  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNISUPLVER2EXTTRIGGERTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_SINGLE_SHOT_V02 = -1, /**<  SUPL INIT message indicates a request for a single shot
       triggered session \n */
  eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_PERIODIC_V02 = 0, /**<  SUPL INIT message indicates a request for a periodic
       triggered session \n */
  eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_AREA_EVENT_V02 = 1, /**<  SUPL INIT message indicates a request for an area event
       triggered session  */
  QMILOCNISUPLVER2EXTTRIGGERTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiSuplVer2ExtTriggerTypeEnumT_v02;
/**
    @}
  */

typedef uint16_t qmiLocNiSuplVer2ExtGnssTypeMaskT_v02;
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GPS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0001) /**<  GPS \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GLONASS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0002) /**<  GLONASS \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GALILEO_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0004) /**<  Galileo \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_SBAS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0008) /**<  SBAS \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_QZSS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0010) /**<  QZSS \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_MODERN_GPS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0020) /**<  Modern GPS \n  */
#define QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_BDS_V02 ((qmiLocNiSuplVer2ExtGnssTypeMaskT_v02)0x0040) /**<  BDS   */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocNiSuplVer2ExtSupportedNetworksMaskT_v02 supportedNetworksMask;
  /**<   Specifies the type of network measurements allowed to be sent as
       part of the location ID or multiple location IDs parameter in the
       SUPL_POS_INIT message (refer to 3GPP \hyperref[TS 03.32]{TS 03.32}). \n
       Valid bitmasks: \n
       - 0x0001 -- SUPPORTED_NETWORK_ WLAN \n
       - 0x0002 -- SUPPORTED_NETWORK_ GSM \n
       - 0x0004 -- SUPPORTED_NETWORK_ WCDMA \n
       - 0x0008 -- SUPPORTED_NETWORK_ CDMA \n
       - 0x0010 -- SUPPORTED_NETWORK_ HRDP \n
       - 0x0020 -- SUPPORTED_NETWORK_ UMB \n
       - 0x0040 -- SUPPORTED_NETWORK_ LTE \n
       - 0x0080 -- SUPPORTED_NETWORK_ WIMAX \n
       - 0x0100 -- SUPPORTED_NETWORK_ HISTORIC \n
       - 0x0200 -- SUPPORTED_NETWORK_ NONSVRV
   */

  qmiLocNiSuplVer2ExtTriggerTypeEnumT_v02 triggerType;
  /**<   Specifies the type of session trigger requested in the
 SUPL_POS_INIT message (refer to 3GPP \hyperref[TS 03.32]{TS 03.32}).
 Values: \n
      - eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_SINGLE_SHOT (-1) --  SUPL INIT message indicates a request for a single shot
       triggered session \n
      - eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_PERIODIC (0) --  SUPL INIT message indicates a request for a periodic
       triggered session \n
      - eQMI_LOC_SUPL_VER_2_EXT_TRIGGER_TYPE_AREA_EVENT (1) --  SUPL INIT message indicates a request for an area event
       triggered session
 */

  qmiLocNiSuplVer2ExtGnssTypeMaskT_v02 gnssType;
  /**<   Specifies which GNSS technologies are allowed as positioning
 technologies.
 Valid bitmasks: \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GPS (0x0001) --  GPS \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GLONASS (0x0002) --  GLONASS \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_GALILEO (0x0004) --  Galileo \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_SBAS (0x0008) --  SBAS \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_QZSS (0x0010) --  QZSS \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_MODERN_GPS (0x0020) --  Modern GPS \n
      - QMI_LOC_SUPL_VER_2_EXT_MASK_GNSS_BDS (0x0040) --  BDS
 */
}qmiLocNiSuplVer2ExtStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  char eslpUrl[QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 + 1];
  /**<   ESLP URL. \n
       - Maximum length -- 255 bytes */
}qmiLocEmergencyNotificationStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Indicates an NI notify/verify request to the control point. */
typedef struct {

  /* Mandatory */
  /*  Notification Type */
  qmiLocNiNotifyVerifyEnumT_v02 notificationType;
  /**<   Type of notification/verification performed.
 Values: \n
      - eQMI_LOC_NI_USER_NO_NOTIFY_NO_VERIFY (1) --  No notification and no verification required \n
      - eQMI_LOC_NI_USER_NOTIFY_ONLY (2) --  Notify only; no verification required \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP (3) --  Notify and verify, but no response required. \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP (4) --  Notify and verify, and require a response \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_PRIVACY_OVERRIDE (5) --  Notify and verify; privacy override
 */

  /* Optional */
  /*  Network Initiated Vx Request */
  uint8_t NiVxInd_valid;  /**< Must be set to true if NiVxInd is being passed */
  qmiLocNiVxNotifyVerifyStructT_v02 NiVxInd;
  /**<   \vspace{0.06in} \n Optional NI Vx request payload. */

  /* Optional */
  /*  Network Initiated SUPL Request */
  uint8_t NiSuplInd_valid;  /**< Must be set to true if NiSuplInd is being passed */
  qmiLocNiSuplNotifyVerifyStructT_v02 NiSuplInd;
  /**<   \vspace{0.06in} \n Optional NI SUPL request payload. */

  /* Optional */
  /*  Network Initiated UMTS Control Plane Request */
  uint8_t NiUmtsCpInd_valid;  /**< Must be set to true if NiUmtsCpInd is being passed */
  qmiLocNiUmtsCpNotifyVerifyStructT_v02 NiUmtsCpInd;
  /**<   \vspace{0.06in} \n Optional NI UMTS-CP request payload. */

  /* Optional */
  /*  Network Initiated Service Interaction Request */
  uint8_t NiVxServiceInteractionInd_valid;  /**< Must be set to true if NiVxServiceInteractionInd is being passed */
  qmiLocNiVxServiceInteractionStructT_v02 NiVxServiceInteractionInd;
  /**<   \vspace{0.06in} \n Optional NI service interaction payload. */

  /* Optional */
  /*  Network Initiated SUPL Version 2 Extension */
  uint8_t NiSuplVer2ExtInd_valid;  /**< Must be set to true if NiSuplVer2ExtInd is being passed */
  qmiLocNiSuplVer2ExtStructT_v02 NiSuplVer2ExtInd;
  /**<   \vspace{0.06in} \n Optional NI SUPL Version 2 Extension payload. When present,
          this payload is used in conjunction with the SUPL
          indication payload. */

  /* Optional */
  /*  SUPL Emergency Notification */
  uint8_t suplEmergencyNotification_valid;  /**< Must be set to true if suplEmergencyNotification is being passed */
  qmiLocEmergencyNotificationStructT_v02 suplEmergencyNotification;
  /**<   \vspace{0.06in} \n This specifies that the corresponding NI notification is an
        emergency notification. Emergency notification
        can be provided even without an Emergency SUPL Location Platform (ESLP)
        address. */

  /* Optional */
  /*  In Emergency Session */
  uint8_t isInEmergencySession_valid;  /**< Must be set to true if isInEmergencySession is being passed */
  uint8_t isInEmergencySession;
  /**<   Reported as TRUE when the device is
         in an emergency session or emergencyCallbackWindow. */
}qmiLocEventNiNotifyVerifyReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  char serverUrl[QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 + 1];
  /**<   Assistance server URL.\n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 256
    */
}qmiLocAssistanceServerUrlStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t delayThreshold;
  /**<   Skip the time server if a one-way delay to the server
       exceeds this threshold. \n
       - Units -- Milliseconds */

  uint32_t timeServerList_len;  /**< Must be set to # of elements in timeServerList */
  qmiLocAssistanceServerUrlStructT_v02 timeServerList[QMI_LOC_MAX_NTP_SERVERS_V02];
  /**<   List of time server URLs recommended by the service for time
       information. The list is ordered; the client uses the first
       server specified in the list as the primary URL to fetch NTP time,
       the second server as secondary, and so on. \n
       - Maximum server list items -- 3 */
}qmiLocTimeServerListStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to inject time information. */
typedef struct {

  /* Optional */
  /*  Time Server Info */
  uint8_t timeServerInfo_valid;  /**< Must be set to true if timeServerInfo is being passed */
  qmiLocTimeServerListStructT_v02 timeServerInfo;
  /**<   \vspace{0.06in} \n Contains information about the time servers recommended by the
       location service for NTP time. */
}qmiLocEventInjectTimeReqIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocServerParamUpdateMaskT_v02;
#define QMI_LOC_PREDICTED_ORBITS_INJECT_REQUEST_V02 ((qmiLocServerParamUpdateMaskT_v02)0x00000001ull) /**<  Request for injection of predicted orbits \n  */
#define QMI_LOC_PREDICTED_ORBITS_SERVER_UPDATE_V02 ((qmiLocServerParamUpdateMaskT_v02)0x00000002ull) /**<  Update server list \n */
#define QMI_LOC_PREDICTED_ORBITS_REFRESH_UPDATE_RATE_V02 ((qmiLocServerParamUpdateMaskT_v02)0x00000004ull) /**<  Refresh periodicity of injection  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCINJECTEDORBITUPDATETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_INJECTED_ORBIT_RATE_UPDATE_V02 = 1, /**<  Injected orbit rate update \n */
  eQMI_LOC_INTEGRITY_RATE_UPDATE_V02 = 2, /**<  Integrity rate update  */
  QMILOCINJECTEDORBITUPDATETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocInjectedOrbitUpdateTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t maxFileSizeInBytes;
  /**<   Maximum allowable predicted orbits file size (in bytes). */

  uint32_t maxPartSize;
  /**<   Maximum allowable predicted orbits file chunk size (in bytes). */
}qmiLocPredictedOrbitsAllowedSizesStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t serverList_len;  /**< Must be set to # of elements in serverList */
  qmiLocAssistanceServerUrlStructT_v02 serverList[QMI_LOC_MAX_PREDICTED_ORBITS_SERVERS_V02];
  /**<   List of predicted orbits URLs. The list is ordered, so the client
       must use the first server specified in the list as the primary URL
       from which to download predicted orbits data, the second one as
       secondary, and so on. \n
       A maximum number of three servers can be specified. */
}qmiLocPredictedOrbitsServerListStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to inject predicted orbits data. */
typedef struct {

  /* Mandatory */
  /*  Allowed Sizes */
  qmiLocPredictedOrbitsAllowedSizesStructT_v02 allowedSizes;
  /**<   \vspace{0.06in} \n Maximum part and file size allowed to inject in the engine. */

  /* Optional */
  /*  Server List */
  uint8_t serverList_valid;  /**< Must be set to true if serverList is being passed */
  qmiLocPredictedOrbitsServerListStructT_v02 serverList;
  /**<   \vspace{0.06in} \n List of servers that the client can use to download
       predicted orbits data. */

  /* Optional */
  /*  Server Request Update Mask */
  uint8_t serverUpdateMask_valid;  /**< Must be set to true if serverUpdateMask is being passed */
  qmiLocServerParamUpdateMaskT_v02 serverUpdateMask;
  /**<   Mask indicating parameters updated in server request
 of predicted orbits data.
      - QMI_LOC_PREDICTED_ORBITS_INJECT_REQUEST (0x00000001) --  Request for injection of predicted orbits \n
      - QMI_LOC_PREDICTED_ORBITS_SERVER_UPDATE (0x00000002) --  Update server list \n
      - QMI_LOC_PREDICTED_ORBITS_REFRESH_UPDATE_RATE (0x00000004) --  Refresh periodicity of injection  */

  /* Optional */
  /*  Update Rate Type */
  uint8_t updateType_valid;  /**< Must be set to true if updateType is being passed */
  qmiLocInjectedOrbitUpdateTypeEnumT_v02 updateType;
  /**<   Data type for which rate is being updated.
      - eQMI_LOC_INJECTED_ORBIT_RATE_UPDATE (1) --  Injected orbit rate update \n
      - eQMI_LOC_INTEGRITY_RATE_UPDATE (2) --  Integrity rate update  */

  /* Optional */
  /*  Update Rate */
  uint8_t updateRate_valid;  /**< Must be set to true if updateRate is being passed */
  uint32_t updateRate;
  /**<   Update rate for the data type indicated. \n
       - Units -- Seconds  */
}qmiLocEventInjectPredictedOrbitsReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to inject a position. */
typedef struct {

  /* Mandatory */
  /*  Latitude */
  double latitude;
  /**<   Latitude (specified in WGS84 datum).\n
       - Type -- Floating point\n
       - Units -- Degrees\n
       - Range -- -90.0 to 90.0\n
        - Positive values indicate northern latitude\n
        - Negative values indicate southern latitude
     */

  /* Mandatory */
  /*  Longitude */
  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0 \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
     */

  /* Mandatory */
  /*  Circular Horizontal Uncertainty */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular). \n
       - Units -- Meters */

  /* Mandatory */
  /*  UTC Timestamp */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds since Jan. 1, 1970
     */
}qmiLocEventInjectPositionReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCENGINESTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ENGINE_STATE_ON_V02 = 1, /**<  Location engine is on \n */
  eQMI_LOC_ENGINE_STATE_OFF_V02 = 2, /**<  Location engine is off  */
  QMILOCENGINESTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocEngineStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the engine state to the control point. */
typedef struct {

  /* Mandatory */
  /*  Engine State */
  qmiLocEngineStateEnumT_v02 engineState;
  /**<   Location engine state.
 Values: \n
      - eQMI_LOC_ENGINE_STATE_ON (1) --  Location engine is on \n
      - eQMI_LOC_ENGINE_STATE_OFF (2) --  Location engine is off
 */
}qmiLocEventEngineStateIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCFIXSESSIONSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_FIX_SESSION_STARTED_V02 = 1, /**<  Location fix session has started \n */
  eQMI_LOC_FIX_SESSION_FINISHED_V02 = 2, /**<  Location fix session has ended  */
  QMILOCFIXSESSIONSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocFixSessionStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the fix session state to the control point. */
typedef struct {

  /* Mandatory */
  /*  Session State */
  qmiLocFixSessionStateEnumT_v02 sessionState;
  /**<   LOC fix session state.
 Values: \n
      - eQMI_LOC_FIX_SESSION_STARTED (1) --  Location fix session has started \n
      - eQMI_LOC_FIX_SESSION_FINISHED (2) --  Location fix session has ended
 */

  /* Optional */
  /*  Session ID */
  uint8_t sessionId_valid;  /**< Must be set to true if sessionId is being passed */
  uint8_t sessionId;
  /**<   ID of the session specified in the Start request.
       This might not be specified for a fix session corresponding to
       a network-initiated request. \n
       - Range: 0 to 255 */
}qmiLocEventFixSessionStateIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIREQUESTENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_START_PERIODIC_HI_FREQ_FIXES_V02 = 0, /**<  Start periodic fixes with high frequency \n */
  eQMI_LOC_WIFI_START_PERIODIC_KEEP_WARM_V02 = 1, /**<  Keep warm for low frequency fixes without data downloads \n */
  eQMI_LOC_WIFI_STOP_PERIODIC_FIXES_V02 = 2, /**<  Stop periodic fixes request  */
  QMILOCWIFIREQUESTENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiRequestEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a Wi-Fi request to the control point. */
typedef struct {

  /* Mandatory */
  /*  Request Type */
  qmiLocWifiRequestEnumT_v02 requestType;
  /**<   Request type.
 Values: \n
      - eQMI_LOC_WIFI_START_PERIODIC_HI_FREQ_FIXES (0) --  Start periodic fixes with high frequency \n
      - eQMI_LOC_WIFI_START_PERIODIC_KEEP_WARM (1) --  Keep warm for low frequency fixes without data downloads \n
      - eQMI_LOC_WIFI_STOP_PERIODIC_FIXES (2) --  Stop periodic fixes request
 */

  /* Optional */
  /*  Time Between Fixes */
  uint8_t tbfInMs_valid;  /**< Must be set to true if tbfInMs is being passed */
  uint16_t tbfInMs;
  /**<   Time between fixes for a periodic request.\n
        - Units -- Milliseconds */

  /* Optional */
  /*  E911 Mode */
  uint8_t e911Mode_valid;  /**< Must be set to true if e911Mode is being passed */
  uint8_t e911Mode;
  /**<   Specifies whether the GPS engine is in E911 mode when this
       indication is sent to the client.
       Values: \n
       - 0x00 (FALSE) -- GPS engine is not in E911 mode \n
       - 0x01 (TRUE) -- GPS engine is in E911 mode
   */
}qmiLocEventWifiReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t samplesPerBatch;
  /**<   Specifies the number of samples per batch the GNSS location engine is to
       receive. Compute the sensor sampling frequency as follows: \vspace{-0.06in} \n

       samplingFrequency = samplesPerBatch * batchesPerSecond  \vspace{-0.06in} \n

       samplesPerBatch must be a nonzero positive value.
  */

  uint16_t batchesPerSecond;
  /**<   Number of sensor-data batches the GNSS location engine is to receive
       per second. The rate is specified in an integral number of batches per
       second (Hz).  \vspace{-0.06in} \n

       batchesPerSecond must be a nonzero positive value.
  */
}qmiLocSensorControlConfigSamplingSpecStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t injectEnable;
  /**<   Indicates whether the GNSS location engine is ready to accept data from this
       sensor.
       Values: \n
       - 0x01 (TRUE)  -- GNSS location engine is ready to accept sensor
                                data \n
       - 0x00 (FALSE) -- GNSS location engine is not ready to accept
                                sensor data
    */

  qmiLocSensorControlConfigSamplingSpecStructT_v02 dataFrequency;
  /**<   Rate at which the GNSS engine would like tp sample the sensor. \n
       The rate is specified in integral number of samples per second (Hz)\n
       and batches per second.
  */
}qmiLocSensorReadyStatusStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point if the GNSS location engine is
                    ready to accept sensor data. */
typedef struct {

  /* Optional */
  /*  Accelerometer Accept Ready */
  uint8_t accelReady_valid;  /**< Must be set to true if accelReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 accelReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
         to accept accelerometer sensor data.
   */

  /* Optional */
  /*  Gyroscope Accept Ready */
  uint8_t gyroReady_valid;  /**< Must be set to true if gyroReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 gyroReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
         to accept gyroscope sensor data.
   */

  /* Optional */
  /*  Accelerometer Temperature Accept Ready */
  uint8_t accelTemperatureReady_valid;  /**< Must be set to true if accelTemperatureReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 accelTemperatureReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
        to accept accelerometer temperature data.
   */

  /* Optional */
  /*  Gyroscope Temperature Accept Ready */
  uint8_t gyroTemperatureReady_valid;  /**< Must be set to true if gyroTemperatureReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 gyroTemperatureReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
         to accept gyroscope temperature data.
   */

  /* Optional */
  /*  Calibrated Magnetometer Accept Ready */
  uint8_t calibratedMagReady_valid;  /**< Must be set to true if calibratedMagReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 calibratedMagReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
         to accept calibrated magnetometer data.
   */

  /* Optional */
  /*  Uncalibrated Magnetometer Accept Ready */
  uint8_t uncalibratedMagReady_valid;  /**< Must be set to true if uncalibratedMagReady is being passed */
  qmiLocSensorReadyStatusStructT_v02 uncalibratedMagReady;
  /**<   \vspace{0.06in} \n Indicates whether the GNSS location engine is ready
         to accept uncalibrated magnetometer data.
   */
}qmiLocEventSensorStreamingReadyStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point to inject time synchronization
                    data. */
typedef struct {

  /* Mandatory */
  /*  Opaque Time Sync Reference Counter */
  uint32_t refCounter;
  /**<   This TLV is sent to registered control points. It is sent by
        the location engine when it must synchronize the location engine and
        control point (sensor processor) times.
        This TLV must be echoed back in the Time Sync Inject request. */
}qmiLocEventTimeSyncReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to enable Stationary Position
                    Indicator (SPI) streaming reports. */
typedef struct {

  /* Mandatory */
  /*  Enable/Disable SPI Requests */
  uint8_t enable;
  /**<   Indicates whether the client is to start or stop sending an SPI status stream. \n
       - 0x01 (TRUE)  -- Client is to start sending an SPI status stream \n
       - 0x00 (FALSE) -- Client is to stop sending an SPI status stream
    */
}qmiLocEventSetSpiStreamingReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWWANTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WWAN_TYPE_INTERNET_V02 = 0, /**<  Bring up the WWAN type used for an Internet connection \n */
  eQMI_LOC_WWAN_TYPE_AGNSS_V02 = 1, /**<  Bring up the WWAN type used for AGNSS connections \n  */
  eQMI_LOC_WWAN_TYPE_AGNSS_EMERGENCY_V02 = 2, /**<  Bring up the WWAN type used for AGNSS emergency connections  */
  QMILOCWWANTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWWANTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSERVERREQUESTENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SERVER_REQUEST_OPEN_V02 = 1, /**<  Open a connection to the location server \n  */
  eQMI_LOC_SERVER_REQUEST_CLOSE_V02 = 2, /**<  Close a connection to the location server  */
  QMILOCSERVERREQUESTENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocServerRequestEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCBEARERTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_BEARER_TYPE_WWAN_V02 = 1, /**<  Request if for WWAN based connection \n */
  eQMI_LOC_BEARER_TYPE_WLAN_V02 = 2, /**<  Request if for WLAN based connection \n */
  eQMI_LOC_BEARER_TYPE_ANY_V02 = 3, /**<  Request for any available bearer WLAN/WWAN based connection */
  QMILOCBEARERTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocBearerTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSYSMODEMASIDTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SYS_MODEM_AS_ID_1_V02 = 0, /**<  Subscription ID 1 \n */
  eQMI_LOC_SYS_MODEM_AS_ID_2_V02 = 1, /**<  Subscription ID 2 \n */
  eQMI_LOC_SYS_MODEM_AS_ID_3_V02 = 2, /**<  Subscription ID 3  */
  QMILOCSYSMODEMASIDTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSysModemAsIdTypeEnumT_v02;
/**
    @}
  */

typedef uint64_t qmiLocApnTypeMaskT_v02;
#define QMI_LOC_APN_TYPE_MASK_DEFAULT_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000001ull) /**<  APN type for default/Internet traffic\n */
#define QMI_LOC_APN_TYPE_MASK_IMS_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000002ull) /**<  APN type for IP Multimedia Subsystem \n  */
#define QMI_LOC_APN_TYPE_MASK_MMS_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000004ull) /**<  APN type for multimedia messaging service \n  */
#define QMI_LOC_APN_TYPE_MASK_DUN_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000008ull) /**<  APN type for dial up network  */
#define QMI_LOC_APN_TYPE_MASK_SUPL_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000010ull) /**<  APN type for secure user plane location \n */
#define QMI_LOC_APN_TYPE_MASK_HIPRI_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000020ull) /**<   APN type for high priority mobile data \n */
#define QMI_LOC_APN_TYPE_MASK_FOTA_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000040ull) /**<   APN type for over the air administration \n */
#define QMI_LOC_APN_TYPE_MASK_CBS_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000080ull) /**<   APN type for carrier branded services \n */
#define QMI_LOC_APN_TYPE_MASK_IA_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000100ull) /**<  APN type for initial attach \n  */
#define QMI_LOC_APN_TYPE_MASK_EMERGENCY_V02 ((qmiLocApnTypeMaskT_v02)0x0000000000000200ull) /**<  APN type for emergency  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the client to open or close a connection
                    to the assisted GPS location server. */
typedef struct {

  /* Mandatory */
  /*  Connection Handle */
  uint32_t connHandle;
  /**<   Identifies a connection across Open and Close request events. */

  /* Mandatory */
  /*  Request Type */
  qmiLocServerRequestEnumT_v02 requestType;
  /**<   Open or close a connection to the location server.
 Values: \n
      - eQMI_LOC_SERVER_REQUEST_OPEN (1) --  Open a connection to the location server \n
      - eQMI_LOC_SERVER_REQUEST_CLOSE (2) --  Close a connection to the location server
 */

  /* Mandatory */
  /*  WWAN Type */
  qmiLocWWANTypeEnumT_v02 wwanType;
  /**<   Identifies the WWAN type for this request.
 Values: \n
      - eQMI_LOC_WWAN_TYPE_INTERNET (0) --  Bring up the WWAN type used for an Internet connection \n
      - eQMI_LOC_WWAN_TYPE_AGNSS (1) --  Bring up the WWAN type used for AGNSS connections \n
      - eQMI_LOC_WWAN_TYPE_AGNSS_EMERGENCY (2) --  Bring up the WWAN type used for AGNSS emergency connections
 */

  /* Optional */
  /*  Bearer Type */
  uint8_t bearerType_valid;  /**< Must be set to true if bearerType is being passed */
  qmiLocBearerTypeEnumT_v02 bearerType;
  /**<   Identifies the bearer type for this WWAN/WLAN request.
 Used in a situation where the data connection for GPS
 functionality over both WLAN and WWAN is supported. This field helps the modem GPS stack inform the AP
 GPS stack to bring up the data connection on a particular bearer type.
 This is helpful when both the WWAN and WLAN are available and use of one specific bearer is requested.
 In the process, the bearer type field is omitted and the AP GPS stack relies on the WWAN type field
 to bring up the data connection. \n
 Values: \n
      - eQMI_LOC_BEARER_TYPE_WWAN (1) --  Request if for WWAN based connection \n
      - eQMI_LOC_BEARER_TYPE_WLAN (2) --  Request if for WLAN based connection \n
      - eQMI_LOC_BEARER_TYPE_ANY (3) --  Request for any available bearer WLAN/WWAN based connection
 */

  /* Optional */
  /*  APN Type Mask */
  uint8_t apnTypeMask_valid;  /**< Must be set to true if apnTypeMask is being passed */
  qmiLocApnTypeMaskT_v02 apnTypeMask;
  /**<   Bitmask specifies the APN type for the requested connection.
 This bitmask uniquely identifies a data connection which the AP brought up
 for the data connection request of the modem GPS stack. This mask is
 provided to the data services as part of the policy to identify the correct
 data connection AP. In case of emergency connections, this bitmask is provided by the data services to help the clients
 latch on to the correct data call. The client (GPS) provides this mask to the AP to
 bring up the correct emergency call, identified by this mask.
 In the process, the APN type mask field is omitted and the AP GPS stack falls back to the legacy behavior
 to request the data connection based on the WWAN type provided.\n
 Valid bitmask: \n
      - QMI_LOC_APN_TYPE_MASK_DEFAULT (0x0000000000000001) --  APN type for default/Internet traffic\n
      - QMI_LOC_APN_TYPE_MASK_IMS (0x0000000000000002) --  APN type for IP Multimedia Subsystem \n
      - QMI_LOC_APN_TYPE_MASK_MMS (0x0000000000000004) --  APN type for multimedia messaging service \n
      - QMI_LOC_APN_TYPE_MASK_DUN (0x0000000000000008) --  APN type for dial up network
      - QMI_LOC_APN_TYPE_MASK_SUPL (0x0000000000000010) --  APN type for secure user plane location \n
      - QMI_LOC_APN_TYPE_MASK_HIPRI (0x0000000000000020) --   APN type for high priority mobile data \n
      - QMI_LOC_APN_TYPE_MASK_FOTA (0x0000000000000040) --   APN type for over the air administration \n
      - QMI_LOC_APN_TYPE_MASK_CBS (0x0000000000000080) --   APN type for carrier branded services \n
      - QMI_LOC_APN_TYPE_MASK_IA (0x0000000000000100) --  APN type for initial attach \n
      - QMI_LOC_APN_TYPE_MASK_EMERGENCY (0x0000000000000200) --  APN type for emergency
 */

  /* Optional */
  /*  Subscription ID */
  uint8_t subId_valid;  /**< Must be set to true if subId is being passed */
  qmiLocSysModemAsIdTypeEnumT_v02 subId;
  /**<   Subscription ID on which to bring up the connection. Values: \n
      - eQMI_LOC_SYS_MODEM_AS_ID_1 (0) --  Subscription ID 1 \n
      - eQMI_LOC_SYS_MODEM_AS_ID_2 (1) --  Subscription ID 2 \n
      - eQMI_LOC_SYS_MODEM_AS_ID_3 (2) --  Subscription ID 3
 */
}qmiLocEventLocationServerConnectionReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNIGEOFENCEOPERATIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_GEOFENCE_ADDED_V02 = 1, /**<  A network-initated Geofence was added \n */
  eQMI_LOC_NI_GEOFENCE_DELETED_V02 = 2, /**<  A network-initated Geofence was deleted \n */
  eQMI_LOC_NI_GEOFENCE_EDITED_V02 = 3, /**<  A network-initated Geofence was edited; the control point can query the
       Geofence to find the its current state  */
  QMILOCNIGEOFENCEOPERATIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiGeofenceOperationEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Informs the control point about
                    network-initiated Geofences. */
typedef struct {

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   ID of the Geofence for which this
       notification was generated. */

  /* Mandatory */
  /*  Operation Type */
  qmiLocNiGeofenceOperationEnumT_v02 operationType;
  /**<   Operation for which this notification was generated.
 Values: \n
      - eQMI_LOC_NI_GEOFENCE_ADDED (1) --  A network-initated Geofence was added \n
      - eQMI_LOC_NI_GEOFENCE_DELETED (2) --  A network-initated Geofence was deleted \n
      - eQMI_LOC_NI_GEOFENCE_EDITED (3) --  A network-initated Geofence was edited; the control point can query the
       Geofence to find the its current state
 */
}qmiLocEventNiGeofenceNotificationIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEGENALERTENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_GEN_ALERT_GNSS_UNAVAILABLE_V02 = 1, /**<  GNSS is unavailable and GNSS position fixes
       cannot be used to monitor Geofences \n  */
  eQMI_LOC_GEOFENCE_GEN_ALERT_GNSS_AVAILABLE_V02 = 2, /**<  GNSS is now available and GNSS postion fixes can
       be used to monitor Geofences \n */
  eQMI_LOC_GEOFENCE_GEN_ALERT_OOS_V02 = 3, /**<  The engine is out of service and no cell ID coverage
       information is available \n */
  eQMI_LOC_GEOFENCE_GEN_ALERT_TIME_INVALID_V02 = 4, /**<  The engine has an invalid time  */
  QMILOCGEOFENCEGENALERTENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceGenAlertEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of the
                    Geofence status. */
typedef struct {

  /* Mandatory */
  /*  Geofence General Alert */
  qmiLocGeofenceGenAlertEnumT_v02 geofenceAlert;
  /**<   Specifies the Geofence general alert type.
 Values: \n
      - eQMI_LOC_GEOFENCE_GEN_ALERT_GNSS_UNAVAILABLE (1) --  GNSS is unavailable and GNSS position fixes
       cannot be used to monitor Geofences \n
      - eQMI_LOC_GEOFENCE_GEN_ALERT_GNSS_AVAILABLE (2) --  GNSS is now available and GNSS postion fixes can
       be used to monitor Geofences \n
      - eQMI_LOC_GEOFENCE_GEN_ALERT_OOS (3) --  The engine is out of service and no cell ID coverage
       information is available \n
      - eQMI_LOC_GEOFENCE_GEN_ALERT_TIME_INVALID (4) --  The engine has an invalid time
 */
}qmiLocEventGeofenceGenAlertIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEBREACHTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_BREACH_TYPE_ENTERING_V02 = 1, /**<  Indicates that a client entered the Geofence \n */
  eQMI_LOC_GEOFENCE_BREACH_TYPE_LEAVING_V02 = 2, /**<  Indicates that a client left the Geofence  */
  QMILOCGEOFENCEBREACHTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceBreachTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  /*  UTC timestamp */
  uint64_t timestampUtc;
  /**<   - Units -- Milliseconds since Jan. 1, 1970
    */

  /*  Latitude */
  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0  \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
    */

  /*   Longitude */
  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0  \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
    */

  /*  Horizontal elliptical uncertainty (semi-minor axis) */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /*  Horizontal elliptical uncertainty (semi-major axis) */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /*  Elliptical horizontal uncertainty azimuth */
  float horUncEllipseOrientAzimuth;
  /**<   Elliptical horizontal uncertainty azimuth of orientation.\n
       - Units -- Decimal degrees \n
       - Range -- 0 to 180 */

  /*  Horizontal speed validity bit */
  uint8_t speedHorizontal_valid;
  /**<   Indicates whether the horizontal speed field contains valid
       information.
       Values: \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
       */

  /*  Horizontal speed */
  float speedHorizontal;
  /**<   - Units -- Meters per second */

  /*  Altitude validity bit */
  uint8_t altitudeWrtEllipsoid_valid;
  /**<   Indicates whether the altitude field contains valid
       information. Values: \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
       */

  /*  Altitude with respect to ellipsoid */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid. \n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  /*  Vertical uncertainty validity bit */
  uint8_t vertUnc_valid;
  /**<   Indicates whether the vertical uncertainty field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
       */

  /*  Vertical uncertainty */
  float vertUnc;
  /**<   - Units -- Meters */

  /*  Vertical speed validity bit */
  uint8_t speedVertical_valid;
  /**<   Indicates whether the vertical speed field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
     */

  /*  Vertical speed */
  float speedVertical;
  /**<   - Units -- Meters per second */

  /*  Heading validity bit */
  uint8_t heading_valid;
  /**<   Indicates whether the heading field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
     */

  /*  Heading */
  float heading;
  /**<   - Units -- Degrees \n
        - Range -- 0 to 359.999  */
}qmiLocGeofencePositionStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCECONFIDENCEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_CONFIDENCE_LOW_V02 = 0x01, /**<  Geofence engine indicates a breach with
       low confidence; this setting results in lower
       power usage, and it can impact the yield because
       incorrect breach events can be sent \n */
  eQMI_LOC_GEOFENCE_CONFIDENCE_MED_V02 = 0x02, /**<  (Default) Geofence engine indicates a breach with
       medium confidence \n */
  eQMI_LOC_GEOFENCE_CONFIDENCE_HIGH_V02 = 0x03, /**<  Geofence engine indicates a breach with
       high confidence; this setting results in higher
       power usage  */
  QMILOCGEOFENCECONFIDENCEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceConfidenceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of
                    a Geofence breach event. */
typedef struct {

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   ID of the Geofence for which this
       notification was generated. */

  /* Mandatory */
  /*  Geofence Breach Type */
  qmiLocGeofenceBreachTypeEnumT_v02 breachType;
  /**<   The type of breach that generated this event.
 Values: \n
      - eQMI_LOC_GEOFENCE_BREACH_TYPE_ENTERING (1) --  Indicates that a client entered the Geofence \n
      - eQMI_LOC_GEOFENCE_BREACH_TYPE_LEAVING (2) --  Indicates that a client left the Geofence
 */

  /* Optional */
  /*  Geofence Position */
  uint8_t geofencePosition_valid;  /**< Must be set to true if geofencePosition is being passed */
  qmiLocGeofencePositionStructT_v02 geofencePosition;
  /**<   \vspace{0.06in} \n Position of the client when it breached the Geofence.
       This TLV is included if the client configures the
       Geofence to report position. The position is reported
       at the same confidence level that was specified in the
       Add Circular Geofence request. */

  /* Optional */
  /*  Geofence Breach Confidence */
  uint8_t breachConfidence_valid;  /**< Must be set to true if breachConfidence is being passed */
  qmiLocGeofenceConfidenceEnumT_v02 breachConfidence;
  /**<   Given a breach event, the confidence determines the probability
 that the breach happened at the Geofence boundary.
 Values: \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_LOW (0x01) --  Geofence engine indicates a breach with
       low confidence; this setting results in lower
       power usage, and it can impact the yield because
       incorrect breach events can be sent \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_MED (0x02) --  (Default) Geofence engine indicates a breach with
       medium confidence \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_HIGH (0x03) --  Geofence engine indicates a breach with
       high confidence; this setting results in higher
       power usage
 */
}qmiLocEventGeofenceBreachIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Recommends how to send pedometer reports to the location engine. */
typedef struct {

  /* Mandatory */
  /*  Request Pedometer Data */
  uint8_t requestPedometerData;
  /**<   Indicates whether the GNSS location engine is requesting the client to
       send pedometer data. \n
       - 0x01 (TRUE) -- GNSS location engine is requesting
                                pedometer data \n
       - 0x00 (FALSE) -- GNSS location engine is not requesting
                                pedometer data
      */

  /* Optional */
  /*  Reset Step Count */
  uint8_t resetStepCount_valid;  /**< Must be set to true if resetStepCount is being passed */
  uint8_t resetStepCount;
  /**<   Indicates whether the location engine is to reset the step count. \n
       - 0x01 (TRUE)  -- Reset pedometer step count \n
       - 0x00 (FALSE) -- Do not reset pedometer step count
        */

  /* Optional */
  /*  Step Count Threshold */
  uint8_t stepCountThreshold_valid;  /**< Must be set to true if stepCountThreshold is being passed */
  uint32_t stepCountThreshold;
  /**<   Specifies the number of steps to sample in a pedometer report,
       as recommended by the location engine. If the threshold is set to 0,
       the location engine wants a pedometer report at every step event.
  */
}qmiLocEventPedometerControlIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Recommends how to send motion data reports to the location engine. */
typedef struct {

  /* Mandatory */
  /*  Request Motion Data */
  uint8_t requestMotionData;
  /**<   Indicates whether the GNSS location engine is requesting
       the client to send motion data.\n
       - 0x01 (TRUE)  -- GNSS location engine is requesting
                                motion data \n
       - 0x00 (FALSE) -- GNSS location engine is not requesting
                                motion data
      */
}qmiLocEventMotionDataControlIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  /*  Low Geofence ID */
  uint32_t idLow;
  /**<   Contains the starting ID of the Geofence in the range of the continuous
       range of Geofences that were breached at the same position. */

  /*  High Geofence ID */
  uint32_t idHigh;
  /**<   Contains the ending ID of the Geofence in the range of the continuous
         range of Geofences that were breached at the same position. */
}qmiLocGeofenceIdContinuousStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of a Geofence breach event by
                    batching all the Geofences that were breached. */
typedef struct {

  /* Mandatory */
  /*  Geofence Breach Type */
  qmiLocGeofenceBreachTypeEnumT_v02 breachType;
  /**<   Type of breach that generated this event.
 Values: \n
      - eQMI_LOC_GEOFENCE_BREACH_TYPE_ENTERING (1) --  Indicates that a client entered the Geofence \n
      - eQMI_LOC_GEOFENCE_BREACH_TYPE_LEAVING (2) --  Indicates that a client left the Geofence
 */

  /* Optional */
  /*  Geofence ID Continuous */
  uint8_t geofenceIdContinuousList_valid;  /**< Must be set to true if geofenceIdContinuousList is being passed */
  uint32_t geofenceIdContinuousList_len;  /**< Must be set to # of elements in geofenceIdContinuousList */
  qmiLocGeofenceIdContinuousStructT_v02 geofenceIdContinuousList[QMI_LOC_MAX_GEOFENCE_ID_CONTINUOUS_LIST_LENGTH_V02];
  /**<   \vspace{0.06in} \n Each entry in the list contains the continuous range of Geofence IDs that were breached
      at the same position. This list does not overlap with the discrete Geofence ID list. */

  /* Optional */
  /*  Geofence ID Discrete */
  uint8_t geofenceIdDiscreteList_valid;  /**< Must be set to true if geofenceIdDiscreteList is being passed */
  uint32_t geofenceIdDiscreteList_len;  /**< Must be set to # of elements in geofenceIdDiscreteList */
  uint32_t geofenceIdDiscreteList[QMI_LOC_MAX_GEOFENCE_ID_DISCRETE_LIST_LENGTH_V02];
  /**<   This list contains the Geofence IDs that were breached at the same position.
       This list does not overlap with the continuous Geofence ID list. */

  /* Optional */
  /*  Geofence Position */
  uint8_t geofencePosition_valid;  /**< Must be set to true if geofencePosition is being passed */
  qmiLocGeofencePositionStructT_v02 geofencePosition;
  /**<   \vspace{0.06in} \n Position of the client when it breached the Geofence.
       This TLV is included if the client configures the
       Geofence to report its position. The position is reported
       at the same confidence level that was specified in the
       Add Circular Geofence request. */

  /* Optional */
  /*  Geofence Breach Confidence */
  uint8_t breachConfidence_valid;  /**< Must be set to true if breachConfidence is being passed */
  qmiLocGeofenceConfidenceEnumT_v02 breachConfidence;
  /**<   Given a breach event, the confidence determines the probability
 that the breach happened at the Geofence boundary.
 Values: \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_LOW (0x01) --  Geofence engine indicates a breach with
       low confidence; this setting results in lower
       power usage, and it can impact the yield because
       incorrect breach events can be sent \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_MED (0x02) --  (Default) Geofence engine indicates a breach with
       medium confidence \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_HIGH (0x03) --  Geofence engine indicates a breach with
       high confidence; this setting results in higher
       power usage
 */

  /* Optional */
  /*  Heading Uncertainty */
  uint8_t headingUnc_valid;  /**< Must be set to true if headingUnc is being passed */
  float headingUnc;
  /**<   - Units -- Degrees \n
       - Range -- 0 to 359.999 */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   - Units -- Meters */

  /* Optional */
  /*  Speed Uncertainty */
  uint8_t speedUnc_valid;  /**< Must be set to true if speedUnc is being passed */
  float speedUnc;
  /**<   3D speed uncertainty. \n
       - Units -- Meters per second */

  /* Optional */
  /*  Horizontal Confidence */
  uint8_t horConfidence_valid;  /**< Must be set to true if horConfidence is being passed */
  uint8_t horConfidence;
  /**<   Horizontal uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Dilution of Precision */
  uint8_t DOP_valid;  /**< Must be set to true if DOP is being passed */
  qmiLocDOPStructT_v02 DOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  SVs Used to Calculate the Fix */
  uint8_t gnssSvUsedList_valid;  /**< Must be set to true if gnssSvUsedList is being passed */
  uint32_t gnssSvUsedList_len;  /**< Must be set to # of elements in gnssSvUsedList */
  uint16_t gnssSvUsedList[QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
       used for calculating this position report. The following
       information is associated with each SV ID.
       Range:    \n
       - GPS --     1 to 32 \n
       - GLONASS -- 65 to 96  \n
       - SBAS --    120 to 158 and 183 to 191  \n
       - QZSS --    193 to 197 \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414
        */

  /* Optional */
  /*  Extended Dilution of Precision */
  uint8_t extDOP_valid;  /**< Must be set to true if extDOP is being passed */
  qmiLocExtDOPStructT_v02 extDOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   If the service reports expandedGnssSvUsedList, gnssSvUsedList is
      not reported. Each entry in the list contains the SV ID of a satellite
      used to calculate this position report. The following
      information is associated with each SV ID.
      Range: \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96 \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414
      */

  /* Optional */
  /*  Satellite Signal Types in the SVs Used list */
  uint8_t gnssSvUsedSignalTypeList_valid;  /**< Must be set to true if gnssSvUsedSignalTypeList is being passed */
  uint32_t gnssSvUsedSignalTypeList_len;  /**< Must be set to # of elements in gnssSvUsedSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSvUsedSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedGnssSvUsedList. The
 signal type list is aligned with the SVs in expandedGnssSvUsedList. Value of 0
 means invalid.\n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */
}qmiLocEventGeofenceBatchedBreachIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEPROXIMITYTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_PROXIMITY_TYPE_IN_V02 = 1, /**<  Indicates that a client is in proximity of the Geofence \n  */
  eQMI_LOC_GEOFENCE_PROXIMITY_TYPE_OUT_V02 = 2, /**<  Indicates that a client is out of proximity of the Geofence  */
  QMILOCGEOFENCEPROXIMITYTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceProximityTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of a Geofence proximity event. */
typedef struct {

  /* Mandatory */
  /*  Geofence Breach Type */
  qmiLocGeofenceProximityTypeEnumT_v02 proximityType;
  /**<   Values: \n
      - eQMI_LOC_GEOFENCE_PROXIMITY_TYPE_IN (1) --  Indicates that a client is in proximity of the Geofence \n
      - eQMI_LOC_GEOFENCE_PROXIMITY_TYPE_OUT (2) --  Indicates that a client is out of proximity of the Geofence
 */

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   Identifier of the Geofence that is in proximity to the handset.
  */

  /* Optional */
  /*  Geofence Context ID */
  uint8_t contextId_valid;  /**< Must be set to true if contextId is being passed */
  uint32_t contextId;
  /**<    Identifier for the context of the Geofence to which the handset is in proximity.
        A single Geofence might be associated with different contexts.
  */
}qmiLocEventGeofenceProximityIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEDWELLTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_DWELL_TYPE_INSIDE_V02 = 1, /**<  Indicates that a client dwelled inside the Geofence \n */
  eQMI_LOC_GEOFENCE_DWELL_TYPE_OUTSIDE_V02 = 2, /**<  Indicates that a client dwelled outside the Geofence  */
  QMILOCGEOFENCEDWELLTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceDwellTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of a Geofence dwell event by
                    batching all the Geofences that were dwelled in. */
typedef struct {

  /* Mandatory */
  /*  Geofence Dwell Type */
  qmiLocGeofenceDwellTypeEnumT_v02 dwellType;
  /**<   Type of dwell event generated.
 Values: \n
      - eQMI_LOC_GEOFENCE_DWELL_TYPE_INSIDE (1) --  Indicates that a client dwelled inside the Geofence \n
      - eQMI_LOC_GEOFENCE_DWELL_TYPE_OUTSIDE (2) --  Indicates that a client dwelled outside the Geofence
 */

  /* Optional */
  /*  Geofence ID Continuous */
  uint8_t geofenceIdContinuousList_valid;  /**< Must be set to true if geofenceIdContinuousList is being passed */
  uint32_t geofenceIdContinuousList_len;  /**< Must be set to # of elements in geofenceIdContinuousList */
  qmiLocGeofenceIdContinuousStructT_v02 geofenceIdContinuousList[QMI_LOC_MAX_GEOFENCE_ID_CONTINUOUS_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the continuous range of Geofence IDs in which a client dwelled.
       This list does not overlap with the discrete Geofence ID list. */

  /* Optional */
  /*  Geofence ID Discrete */
  uint8_t geofenceIdDiscreteList_valid;  /**< Must be set to true if geofenceIdDiscreteList is being passed */
  uint32_t geofenceIdDiscreteList_len;  /**< Must be set to # of elements in geofenceIdDiscreteList */
  uint32_t geofenceIdDiscreteList[QMI_LOC_MAX_GEOFENCE_ID_DISCRETE_LIST_LENGTH_V02];
  /**<   This list contains the Geofence IDs in which a client dwelled.
       This list does not overlap with the continuous Geofence ID list. */

  /* Optional */
  /*  Geofence Position */
  uint8_t geofencePosition_valid;  /**< Must be set to true if geofencePosition is being passed */
  qmiLocGeofencePositionStructT_v02 geofencePosition;
  /**<   \n The latest position calculated by the Geofence engine when
       the dwell notification is sent. */

  /* Optional */
  /*  Heading Uncertainty */
  uint8_t headingUnc_valid;  /**< Must be set to true if headingUnc is being passed */
  float headingUnc;
  /**<   Heading uncertainty.\n
       - Units -- Degrees \n
       - Range -- 0 to 359.999 */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   Vertical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  Speed Uncertainty */
  uint8_t speedUnc_valid;  /**< Must be set to true if speedUnc is being passed */
  float speedUnc;
  /**<   3D speed uncertainty.\n
       - Units -- Meters per second */

  /* Optional */
  /*  Horizontal Confidence */
  uint8_t horConfidence_valid;  /**< Must be set to true if horConfidence is being passed */
  uint8_t horConfidence;
  /**<   Horizontal uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Dilution of Precision */
  uint8_t DOP_valid;  /**< Must be set to true if DOP is being passed */
  qmiLocDOPStructT_v02 DOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  SVs Used to Calculate the Fix */
  uint8_t gnssSvUsedList_valid;  /**< Must be set to true if gnssSvUsedList is being passed */
  uint32_t gnssSvUsedList_len;  /**< Must be set to # of elements in gnssSvUsedList */
  uint16_t gnssSvUsedList[QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
       used for calculating this position report. The following
       information is associated with each SV ID.
       Range:    \n
       - GPS --     1 to 32 \n
       - GLONASS -- 65 to 96 \n
       - SBAS --    120 to 158 and 183 to 191 \n
       - QZSS --    193 to 197 \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414
        */

  /* Optional */
  /*  Extended Dilution of Precision */
  uint8_t extDOP_valid;  /**< Must be set to true if extDOP is being passed */
  qmiLocExtDOPStructT_v02 extDOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   If the service reports expandedGnssSvUsedList, gnssSvUsedList is
        not reported. Each entry in the list contains the SV ID of a satellite
        used to calculate this position report. The following
        information is associated with each SV ID.
        Range: \n
        - GPS --     1 to 32 \n
        - GLONASS -- 65 to 96 \n
        - QZSS --    193 to 197 \n
        - BDS --     201 to 263 \n
        - Galileo -- 301 to 336 \n
        - NavIC --   401 to 414
      */

  /* Optional */
  /*  Satellite Signal Types in the SVs Used list */
  uint8_t gnssSvUsedSignalTypeList_valid;  /**< Must be set to true if gnssSvUsedSignalTypeList is being passed */
  uint32_t gnssSvUsedSignalTypeList_len;  /**< Must be set to # of elements in gnssSvUsedSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSvUsedSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedGnssSvUsedList. The
 signal type list is aligned with the SVs in expandedGnssSvUsedList. Value 0
 means invalid.
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */
}qmiLocEventGeofenceBatchedDwellIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGDTSERVICEIDENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GDT_SERVICE_WWAN_V02 = 1, /**<  GDT service for WWAN UL \n  */
  eQMI_LOC_GDT_SERVICE_WWAN_DL_V02 = 2, /**<  GDT service for WWAN DL \n  */
  eQMI_LOC_GDT_SERVICE_CSM_UL_V02 = 3, /**<  GDT service for Crowdsource Manager UL  */
  QMILOCGDTSERVICEIDENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGdtServiceIdEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGDTACCESSSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GDT_ACCESS_ALLOWED_V02 = 1, /**<  GDT access to the service is allowed \n  */
  eQMI_LOC_GDT_ACCESS_FAILED_V02 = 2, /**<  Any type of GDT access error \n  */
  eQMI_LOC_GDT_ACCESS_NOT_ALLOWED_V02 = 3, /**<  GDT access to the service is not allowed   */
  QMILOCGDTACCESSSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGdtAccessStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to transfer data. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  Data */
  uint32_t filePath_len;  /**< Must be set to # of elements in filePath */
  char filePath[QMI_LOC_MAX_GDT_PATH_LEN_V02];
  /**<   File path to the data. \n
         - Type: Array of bytes \n
         - Maximum length of the array: 255
    */
}qmiLocEventGdtUploadBeginStatusReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGDTENDSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GDT_SUCCESS_V02 = 1, /**<  The sent data was accepted \n  */
  eQMI_LOC_GDT_FAILED_V02 = 2, /**<  The sent data was not accepted \n  */
  eQMI_LOC_GDT_INVALID_V02 = 3, /**<  General error in the received data  */
  QMILOCGDTENDSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGdtEndStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to report the status of the
                    transferred data. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;

  /* Mandatory */
  /*  GDT End Status */
  qmiLocGdtEndStatusEnumT_v02 endStatus;
  /**<   Values: \n
      - eQMI_LOC_GDT_SUCCESS (1) --  The sent data was accepted \n
      - eQMI_LOC_GDT_FAILED (2) --  The sent data was not accepted \n
      - eQMI_LOC_GDT_INVALID (3) --  General error in the received data  */
}qmiLocEventGdtUploadEndReqIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocGdtDownloadReqMaskT_v02;
#define QMI_LOC_GDT_DOWNLOAD_REQ_MASK_DBH_V02 ((qmiLocGdtDownloadReqMaskT_v02)0x00000001) /**<  Bitmask specifying whether DBH is on for the request.   */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to transfer data. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  Interval After Which AP Must Respond to MP */
  uint32_t respTimeoutInterval;
  /**<   Interval after which the AP must respond to the MP, in seconds. */

  /* Mandatory */
  /*  Encoded GTP Client Information */
  uint32_t clientInfo_len;  /**< Must be set to # of elements in clientInfo */
  uint8_t clientInfo[QMI_LOC_MAX_GTP_CL_INFO_LEN_V02];
  /**<   GTP client information encoded in asn.1 format. \n
         - Type: Array of bytes \n
         - Maximum length of the array: 1500
    */

  /* Mandatory */
  /*  Encoded Mobile Status Data */
  uint32_t mobileStatusData_len;  /**< Must be set to # of elements in mobileStatusData */
  uint8_t mobileStatusData[QMI_LOC_MAX_GTP_MSD_LEN_V02];
  /**<   Mobile status data encoded in asn.1 format. \n
         - Type: Array of bytes \n
         - Maximum length of the array: 4000
    */

  /* Mandatory */
  /*  Data Filepath (NULL-Terminated) */
  uint32_t filePath_len;  /**< Must be set to # of elements in filePath */
  char filePath[QMI_LOC_MAX_GDT_PATH_LEN_V02];
  /**<   File path to the GTP response data that is applicable to the MP. \n
         - Type: Array of bytes \n
         - Maximum length of the array: 255
    */

  /* Optional */
  /*  Power Budget Info */
  uint8_t powerBudgetInfo_valid;  /**< Must be set to true if powerBudgetInfo is being passed */
  uint32_t powerBudgetInfo;
  /**<   Power budget information. */

  /* Optional */
  /*  Power Budget Allowance */
  uint8_t powerBudgetAllowance_valid;  /**< Must be set to true if powerBudgetAllowance is being passed */
  uint32_t powerBudgetAllowance;
  /**<   Power budget allowance. */

  /* Optional */
  /*  Download Request Mask */
  uint8_t downloadRequestMask_valid;  /**< Must be set to true if downloadRequestMask is being passed */
  qmiLocGdtDownloadReqMaskT_v02 downloadRequestMask;
  /**<   Download request mask. */
}qmiLocEventGdtDownloadBeginReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGDTRECEIVESTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GTP_RCV_STATUS_CONTINUE_V02 = 1, /**<  Indicates that the AP is to continue sending more partitions to the MP \n */
  eQMI_LOC_GTP_RCV_STATUS_DONE_V02 = 2, /**<  Indicates that the AP is to stop sending partitions to the MP  */
  QMILOCGDTRECEIVESTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGdtReceiveStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point after consuming the current data transfer. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  GDT Receive Status */
  qmiLocGdtReceiveStatusEnumT_v02 status;
  /**<   Status indicating the continuation or termination of sending to the AP.
 Values: \n
      - eQMI_LOC_GTP_RCV_STATUS_CONTINUE (1) --  Indicates that the AP is to continue sending more partitions to the MP \n
      - eQMI_LOC_GTP_RCV_STATUS_DONE (2) --  Indicates that the AP is to stop sending partitions to the MP
 */
}qmiLocEventGdtReceiveDoneIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of the end of a download session. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  GDT Download End Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the download session.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocEventGdtDownloadEndReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the client to query the service revision. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetServiceRevisionReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the client to query the service revision. */
typedef struct {

  /* Mandatory */
  /*  Get Revision Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Revision request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Interface Definition Minor Revision */
  uint32_t revision;
  /**<   Revision of the service. This is the minor revision of the interface that
       the service implements. Minor revision updates of the service are always
       backward compatible. */

  /* Optional */
  /*  GNSS Measurement Engine Firmware Version String */
  uint8_t gnssMeFWVerString_valid;  /**< Must be set to true if gnssMeFWVerString is being passed */
  char gnssMeFWVerString[QMI_LOC_GNSS_ME_VERSION_STRING_MAX_LENGTH_V02 + 1];
  /**<   Version of the GNSS measurement engine software running under the LOC API. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 128 \n
       \textbf{Note:} This string is only provided on platforms that have
       a measurement engine that supports this version string. On all other
       platforms, this optional TLV is not provided. */

  /* Optional */
  /*  GNSS Hosted Software Version String */
  uint8_t gnssHostSWVerString_valid;  /**< Must be set to true if gnssHostSWVerString is being passed */
  char gnssHostSWVerString[QMI_LOC_GNSS_HOSTED_SW_VERSION_STRING_MAX_LENGTH_V02 + 1];
  /**<   Version of the GNSS hosted software running under the LOC API.\n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 128 \n
       \textbf{Note:} This string is only provided on hosted architectures
       (measurement and position engine running on different processors) that
       support this version string. All other platforms do not provide this optional TLV. */

  /* Optional */
  /*  GNSS Software Version String */
  uint8_t gnssSWVerString_valid;  /**< Must be set to true if gnssSWVerString is being passed */
  char gnssSWVerString[QMI_LOC_GNSS_SW_VERSION_STRING_MAX_LENGTH_V02 + 1];
  /**<   Aggregate version of the GNSS software. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 256
     */
}qmiLocGetServiceRevisionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the fix criteria from the location engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetFixCriteriaReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the fix criteria from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get Fix Criteria Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_FIX_CRITERIA_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Horizontal Accuracy */
  uint8_t horizontalAccuracyLevel_valid;  /**< Must be set to true if horizontalAccuracyLevel is being passed */
  qmiLocAccuracyLevelEnumT_v02 horizontalAccuracyLevel;
  /**<   Horizontal accuracy level.
 Values: \n
      - eQMI_LOC_ACCURACY_LOW (1) --  Low accuracy \n
      - eQMI_LOC_ACCURACY_MED (2) --  Medium accuracy \n
      - eQMI_LOC_ACCURACY_HIGH (3) --  High accuracy
 */

  /* Optional */
  /*  Enable/Disable Intermediate Fixes */
  uint8_t intermediateReportState_valid;  /**< Must be set to true if intermediateReportState is being passed */
  qmiLocIntermediateReportStateEnumT_v02 intermediateReportState;
  /**<   Intermediate report state (ON, OFF).\n
 The client must explicitly set this field to OFF to stop receiving
 intermediate position reports. Intermediate position reports are
 generated at 1 Hz and are ON by default. If intermediate reports
 are turned ON, the client receives position reports even if the
 accuracy criteria is not met. The status in the position report is
 set to IN_PROGRESS for intermediate reports.
 Values: \n
      - eQMI_LOC_INTERMEDIATE_REPORTS_ON (1) --  Intermediate reports are turned on \n
      - eQMI_LOC_INTERMEDIATE_REPORTS_OFF (2) --  Intermediate reports are turned off
 */

  /* Optional */
  /*  Minimum Interval Between Fixes */
  uint8_t minInterval_valid;  /**< Must be set to true if minInterval is being passed */
  uint32_t minInterval;
  /**<   Time that must elapse before alerting the client. \n
       - Units -- Milliseconds */

  /* Optional */
  /*  ID of the Application that Sent the Position Request */
  uint8_t applicationId_valid;  /**< Must be set to true if applicationId is being passed */
  qmiLocApplicationIdStructT_v02 applicationId;
  /**<   \vspace{0.06in} \n Application provider, name, and version.*/

  /* Optional */
  /*  Configuration for Altitude Assumed Info in GNSS SV Info Event */
  uint8_t configAltitudeAssumed_valid;  /**< Must be set to true if configAltitudeAssumed is being passed */
  qmiLocConfigIncludeAltitudeAssumedInGnssSvInfoEnumT_v02 configAltitudeAssumed;
  /**<   Specifies the configuration to include Altitude Assumed information in the GNSS SV Info Event.
 When enabled, an additional GNSS SV Info event indication is sent to the control
 point that also includes the Altitude Sssumed information.
 If not specified, the configuration defaults to ENABLED.
 Values: \n
      - eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_ENABLED (1) --  Enable altitude assumed information in GNSS SV Info Event.\n
      - eQMI_LOC_ALTITUDE_ASSUMED_IN_GNSS_SV_INFO_DISABLED (2) --  Disable altitude assumed information in GNSS SV Info Event.
 */

  /* Optional */
  /*  Minimum Interval Between Intermediate Position Reports */
  uint8_t minIntermediatePositionReportInterval_valid;  /**< Must be set to true if minIntermediatePositionReportInterval is being passed */
  uint32_t minIntermediatePositionReportInterval;
  /**<   Minimum time interval for intermediate position reports, specified by the control point,
       that, between the position reports elapsed time, must be longer than the interval time.
       If this optional value is not set or set to the default value (0), the intermediate position
       is reported when it is ready. \n
       - Units -- Milliseconds \n
       - Default: 0 ms
  */

  /* Optional */
  /*  Maximum Wait Time to Get a Position Report */
  uint8_t positionReportTimeout_valid;  /**< Must be set to true if positionReportTimeout is being passed */
  uint32_t positionReportTimeout;
  /**<   Maximum time to work on each fix, specified by the control point.
       The GPS engine returns QMI_ERR_INTERNAL if a position cannot be obtained
       within the positionReportTimeout value. \n
       - Units -- Milliseconds \n
       - Default: 255*1000 ms \n
       - Range: 1000 - 255*1000 ms
  */

  /* Optional */
  /*  Share Position Report with Other Clients */
  uint8_t sharePosition_valid;  /**< Must be set to true if sharePosition is being passed */
  uint8_t sharePosition;
  /**<   Share the position report with the other QMI_LOC clients. \n
       - 0x00 (FALSE) -- Do not share the position report \n
       - 0x01 (TRUE) -- Share the position report
  */

  /* Optional */
  /*  GNSS Power Mode */
  uint8_t powerMode_valid;  /**< Must be set to true if powerMode is being passed */
  qmiLocPowerModeStructT_v02 powerMode;
  /**<   The power mode requested by the client.
  */
}qmiLocGetFixCriteriaIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCNIUSERRESPENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT_V02 = 1, /**<  User accepted the Notify/Verify request \n  */
  eQMI_LOC_NI_LCS_NOTIFY_VERIFY_DENY_V02 = 2, /**<  User denied the Notify/Verify request \n */
  eQMI_LOC_NI_LCS_NOTIFY_VERIFY_NORESP_V02 = 3, /**<  User did not respond to the Notify/Verify request  */
  QMILOCNIUSERRESPENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocNiUserRespEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends the NI user response back to the engine; success or
                    failure is reported in a separate indication. */
typedef struct {

  /* Mandatory */
  /*  User Response */
  qmiLocNiUserRespEnumT_v02 userResp;
  /**<   User accepted or denied.
 Values: \n
      - eQMI_LOC_NI_LCS_NOTIFY_VERIFY_ACCEPT (1) --  User accepted the Notify/Verify request \n
      - eQMI_LOC_NI_LCS_NOTIFY_VERIFY_DENY (2) --  User denied the Notify/Verify request \n
      - eQMI_LOC_NI_LCS_NOTIFY_VERIFY_NORESP (3) --  User did not respond to the Notify/Verify request
 */

  /* Mandatory */
  /*  Notification Type */
  qmiLocNiNotifyVerifyEnumT_v02 notificationType;
  /**<   Type of notification/verification performed.
 Values: \n
      - eQMI_LOC_NI_USER_NO_NOTIFY_NO_VERIFY (1) --  No notification and no verification required \n
      - eQMI_LOC_NI_USER_NOTIFY_ONLY (2) --  Notify only; no verification required \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_ALLOW_NO_RESP (3) --  Notify and verify, but no response required. \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_NOT_ALLOW_NO_RESP (4) --  Notify and verify, and require a response \n
      - eQMI_LOC_NI_USER_NOTIFY_VERIFY_PRIVACY_OVERRIDE (5) --  Notify and verify; privacy override
 */

  /* Optional */
  /*  Network Initiated Vx Request */
  uint8_t NiVxPayload_valid;  /**< Must be set to true if NiVxPayload is being passed */
  qmiLocNiVxNotifyVerifyStructT_v02 NiVxPayload;
  /**<   \vspace{0.06in} \n Optional NI VX request payload. */

  /* Optional */
  /*  Network Initiated SUPL Request */
  uint8_t NiSuplPayload_valid;  /**< Must be set to true if NiSuplPayload is being passed */
  qmiLocNiSuplNotifyVerifyStructT_v02 NiSuplPayload;
  /**<   \vspace{0.06in} \n Optional NI SUPL request payload. */

  /* Optional */
  /*  Network Initiated UMTS Control Plane Request */
  uint8_t NiUmtsCpPayload_valid;  /**< Must be set to true if NiUmtsCpPayload is being passed */
  qmiLocNiUmtsCpNotifyVerifyStructT_v02 NiUmtsCpPayload;
  /**<   \vspace{0.06in} \n Optional NI UMTS-CP request payload. */

  /* Optional */
  /*  Network Initiated Service Interaction Request */
  uint8_t NiVxServiceInteractionPayload_valid;  /**< Must be set to true if NiVxServiceInteractionPayload is being passed */
  qmiLocNiVxServiceInteractionStructT_v02 NiVxServiceInteractionPayload;
  /**<   \vspace{0.06in} \n Optional NI service interaction payload. */

  /* Optional */
  /*  Network Initiated SUPL Version 2 Extension */
  uint8_t NiSuplVer2ExtPayload_valid;  /**< Must be set to true if NiSuplVer2ExtPayload is being passed */
  qmiLocNiSuplVer2ExtStructT_v02 NiSuplVer2ExtPayload;
  /**<   \vspace{0.06in} \n Optional SUPL Version 2 Extension payload. */

  /* Optional */
  /*  SUPL Emergency Notification */
  uint8_t suplEmergencyNotification_valid;  /**< Must be set to true if suplEmergencyNotification is being passed */
  qmiLocEmergencyNotificationStructT_v02 suplEmergencyNotification;
  /**<    \vspace{0.06in} \n SUPL emergency notification payload. Emergency notification
        can be provided even without an ESLP address */
}qmiLocNiUserRespReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the NI user response back to the engine; success or
                    failure is reported in a separate indication. */
typedef struct {

  /* Mandatory */
  /*  NI User Response Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the NI User Response request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocNiUserRespIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPREDICTEDORBITSDATAFORMATENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_PREDICTED_ORBITS_XTRA_V02 = 0, /**<  Default is XTRA format.  */
  QMILOCPREDICTEDORBITSDATAFORMATENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPredictedOrbitsDataFormatEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects predicted orbits data. (Deprecated) */
typedef struct {

  /* Mandatory */
  /*  Total Size */
  uint32_t totalSize;
  /**<   Total size of the predicted orbits data to inject. \n
        - Units -- Bytes */

  /* Mandatory */
  /*  Total Parts */
  uint16_t totalParts;
  /**<   Total number of parts to divide the predicted orbits data into. */

  /* Mandatory */
  /*  Part Number */
  uint16_t partNum;
  /**<   Number of the current predicted orbits data part; starts at 1. */

  /* Mandatory */
  /*  Data */
  uint32_t partData_len;  /**< Must be set to # of elements in partData */
  char partData[QMI_LOC_MAX_PREDICTED_ORBITS_PART_LEN_V02];
  /**<   Predicted orbits data. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 1024
    */

  /* Optional */
  /*  Format Type */
  uint8_t formatType_valid;  /**< Must be set to true if formatType is being passed */
  qmiLocPredictedOrbitsDataFormatEnumT_v02 formatType;
  /**<   Predicted orbits data format. \n
 Values: \n
      - eQMI_LOC_PREDICTED_ORBITS_XTRA (0) --  Default is XTRA format.
 */
}qmiLocInjectPredictedOrbitsDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects predicted orbits data. (Deprecated) */
typedef struct {

  /* Mandatory */
  /*  Data Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Data Injection request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Part Number */
  uint8_t partNum_valid;  /**< Must be set to true if partNum is being passed */
  uint16_t partNum;
  /**<   Number of the predicted orbits data part for which this indication
      is sent; starts at 1. */
}qmiLocInjectPredictedOrbitsDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the predicted orbits data source. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetPredictedOrbitsDataSourceReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the predicted orbits data source. */
typedef struct {

  /* Mandatory */
  /*  Predicted Orbits Data Source Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the query request for a predicted orbits data source.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Allowed Sizes */
  uint8_t allowedSizes_valid;  /**< Must be set to true if allowedSizes is being passed */
  qmiLocPredictedOrbitsAllowedSizesStructT_v02 allowedSizes;
  /**<   \n Maximum part and file size to inject in the engine. */

  /* Optional */
  /*  Server List */
  uint8_t serverList_valid;  /**< Must be set to true if serverList is being passed */
  qmiLocPredictedOrbitsServerListStructT_v02 serverList;
  /**<   \n List of servers that the client can use to download
       predicted orbits data. */
}qmiLocGetPredictedOrbitsDataSourceIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the predicted orbits data validity. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetPredictedOrbitsDataValidityReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint64_t startTimeInUTC;
  /**<   Predicted orbits data is valid starting from this time. \n
       - Units -- Seconds (since Jan. 1, 1970)
        */

  uint16_t durationHours;
  /**<   Duration from the start time for which the data is valid.\n
       - Units -- Hours
        */
}qmiLocPredictedOrbitsDataValidityStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the predicted orbits data validity. */
typedef struct {

  /* Mandatory */
  /*  Predicted Orbits Data Validity Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the query request for predicted orbits data validity.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Validity Info */
  uint8_t validityInfo_valid;  /**< Must be set to true if validityInfo is being passed */
  qmiLocPredictedOrbitsDataValidityStructT_v02 validityInfo;
}qmiLocGetPredictedOrbitsDataValidityIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCOARSETIMEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_COARSE_TIME_UNKNOWN_V02 = 0, /**<  Origin unknown, default setting, cross check  \n */
  eQMI_LOC_COARSE_TIME_AP_V02 = 1, /**<  AP-based time injection, origin unknown \n */
  eQMI_LOC_COARSE_TIME_NTP_XTRA_V02 = 2, /**<  NTP-based injection  \n */
  eQMI_LOC_COARSE_TIME_NTS_XTRA_V02 = 3, /**<  Network time security   */
  QMILOCCOARSETIMEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocCoarseTimeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects UTC time in the location engine. */
typedef struct {

  /* Mandatory */
  /*  UTC Time */
  uint64_t timeUtc;
  /**<   UTC time since Jan. 1, 1970.\n
       - Units: Milliseconds */

  /* Mandatory */
  /*  Time Uncertainty */
  uint32_t timeUnc;
  /**<   - Units: Milliseconds */

  /* Optional */
  /*  Time Source */
  uint8_t timeSrc_valid;  /**< Must be set to true if timeSrc is being passed */
  qmiLocCoarseTimeEnumT_v02 timeSrc;
  /**<   Specifies the source of the coarse time.
 Values: \n
      - eQMI_LOC_COARSE_TIME_UNKNOWN (0) --  Origin unknown, default setting, cross check  \n
      - eQMI_LOC_COARSE_TIME_AP (1) --  AP-based time injection, origin unknown \n
      - eQMI_LOC_COARSE_TIME_NTP_XTRA (2) --  NTP-based injection  \n
      - eQMI_LOC_COARSE_TIME_NTS_XTRA (3) --  Network time security
 */
}qmiLocInjectUtcTimeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects UTC time in the location engine. */
typedef struct {

  /* Mandatory */
  /*  UTC Time Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the UTC Time Injection request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectUtcTimeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCALTSRCENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ALT_SRC_UNKNOWN_V02 = 0, /**<  Source is unknown \n */
  eQMI_LOC_ALT_SRC_GPS_V02 = 1, /**<  GPS is the source \n  */
  eQMI_LOC_ALT_SRC_CELL_ID_V02 = 2, /**<  Cell ID provided the source \n */
  eQMI_LOC_ALT_SRC_ENHANCED_CELL_ID_V02 = 3, /**<  Source is enhanced cell ID \n  */
  eQMI_LOC_ALT_SRC_WIFI_V02 = 4, /**<  Wi-Fi is the source \n  */
  eQMI_LOC_ALT_SRC_TERRESTRIAL_V02 = 5, /**<  Terrestrial source \n */
  eQMI_LOC_ALT_SRC_TERRESTRIAL_HYBRID_V02 = 6, /**<  Hybrid terrestrial source \n */
  eQMI_LOC_ALT_SRC_ALTITUDE_DATABASE_V02 = 7, /**<  Altitude database is the source \n */
  eQMI_LOC_ALT_SRC_BAROMETRIC_ALTIMETER_V02 = 8, /**<  Barometric altimeter is the source \n */
  eQMI_LOC_ALT_SRC_OTHER_V02 = 9, /**<  Other sources  */
  QMILOCALTSRCENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocAltSrcEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCALTSRCLINKAGEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ALT_SRC_LINKAGE_NOT_SPECIFIED_V02 = 0, /**<  Not specified \n */
  eQMI_LOC_ALT_SRC_LINKAGE_FULLY_INTERDEPENDENT_V02 = 1, /**<  Fully interdependent \n */
  eQMI_LOC_ALT_SRC_LINKAGE_DEPENDS_ON_LAT_LONG_V02 = 2, /**<  Depends on latitude and longitude \n  */
  eQMI_LOC_ALT_SRC_LINKAGE_FULLY_INDEPENDENT_V02 = 3, /**<  Fully independent  */
  QMILOCALTSRCLINKAGEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocAltSrcLinkageEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCALTSRCUNCERTAINTYCOVERAGEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ALT_UNCERTAINTY_NOT_SPECIFIED_V02 = 0, /**<  Not specified \n */
  eQMI_LOC_ALT_UNCERTAINTY_POINT_V02 = 1, /**<  Altitude uncertainty is valid at the injected horizontal
       position coordinates only \n */
  eQMI_LOC_ALT_UNCERTAINTY_FULL_V02 = 2, /**<  Altitude uncertainty applies to the position of the device
       regardless of horizontal position (within the horizontal
       uncertainty region, if provided)  */
  QMILOCALTSRCUNCERTAINTYCOVERAGEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocAltSrcUncertaintyCoverageEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocAltSrcEnumT_v02 source;
  /**<   Specifies the source of the altitude.
 Values: \n
      - eQMI_LOC_ALT_SRC_UNKNOWN (0) --  Source is unknown \n
      - eQMI_LOC_ALT_SRC_GPS (1) --  GPS is the source \n
      - eQMI_LOC_ALT_SRC_CELL_ID (2) --  Cell ID provided the source \n
      - eQMI_LOC_ALT_SRC_ENHANCED_CELL_ID (3) --  Source is enhanced cell ID \n
      - eQMI_LOC_ALT_SRC_WIFI (4) --  Wi-Fi is the source \n
      - eQMI_LOC_ALT_SRC_TERRESTRIAL (5) --  Terrestrial source \n
      - eQMI_LOC_ALT_SRC_TERRESTRIAL_HYBRID (6) --  Hybrid terrestrial source \n
      - eQMI_LOC_ALT_SRC_ALTITUDE_DATABASE (7) --  Altitude database is the source \n
      - eQMI_LOC_ALT_SRC_BAROMETRIC_ALTIMETER (8) --  Barometric altimeter is the source \n
      - eQMI_LOC_ALT_SRC_OTHER (9) --  Other sources
 */

  qmiLocAltSrcLinkageEnumT_v02 linkage;
  /**<   Specifies the dependency between the horizontal and
 altitude position components.
 Values: \n
      - eQMI_LOC_ALT_SRC_LINKAGE_NOT_SPECIFIED (0) --  Not specified \n
      - eQMI_LOC_ALT_SRC_LINKAGE_FULLY_INTERDEPENDENT (1) --  Fully interdependent \n
      - eQMI_LOC_ALT_SRC_LINKAGE_DEPENDS_ON_LAT_LONG (2) --  Depends on latitude and longitude \n
      - eQMI_LOC_ALT_SRC_LINKAGE_FULLY_INDEPENDENT (3) --  Fully independent
 */

  qmiLocAltSrcUncertaintyCoverageEnumT_v02 coverage;
  /**<   Specifies the region of uncertainty.
 Values: \n
      - eQMI_LOC_ALT_UNCERTAINTY_NOT_SPECIFIED (0) --  Not specified \n
      - eQMI_LOC_ALT_UNCERTAINTY_POINT (1) --  Altitude uncertainty is valid at the injected horizontal
       position coordinates only \n
      - eQMI_LOC_ALT_UNCERTAINTY_FULL (2) --  Altitude uncertainty applies to the position of the device
       regardless of horizontal position (within the horizontal
       uncertainty region, if provided)
 */
}qmiLocAltitudeSrcInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPOSITIONSRCENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POSITION_SRC_GNSS_V02 = 0, /**<  Position source is GNSS \n  */
  eQMI_LOC_POSITION_SRC_CELLID_V02 = 1, /**<  Position source is Cell ID \n  */
  eQMI_LOC_POSITION_SRC_ENH_CELLID_V02 = 2, /**<  Position source is Enhanced Cell ID \n */
  eQMI_LOC_POSITION_SRC_WIFI_V02 = 3, /**<  Position source is Wi-Fi \n */
  eQMI_LOC_POSITION_SRC_TERRESTRIAL_V02 = 4, /**<  Position source is Terrestrial \n */
  eQMI_LOC_POSITION_SRC_GNSS_TERRESTRIAL_HYBRID_V02 = 5, /**<  Position source is GNSS Terrestrial Hybrid \n  */
  eQMI_LOC_POSITION_SRC_OTHER_V02 = 6, /**<  Other sources \n  */
  eQMI_LOC_POSITION_SRC_DRE_V02 = 7, /**<  Position source is the dead reckoning engine  */
  QMILOCPOSITIONSRCENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPositionSrcEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPOSITIONSRCPROVIDERENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POSITION_SRC_PROVIDER_EXTERNAL_V02 = 0, /**<  Position is sourced from an external module \n */
  eQMI_LOC_POSITION_SRC_PROVIDER_INTERNAL_V02 = 1, /**<  Position is sourced from an internal module  */
  QMILOCPOSITIONSRCPROVIDERENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPositionSrcProviderEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects a position to the location engine. */
typedef struct {

  /* Optional */
  /*  Latitude */
  uint8_t latitude_valid;  /**< Must be set to true if latitude is being passed */
  double latitude;
  /**<   Latitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0    \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude

    */

  /* Optional */
  /*  Longitude */
  uint8_t longitude_valid;  /**< Must be set to true if longitude is being passed */
  double longitude;
  /**<   Longitude (specified in WGS84 datum).\n
       - Type -- Floating point\n
       - Units -- Degrees\n
       - Range -- -180.0 to 180.0  \n
        - Positive values indicate eastern longitude\n
        - Negative values indicate western longitude
   */

  /* Optional */
  /*  Circular Horizontal Uncertainty */
  uint8_t horUncCircular_valid;  /**< Must be set to true if horUncCircular is being passed */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
        - Units -- Meters */

  /* Optional */
  /*  Horizontal Confidence */
  uint8_t horConfidence_valid;  /**< Must be set to true if horConfidence is being passed */
  uint8_t horConfidence;
  /**<   Horizontal confidence, as defined by ETSI TS 101 109 (3GPP \hyperref[TS 03.32]{TS 03.32}).\n
        - Units -- Percent (1 to 99)\n
        - 0, 101 to 255 -- invalid value\n
        - If 100 is received, reinterpret to 99 \n
        This field must be specified together with horizontal uncertainty.
        If not specified when horUncCircular is set, the default value is 50. */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horReliability_valid;  /**< Must be set to true if horReliability is being passed */
  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Altitude With Respect to Ellipsoid */
  uint8_t altitudeWrtEllipsoid_valid;  /**< Must be set to true if altitudeWrtEllipsoid is being passed */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid. \n
        - Units -- Meters  \n
         - Positive = height
         - Negative = depth
     */

  /* Optional */
  /*  Altitude With Respect to Sea Level */
  uint8_t altitudeWrtMeanSeaLevel_valid;  /**< Must be set to true if altitudeWrtMeanSeaLevel is being passed */
  float altitudeWrtMeanSeaLevel;
  /**<   Altitude with respect to mean sea level.\n
       - Units -- Meters */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   Vertical uncertainty; mandatory when either altitudeWrtEllipsoid
        or altitudeWrtMeanSeaLevel is specified.
        - Units -- Meters */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical confidence, as defined by  ETSI TS 101 109 (3GPP \hyperref[TS 03.32]{TS 03.32}).\n
        - Units -- Percent (0-99)\n
        - 0 -- invalid value \n
        - 100 to 256 -- not used \n
        - If 100 is received, reinterpret to 99 \n
        This field must be specified together with the vertical uncertainty.
        If not specified, the default value is 50. */

  /* Optional */
  /*  Vertical Reliability */
  uint8_t vertReliability_valid;  /**< Must be set to true if vertReliability is being passed */
  qmiLocReliabilityEnumT_v02 vertReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Altitude Source Info */
  uint8_t altSourceInfo_valid;  /**< Must be set to true if altSourceInfo is being passed */
  qmiLocAltitudeSrcInfoStructT_v02 altSourceInfo;
  /**<   \vspace{0.06in} \n Specifies information regarding the altitude source. */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   UTC timestamp. \n
        - Units -- Milliseconds (since Jan. 1, 1970) */

  /* Optional */
  /*  Position Age */
  uint8_t timestampAge_valid;  /**< Must be set to true if timestampAge is being passed */
  int32_t timestampAge;
  /**<   Position age, which is an estimate of how long ago this fix was made. \n
        - Units -- Milliseconds */

  /* Optional */
  /*  Position Source */
  uint8_t positionSrc_valid;  /**< Must be set to true if positionSrc is being passed */
  qmiLocPositionSrcEnumT_v02 positionSrc;
  /**<   Source from which this position was obtained.
 Values: \n
      - eQMI_LOC_POSITION_SRC_GNSS (0) --  Position source is GNSS \n
      - eQMI_LOC_POSITION_SRC_CELLID (1) --  Position source is Cell ID \n
      - eQMI_LOC_POSITION_SRC_ENH_CELLID (2) --  Position source is Enhanced Cell ID \n
      - eQMI_LOC_POSITION_SRC_WIFI (3) --  Position source is Wi-Fi \n
      - eQMI_LOC_POSITION_SRC_TERRESTRIAL (4) --  Position source is Terrestrial \n
      - eQMI_LOC_POSITION_SRC_GNSS_TERRESTRIAL_HYBRID (5) --  Position source is GNSS Terrestrial Hybrid \n
      - eQMI_LOC_POSITION_SRC_OTHER (6) --  Other sources \n
      - eQMI_LOC_POSITION_SRC_DRE (7) --  Position source is the dead reckoning engine  \n
 If altitude is specified and the altitude source is not specified, the engine
 assumes that the altitude was obtained using the specified position source. \n
 If both altitude and altitude source are specified, the engine assumes
 that only latitude and longitude were obtained using the specified position
 source.
 */

  /* Optional */
  /*  Raw Circular Horizontal Uncertainty */
  uint8_t rawHorUncCircular_valid;  /**< Must be set to true if rawHorUncCircular is being passed */
  float rawHorUncCircular;
  /**<   Horizontal position uncertainty (circular) without any optimization.\n
        - Units -- Meters */

  /* Optional */
  /*  Raw Horizontal Confidence */
  uint8_t rawHorConfidence_valid;  /**< Must be set to true if rawHorConfidence is being passed */
  uint8_t rawHorConfidence;
  /**<   Horizontal confidence associated with raw horizontal uncertainty,
        as defined by ETSI TS 101 109 (3GPP \hyperref[TS 03.32]{TS 03.32}).\n
        - Units -- Percent (1 to 99) \n
        - 0, 101 to 255 -- invalid value \n
        - If 100 is received, reinterpret to 99 \n
        This field must be specified together with raw horizontal uncertainty.
        If not specified when rawHorUncCircular is set, the default value is 50. */

  /* Optional */
  /*  Free CPI or On-Demand CPI */
  uint8_t onDemandCpi_valid;  /**< Must be set to true if onDemandCpi is being passed */
  uint8_t onDemandCpi;
  /**<   Indicates whether the modem has requested this position injection.
        Values: \n
        - 0x00 (FALSE) -- The position injection was not requested by the modem (free CPI) \n
        - 0x01 (TRUE) -- The position injection was requested by the modem (on-demand CPI) */

  /* Optional */
  /*  Position Source Provider  */
  uint8_t positionSrcProvider_valid;  /**< Must be set to true if positionSrcProvider is being passed */
  qmiLocPositionSrcProviderEnumT_v02 positionSrcProvider;
  /**<   The source provider from which this position was obtained.
 Values: \n
      - eQMI_LOC_POSITION_SRC_PROVIDER_EXTERNAL (0) --  Position is sourced from an external module \n
      - eQMI_LOC_POSITION_SRC_PROVIDER_INTERNAL (1) --  Position is sourced from an internal module
 */

  /* Optional */
  /*  GPS Time */
  uint8_t gpsTime_valid;  /**< Must be set to true if gpsTime is being passed */
  qmiLocGPSTimeStructT_v02 gpsTime;
  /**<   \n The number of weeks since Jan. 6, 1980, and
       milliseconds into the current week. This is the GPS time stamp
       for this injected position. */

  /* Optional */
  /*  Time Uncertainty */
  uint8_t timeUnc_valid;  /**< Must be set to true if timeUnc is being passed */
  float timeUnc;
  /**<   Time uncertainty associated with this injected position. \n
       - Units -- Milliseconds */

  /* Optional */
  /*  Velocity ENU (East, North, Up) */
  uint8_t velEnu_valid;  /**< Must be set to true if velEnu is being passed */
  float velEnu[QMI_LOC_ENU_ARRAY_LENGTH_V02];
  /**<   East, north, up velocity.\n
       - Units -- Meters per second */

  /* Optional */
  /*  Velocity Uncertainty ENU */
  uint8_t velUncEnu_valid;  /**< Must be set to true if velUncEnu is being passed */
  float velUncEnu[QMI_LOC_ENU_ARRAY_LENGTH_V02];
  /**<   East, North, up velocity uncertainty.\n
       - Units -- Meters per second */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
       used for calculating this position report. The following
       information is associated with each SV ID range: \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96 \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414
      */

  /* Optional */
  /*  Number of SVs Used to Calculate the Fix */
  uint8_t numSvInFix_valid;  /**< Must be set to true if numSvInFix is being passed */
  uint8_t numSvInFix;
  /**<   Number of SVs used to calculate the fix.
  */
}qmiLocInjectPositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects a position to the location engine. */
typedef struct {

  /* Mandatory */
  /*  UTC Position Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the UTC Position Injection request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectPositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCLOCKENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_LOCK_NONE_V02 = 1, /**<  Do not lock any position sessions \n */
  eQMI_LOC_LOCK_MI_V02 = 2, /**<  Lock application framework/AFW position sessions\n  */
  eQMI_LOC_LOCK_MT_V02 = 3, /**<  Lock non-AFW/NFW position sessions\n  */
  eQMI_LOC_LOCK_ALL_V02 = 4, /**<  Lock all position sessions  */
  QMILOCLOCKENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocLockEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCLOCKSUBINFOENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_LOCK_DV_SUB_V02 = 1, /**<  Lock Dedicated Voice subscription (DV sub) \n */
  eQMI_LOC_LOCK_DD_SUB_V02 = 2, /**<  Lock Dedicated Data subscription (DD sub) \n */
  eQMI_LOC_LOCK_ALL_SUB_V02 = 3, /**<  Lock all subscriptions     */
  QMILOCLOCKSUBINFOENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocLockSubInfoEnumT_v02;
/**
    @}
  */

typedef uint64_t qmiLocLockClientMaskT_v02;
#define QMI_LOC_LOCK_CLIENT_MASK_AFW_V02 ((qmiLocLockClientMaskT_v02)0x00000001ull) /**<  Lock AFW client \n */
#define QMI_LOC_LOCK_CLIENT_MASK_NFW_V02 ((qmiLocLockClientMaskT_v02)0x00000002ull) /**<  Lock NFW client \n */
#define QMI_LOC_LOCK_CLIENT_MASK_PRIVILEGED_V02 ((qmiLocLockClientMaskT_v02)0x00000004ull) /**<  Lock privileged client  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the location engine lock. */
typedef struct {

  /* Mandatory */
  /*  Lock Type */
  qmiLocLockEnumT_v02 lockType;
  /**<   Type of lock.
 Values: \n
      - eQMI_LOC_LOCK_NONE (1) --  Do not lock any position sessions \n
      - eQMI_LOC_LOCK_MI (2) --  Lock application framework/AFW position sessions\n
      - eQMI_LOC_LOCK_MT (3) --  Lock non-AFW/NFW position sessions\n
      - eQMI_LOC_LOCK_ALL (4) --  Lock all position sessions
 */

  /* Optional */
  /*  Subscription Type */
  uint8_t subType_valid;  /**< Must be set to true if subType is being passed */
  qmiLocLockSubInfoEnumT_v02 subType;
  /**<   Subscription to which Lock Type must be applied.
 If not specified, the default value is eQMI_LOC_LOCK_DD_SUB.
 Values: \n
      - eQMI_LOC_LOCK_DV_SUB (1) --  Lock Dedicated Voice subscription (DV sub) \n
      - eQMI_LOC_LOCK_DD_SUB (2) --  Lock Dedicated Data subscription (DD sub) \n
      - eQMI_LOC_LOCK_ALL_SUB (3) --  Lock all subscriptions
 */

  /* Optional */
  /*  Lock Client */
  uint8_t lockClient_valid;  /**< Must be set to true if lockClient is being passed */
  qmiLocLockClientMaskT_v02 lockClient;
  /**<   If specified by the control point, the client(s) are
 blocked to request position.
 Note: lockClient overwrites lockType
 Values: \n
      - QMI_LOC_LOCK_CLIENT_MASK_AFW (0x00000001) --  Lock AFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_NFW (0x00000002) --  Lock NFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_PRIVILEGED (0x00000004) --  Lock privileged client
 */
}qmiLocSetEngineLockReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the location engine lock. */
typedef struct {

  /* Mandatory */
  /*  Set Engine Lock Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Engine Lock request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetEngineLockIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the location engine lock. */
typedef struct {

  /* Optional */
  /*  Subscription Type */
  uint8_t subType_valid;  /**< Must be set to true if subType is being passed */
  qmiLocLockSubInfoEnumT_v02 subType;
  /**<   Subscription associated with the requested engine lock state.
 Only a subset of the enum is valid -- eQMI_LOC_LOCK_ALL_SUB is invalid.
 If not specified, the default value is eQMI_LOC_LOCK_DD_SUB.
 Values: \n
      - eQMI_LOC_LOCK_DV_SUB (1) --  Lock Dedicated Voice subscription (DV sub) \n
      - eQMI_LOC_LOCK_DD_SUB (2) --  Lock Dedicated Data subscription (DD sub) \n
      - eQMI_LOC_LOCK_ALL_SUB (3) --  Lock all subscriptions
 */
}qmiLocGetEngineLockReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the location engine lock. */
typedef struct {

  /* Mandatory */
  /*  Get Engine Lock Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Engine Lock request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Lock Type */
  uint8_t lockType_valid;  /**< Must be set to true if lockType is being passed */
  qmiLocLockEnumT_v02 lockType;
  /**<   Type of lock.
 Values: \n
      - eQMI_LOC_LOCK_NONE (1) --  Do not lock any position sessions \n
      - eQMI_LOC_LOCK_MI (2) --  Lock application framework/AFW position sessions\n
      - eQMI_LOC_LOCK_MT (3) --  Lock non-AFW/NFW position sessions\n
      - eQMI_LOC_LOCK_ALL (4) --  Lock all position sessions
 */

  /* Optional */
  /*  Subscription Type */
  uint8_t subType_valid;  /**< Must be set to true if subType is being passed */
  qmiLocLockSubInfoEnumT_v02 subType;
  /**<   Subscription to which the above Lock Type is associated with.
 Values: \n
      - eQMI_LOC_LOCK_DV_SUB (1) --  Lock Dedicated Voice subscription (DV sub) \n
      - eQMI_LOC_LOCK_DD_SUB (2) --  Lock Dedicated Data subscription (DD sub) \n
      - eQMI_LOC_LOCK_ALL_SUB (3) --  Lock all subscriptions
 */

  /* Optional */
  /*  Lock Client */
  uint8_t lockClient_valid;  /**< Must be set to true if lockClient is being passed */
  qmiLocLockClientMaskT_v02 lockClient;
  /**<   The client(s) who have been locked to request position.
 Values: \n
      - QMI_LOC_LOCK_CLIENT_MASK_AFW (0x00000001) --  Lock AFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_NFW (0x00000002) --  Lock NFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_PRIVILEGED (0x00000004) --  Lock privileged client
 */
}qmiLocGetEngineLockIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the SBAS configuration. */
typedef struct {

  /* Mandatory */
  /*  SBAS Config */
  uint8_t sbasConfig;
  /**<   Indicates whether SBAS configuration is enabled.\n
       - 0x01 (TRUE) -- Enabled \n
       - 0x00 (FALSE) -- Disabled
    */

  /* Optional */
  /*  QZSS-L1S Config */
  uint8_t qzssL1sConfig_valid;  /**< Must be set to true if qzssL1sConfig is being passed */
  uint8_t qzssL1sConfig;
  /**<   Indicates whether QZSS-L1S configuration is enabled.\n
       -  0x01 (TRUE) -- Enabled \n
       -  0x00 (FALSE) -- Disabled
       */
}qmiLocSetSbasConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the SBAS configuration. */
typedef struct {

  /* Mandatory */
  /*  Set SBAS Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set SBAS Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetSbasConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the SBAS configuration from the location engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetSbasConfigReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the SBAS configuration from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get SBAS Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get SBAS Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  SBAS Config */
  uint8_t sbasConfig_valid;  /**< Must be set to true if sbasConfig is being passed */
  uint8_t sbasConfig;
  /**<   Indicates whether SBAS configuration is enabled.\n
       - 0x01 (TRUE) -- SBAS configuration is enabled \n
       - 0x00 (FALSE) -- SBAS configuration is disabled
    */
}qmiLocGetSbasConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocNmeaSentenceMaskT_v02;
#define QMI_LOC_NMEA_MASK_GGA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000001) /**<  Enable GGA type \n */
#define QMI_LOC_NMEA_MASK_RMC_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000002) /**<  Enable RMC type \n  */
#define QMI_LOC_NMEA_MASK_GSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000004) /**<  Enable GSV type \n  */
#define QMI_LOC_NMEA_MASK_GSA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000008) /**<  Enable GSA type \n  */
#define QMI_LOC_NMEA_MASK_VTG_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000010) /**<  Enable VTG type \n  */
#define QMI_LOC_NMEA_MASK_PQXFI_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000020) /**<  Enable PQXFI type \n  */
#define QMI_LOC_NMEA_MASK_PSTIS_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000040) /**<  Enable PSTIS type \n  */
#define QMI_LOC_NMEA_MASK_GLGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000080) /**<  Enable GLGSV type \n  */
#define QMI_LOC_NMEA_MASK_GNGSA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000100) /**<  Enable GNGSA type \n  */
#define QMI_LOC_NMEA_MASK_GNGNS_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000200) /**<  Enable GNGNS type \n  */
#define QMI_LOC_NMEA_MASK_GARMC_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000400) /**<  Enable GARMC type \n  */
#define QMI_LOC_NMEA_MASK_GAGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00000800) /**<  Enable GAGSV type \n  */
#define QMI_LOC_NMEA_MASK_GAGSA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00001000) /**<  Enable GAGSA type \n  */
#define QMI_LOC_NMEA_MASK_GAVTG_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00002000) /**<  Enable GAVTG type \n  */
#define QMI_LOC_NMEA_MASK_GAGGA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00004000) /**<  Enable GAGGA type \n  */
#define QMI_LOC_NMEA_MASK_PQGSA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00008000) /**<  Deprecated \n  */
#define QMI_LOC_NMEA_MASK_PQGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00010000) /**<  Deprecated \n  */
#define QMI_LOC_NMEA_MASK_DEBUG_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00020000) /**<  Enable DEBUG NMEA type \n  */
#define QMI_LOC_NMEA_MASK_GPDTM_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00040000) /**<  Enable GPDTM type \n  */
#define QMI_LOC_NMEA_MASK_GNGGA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00080000) /**<  Enable GNGGA type \n  */
#define QMI_LOC_NMEA_MASK_GNRMC_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00100000) /**<  Enable GNRMC type \n  */
#define QMI_LOC_NMEA_MASK_GNVTG_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00200000) /**<  Enable GNVTG type \n  */
#define QMI_LOC_NMEA_MASK_GAGNS_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00400000) /**<  Enable GAGNS type \n  */
#define QMI_LOC_NMEA_MASK_GBGGA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x00800000) /**<  Enable GBGGA type \n  */
#define QMI_LOC_NMEA_MASK_GBGSA_V02 ((qmiLocNmeaSentenceMaskT_v02)0x01000000) /**<  Enable GBGSA type \n  */
#define QMI_LOC_NMEA_MASK_GBGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x02000000) /**<  Enable GBGSV type \n  */
#define QMI_LOC_NMEA_MASK_GBRMC_V02 ((qmiLocNmeaSentenceMaskT_v02)0x04000000) /**<  Enable GBRMC type \n  */
#define QMI_LOC_NMEA_MASK_GBVTG_V02 ((qmiLocNmeaSentenceMaskT_v02)0x08000000) /**<  Enable GBVTG type \n  */
#define QMI_LOC_NMEA_MASK_GQGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x10000000) /**<  Enable GQGSV type \n  */
#define QMI_LOC_NMEA_MASK_GIGSV_V02 ((qmiLocNmeaSentenceMaskT_v02)0x20000000) /**<  Enable GIGSV type \n  */
#define QMI_LOC_NMEA_MASK_GNDTM_V02 ((qmiLocNmeaSentenceMaskT_v02)0x40000000) /**<  Enable GNDTM type \n  */
#define QMI_LOC_NMEA_MASK_GSA_TAGBLOCK_ENABLE_V02 ((qmiLocNmeaSentenceMaskT_v02)0x80000000) /**<  Enable TAG block for GSA sentence  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the NMEA types. */
typedef struct {

  /* Mandatory */
  /*  NMEA Sentence Types */
  qmiLocNmeaSentenceMaskT_v02 nmeaSentenceType;
  /**<   Bitmasks of NMEA types to enable.\n
 Valid bitmasks: \n
      - QMI_LOC_NMEA_MASK_GGA (0x00000001) --  Enable GGA type \n
      - QMI_LOC_NMEA_MASK_RMC (0x00000002) --  Enable RMC type \n
      - QMI_LOC_NMEA_MASK_GSV (0x00000004) --  Enable GSV type \n
      - QMI_LOC_NMEA_MASK_GSA (0x00000008) --  Enable GSA type \n
      - QMI_LOC_NMEA_MASK_VTG (0x00000010) --  Enable VTG type \n
      - QMI_LOC_NMEA_MASK_PQXFI (0x00000020) --  Enable PQXFI type \n
      - QMI_LOC_NMEA_MASK_PSTIS (0x00000040) --  Enable PSTIS type \n
      - QMI_LOC_NMEA_MASK_GLGSV (0x00000080) --  Enable GLGSV type \n
      - QMI_LOC_NMEA_MASK_GNGSA (0x00000100) --  Enable GNGSA type \n
      - QMI_LOC_NMEA_MASK_GNGNS (0x00000200) --  Enable GNGNS type \n
      - QMI_LOC_NMEA_MASK_GARMC (0x00000400) --  Enable GARMC type \n
      - QMI_LOC_NMEA_MASK_GAGSV (0x00000800) --  Enable GAGSV type \n
      - QMI_LOC_NMEA_MASK_GAGSA (0x00001000) --  Enable GAGSA type \n
      - QMI_LOC_NMEA_MASK_GAVTG (0x00002000) --  Enable GAVTG type \n
      - QMI_LOC_NMEA_MASK_GAGGA (0x00004000) --  Enable GAGGA type \n
      - QMI_LOC_NMEA_MASK_PQGSA (0x00008000) --  Deprecated \n
      - QMI_LOC_NMEA_MASK_PQGSV (0x00010000) --  Deprecated \n
      - QMI_LOC_NMEA_MASK_DEBUG (0x00020000) --  Enable DEBUG NMEA type \n
      - QMI_LOC_NMEA_MASK_GPDTM (0x00040000) --  Enable GPDTM type \n
      - QMI_LOC_NMEA_MASK_GNGGA (0x00080000) --  Enable GNGGA type \n
      - QMI_LOC_NMEA_MASK_GNRMC (0x00100000) --  Enable GNRMC type \n
      - QMI_LOC_NMEA_MASK_GNVTG (0x00200000) --  Enable GNVTG type \n
      - QMI_LOC_NMEA_MASK_GAGNS (0x00400000) --  Enable GAGNS type \n
      - QMI_LOC_NMEA_MASK_GBGGA (0x00800000) --  Enable GBGGA type \n
      - QMI_LOC_NMEA_MASK_GBGSA (0x01000000) --  Enable GBGSA type \n
      - QMI_LOC_NMEA_MASK_GBGSV (0x02000000) --  Enable GBGSV type \n
      - QMI_LOC_NMEA_MASK_GBRMC (0x04000000) --  Enable GBRMC type \n
      - QMI_LOC_NMEA_MASK_GBVTG (0x08000000) --  Enable GBVTG type \n
      - QMI_LOC_NMEA_MASK_GQGSV (0x10000000) --  Enable GQGSV type \n
      - QMI_LOC_NMEA_MASK_GIGSV (0x20000000) --  Enable GIGSV type \n
      - QMI_LOC_NMEA_MASK_GNDTM (0x40000000) --  Enable GNDTM type \n
      - QMI_LOC_NMEA_MASK_GSA_TAGBLOCK_ENABLE (0x80000000) --  Enable TAG block for GSA sentence \n
 The following NMEA sentences are deprecated, if any of these bits are
 set, an error is sent: \n
 - QMI_LOC_NMEA_MASK_PQGSA \n
 - QMI_LOC_NMEA_MASK_PQGSV

 */
}qmiLocSetNmeaTypesReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the NMEA types. */
typedef struct {

  /* Mandatory */
  /*  Set NMEA Types Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of QMI_LOC_SET_NMEA_TYPES_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetNmeaTypesIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the NMEA types from the location engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetNmeaTypesReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the NMEA types from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get NMEA Types Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get NMEA Types request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  NMEA Sentence Types */
  uint8_t nmeaSentenceType_valid;  /**< Must be set to true if nmeaSentenceType is being passed */
  qmiLocNmeaSentenceMaskT_v02 nmeaSentenceType;
  /**<   NMEA types to enable. \n
 Valid bitmasks: \n
      - QMI_LOC_NMEA_MASK_GGA (0x00000001) --  Enable GGA type \n
      - QMI_LOC_NMEA_MASK_RMC (0x00000002) --  Enable RMC type \n
      - QMI_LOC_NMEA_MASK_GSV (0x00000004) --  Enable GSV type \n
      - QMI_LOC_NMEA_MASK_GSA (0x00000008) --  Enable GSA type \n
      - QMI_LOC_NMEA_MASK_VTG (0x00000010) --  Enable VTG type \n
      - QMI_LOC_NMEA_MASK_PQXFI (0x00000020) --  Enable PQXFI type \n
      - QMI_LOC_NMEA_MASK_PSTIS (0x00000040) --  Enable PSTIS type \n
      - QMI_LOC_NMEA_MASK_GLGSV (0x00000080) --  Enable GLGSV type \n
      - QMI_LOC_NMEA_MASK_GNGSA (0x00000100) --  Enable GNGSA type \n
      - QMI_LOC_NMEA_MASK_GNGNS (0x00000200) --  Enable GNGNS type \n
      - QMI_LOC_NMEA_MASK_GARMC (0x00000400) --  Enable GARMC type \n
      - QMI_LOC_NMEA_MASK_GAGSV (0x00000800) --  Enable GAGSV type \n
      - QMI_LOC_NMEA_MASK_GAGSA (0x00001000) --  Enable GAGSA type \n
      - QMI_LOC_NMEA_MASK_GAVTG (0x00002000) --  Enable GAVTG type \n
      - QMI_LOC_NMEA_MASK_GAGGA (0x00004000) --  Enable GAGGA type \n
      - QMI_LOC_NMEA_MASK_PQGSA (0x00008000) --  Deprecated \n
      - QMI_LOC_NMEA_MASK_PQGSV (0x00010000) --  Deprecated \n
      - QMI_LOC_NMEA_MASK_DEBUG (0x00020000) --  Enable DEBUG NMEA type \n
      - QMI_LOC_NMEA_MASK_GPDTM (0x00040000) --  Enable GPDTM type \n
      - QMI_LOC_NMEA_MASK_GNGGA (0x00080000) --  Enable GNGGA type \n
      - QMI_LOC_NMEA_MASK_GNRMC (0x00100000) --  Enable GNRMC type \n
      - QMI_LOC_NMEA_MASK_GNVTG (0x00200000) --  Enable GNVTG type \n
      - QMI_LOC_NMEA_MASK_GAGNS (0x00400000) --  Enable GAGNS type \n
      - QMI_LOC_NMEA_MASK_GBGGA (0x00800000) --  Enable GBGGA type \n
      - QMI_LOC_NMEA_MASK_GBGSA (0x01000000) --  Enable GBGSA type \n
      - QMI_LOC_NMEA_MASK_GBGSV (0x02000000) --  Enable GBGSV type \n
      - QMI_LOC_NMEA_MASK_GBRMC (0x04000000) --  Enable GBRMC type \n
      - QMI_LOC_NMEA_MASK_GBVTG (0x08000000) --  Enable GBVTG type \n
      - QMI_LOC_NMEA_MASK_GQGSV (0x10000000) --  Enable GQGSV type \n
      - QMI_LOC_NMEA_MASK_GIGSV (0x20000000) --  Enable GIGSV type \n
      - QMI_LOC_NMEA_MASK_GNDTM (0x40000000) --  Enable GNDTM type \n
      - QMI_LOC_NMEA_MASK_GSA_TAGBLOCK_ENABLE (0x80000000) --  Enable TAG block for GSA sentence \n
 The following NMEA sentences are deprecated, if any of these bits are
 set, an error is sent: \n
 - QMI_LOC_NMEA_MASK_PQGSA \n
 - QMI_LOC_NMEA_MASK_PQGSV
 */
}qmiLocGetNmeaTypesIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Enables/disables Low Power Mode (LPM) configuration. */
typedef struct {

  /* Mandatory */
  /*  Enable Low Power Mode */
  uint8_t lowPowerMode;
  /**<   Indicates whether to enable Low Power mode:\n
       - 0x01 (TRUE) -- Enable LPM \n
       - 0x00 (FALSE) -- Disable LPM */
}qmiLocSetLowPowerModeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Enables/disables Low Power Mode (LPM) configuration. */
typedef struct {

  /* Mandatory */
  /*  Set LPM Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_SET_LOW_POWER_MODE_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetLowPowerModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the LPM status from the location engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetLowPowerModeReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the LPM status from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get LPM Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get LPM request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Enable/Disable LPM */
  uint8_t lowPowerMode_valid;  /**< Must be set to true if lowPowerMode is being passed */
  uint8_t lowPowerMode;
  /**<   Indicates whether to enable Low Power mode:\n
       - 0x01 (TRUE) -- Enable LPM \n
       - 0x00 (FALSE) -- Disable LPM */
}qmiLocGetLowPowerModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSERVERTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SERVER_TYPE_CDMA_PDE_V02 = 1, /**<  CDMA PDE \n  */
  eQMI_LOC_SERVER_TYPE_CDMA_MPC_V02 = 2, /**<  CDMA MPC \n */
  eQMI_LOC_SERVER_TYPE_UMTS_SLP_V02 = 3, /**<  UMTS SLP \n */
  eQMI_LOC_SERVER_TYPE_CUSTOM_PDE_V02 = 4, /**<  Custom PDE \n */
  eQMI_LOC_SERVER_TYPE_CUSTOM_SLP_V02 = 5, /**<  Custom SUPL SLP  */
  QMILOCSERVERTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocServerTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Specifies the A-GPS server type and address. */
typedef struct {

  /* Mandatory */
  /*  Server Type */
  qmiLocServerTypeEnumT_v02 serverType;
  /**<   Type of server.
 Values: \n
      - eQMI_LOC_SERVER_TYPE_CDMA_PDE (1) --  CDMA PDE \n
      - eQMI_LOC_SERVER_TYPE_CDMA_MPC (2) --  CDMA MPC \n
      - eQMI_LOC_SERVER_TYPE_UMTS_SLP (3) --  UMTS SLP \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_PDE (4) --  Custom PDE \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_SLP (5) --  Custom SUPL SLP
 */

  /* Optional */
  /*  IPv4 Address */
  uint8_t ipv4Addr_valid;  /**< Must be set to true if ipv4Addr is being passed */
  qmiLocIpV4AddrStructType_v02 ipv4Addr;
  /**<   \vspace{0.06in} \n IPv4 address and port. */

  /* Optional */
  /*  IPv6 Address */
  uint8_t ipv6Addr_valid;  /**< Must be set to true if ipv6Addr is being passed */
  qmiLocIpV6AddrStructType_v02 ipv6Addr;
  /**<   \vspace{0.06in} \n IPv6 address and port. */

  /* Optional */
  /*  Uniform Resource Locator */
  uint8_t urlAddr_valid;  /**< Must be set to true if urlAddr is being passed */
  char urlAddr[QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 + 1];
  /**<   URL. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 256
   */
}qmiLocSetServerReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Specifies the A-GPS server type and address. */
typedef struct {

  /* Mandatory */
  /*  Set Server Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_SET_SERVER_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetServerIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the location server from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Server Type */
  qmiLocServerTypeEnumT_v02 serverType;
  /**<   Type of server.
 Values: \n
      - eQMI_LOC_SERVER_TYPE_CDMA_PDE (1) --  CDMA PDE \n
      - eQMI_LOC_SERVER_TYPE_CDMA_MPC (2) --  CDMA MPC \n
      - eQMI_LOC_SERVER_TYPE_UMTS_SLP (3) --  UMTS SLP \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_PDE (4) --  Custom PDE \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_SLP (5) --  Custom SUPL SLP
 */

  /* Optional */
  /*  Server Address Type */
  uint8_t serverAddrTypeMask_valid;  /**< Must be set to true if serverAddrTypeMask is being passed */
  qmiLocServerAddrTypeMaskT_v02 serverAddrTypeMask;
  /**<   Type of server address the client wants. If unspecified, the
 indication contains all the types of addresses
 it has for the specified server type.\n
 Valid bitmasks: \n
      - QMI_LOC_SERVER_ADDR_TYPE_IPV4_MASK (0x01) --  IPv4  \n
      - QMI_LOC_SERVER_ADDR_TYPE_IPV6_MASK (0x02) --  IPv6  \n
      - QMI_LOC_SERVER_ADDR_TYPE_URL_MASK (0x04) --  URL
 */
}qmiLocGetServerReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the location server from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get Server Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Server request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Server Type */
  qmiLocServerTypeEnumT_v02 serverType;
  /**<   Type of server.
 Values: \n
      - eQMI_LOC_SERVER_TYPE_CDMA_PDE (1) --  CDMA PDE \n
      - eQMI_LOC_SERVER_TYPE_CDMA_MPC (2) --  CDMA MPC \n
      - eQMI_LOC_SERVER_TYPE_UMTS_SLP (3) --  UMTS SLP \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_PDE (4) --  Custom PDE \n
      - eQMI_LOC_SERVER_TYPE_CUSTOM_SLP (5) --  Custom SUPL SLP
 */

  /* Optional */
  /*  IPv4 Address */
  uint8_t ipv4Addr_valid;  /**< Must be set to true if ipv4Addr is being passed */
  qmiLocIpV4AddrStructType_v02 ipv4Addr;
  /**<   \vspace{0.06in} \n IPv4 address and port. */

  /* Optional */
  /*  IPv6 Address */
  uint8_t ipv6Addr_valid;  /**< Must be set to true if ipv6Addr is being passed */
  qmiLocIpV6AddrStructType_v02 ipv6Addr;
  /**<   \vspace{0.06in} \n IPv6 address and port. */

  /* Optional */
  /*  Uniform Resource Locator */
  uint8_t urlAddr_valid;  /**< Must be set to true if urlAddr is being passed */
  char urlAddr[QMI_LOC_MAX_SERVER_ADDR_LENGTH_V02 + 1];
  /**<   URL. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator)-- 256
   */
}qmiLocGetServerIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocDeleteGnssDataMaskT_v02;
#define QMI_LOC_MASK_DELETE_GPS_SVDIR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000001ull) /**<  Mask to delete GPS SVDIR  */
#define QMI_LOC_MASK_DELETE_GPS_SVSTEER_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000002ull) /**<  Mask to delete GPS SVSTEER  */
#define QMI_LOC_MASK_DELETE_GPS_TIME_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000004ull) /**<  Mask to delete GPS time  */
#define QMI_LOC_MASK_DELETE_GPS_ALM_CORR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000008ull) /**<  Mask to delete almanac correlation  */
#define QMI_LOC_MASK_DELETE_GLO_SVDIR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000010ull) /**<  Mask to delete GLONASS SVDIR  */
#define QMI_LOC_MASK_DELETE_GLO_SVSTEER_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000020ull) /**<  Mask to delete GLONASS SVSTEER  */
#define QMI_LOC_MASK_DELETE_GLO_TIME_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000040ull) /**<  Mask to delete GLONASS time  */
#define QMI_LOC_MASK_DELETE_GLO_ALM_CORR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000080ull) /**<  Mask to delete GLONASS almanac correlation  */
#define QMI_LOC_MASK_DELETE_SBAS_SVDIR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000100ull) /**<  Mask to delete SBAS SVDIR  */
#define QMI_LOC_MASK_DELETE_SBAS_SVSTEER_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000200ull) /**<  Mask to delete SBAS SVSTEER  */
#define QMI_LOC_MASK_DELETE_POSITION_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000400ull) /**<  Mask to delete position estimate  */
#define QMI_LOC_MASK_DELETE_TIME_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00000800ull) /**<  Mask to delete time estimate  */
#define QMI_LOC_MASK_DELETE_IONO_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00001000ull) /**<  Mask to delete IONO  */
#define QMI_LOC_MASK_DELETE_UTC_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00002000ull) /**<  Mask to delete UTC estimate  */
#define QMI_LOC_MASK_DELETE_HEALTH_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00004000ull) /**<  Mask to delete SV health record  */
#define QMI_LOC_MASK_DELETE_SADATA_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00008000ull) /**<  Mask to delete SADATA  */
#define QMI_LOC_MASK_DELETE_RTI_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00010000ull) /**<  Mask to delete RTI  */
#define QMI_LOC_MASK_DELETE_SV_NO_EXIST_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00020000ull) /**<  Mask to delete SV_NO_EXIST  */
#define QMI_LOC_MASK_DELETE_FREQ_BIAS_EST_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00040000ull) /**<  Mask to delete frequency bias estimate  */
#define QMI_LOC_MASK_DELETE_BDS_SVDIR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00080000ull) /**<  Mask to delete BDS SVDIR  */
#define QMI_LOC_MASK_DELETE_BDS_SVSTEER_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00100000ull) /**<  Mask to delete BDS SVSTEER  */
#define QMI_LOC_MASK_DELETE_BDS_TIME_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00200000ull) /**<  Mask to delete BDS time  */
#define QMI_LOC_MASK_DELETE_BDS_ALM_CORR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00400000ull) /**<  Mask to delete BDS almanac correlation  */
#define QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GPS_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x00800000ull) /**<  Mask to delete GNSS SV blacklist GPS   */
#define QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GLO_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x01000000ull) /**<  Mask to delete GNSS SV blacklist GLONASS   */
#define QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_BDS_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x02000000ull) /**<  Mask to delete GNSS SV blacklist BDS   */
#define QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GAL_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x04000000ull) /**<  Mask to delete GNSS SV blacklist Galileo   */
#define QMI_LOC_MASK_DELETE_GAL_SVDIR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x08000000ull) /**<  Mask to delete Galileo SVDIR  */
#define QMI_LOC_MASK_DELETE_GAL_SVSTEER_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x10000000ull) /**<  Mask to delete Galileo SVSTEER  */
#define QMI_LOC_MASK_DELETE_GAL_TIME_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x20000000ull) /**<  Mask to delete Galileo time  */
#define QMI_LOC_MASK_DELETE_GAL_ALM_CORR_V02 ((qmiLocDeleteGnssDataMaskT_v02)0x40000000ull) /**<  Mask to delete Galileo almanac correlation  */
typedef uint32_t qmiLocDeleteCelldbDataMaskT_v02;
#define QMI_LOC_MASK_DELETE_CELLDB_POS_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000001) /**<  Delete cell database position  */
#define QMI_LOC_MASK_DELETE_CELLDB_LATEST_GPS_POS_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000002) /**<  Delete cell database latest GPS position  */
#define QMI_LOC_MASK_DELETE_CELLDB_OTA_POS_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000004) /**<  Delete cell database OTA position  */
#define QMI_LOC_MASK_DELETE_CELLDB_EXT_REF_POS_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000008) /**<  Delete cell database external reference position  */
#define QMI_LOC_MASK_DELETE_CELLDB_TIMETAG_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000010) /**<  Delete cell database time tag  */
#define QMI_LOC_MASK_DELETE_CELLDB_CELLID_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000020) /**<  Delete cell database cell ID  */
#define QMI_LOC_MASK_DELETE_CELLDB_CACHED_CELLID_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000040) /**<  Delete cell database cached cell ID  */
#define QMI_LOC_MASK_DELETE_CELLDB_LAST_SRV_CELL_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000080) /**<  Delete cell database last service cell  */
#define QMI_LOC_MASK_DELETE_CELLDB_CUR_SRV_CELL_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000100) /**<  Delete cell database current service cell  */
#define QMI_LOC_MASK_DELETE_CELLDB_NEIGHBOR_INFO_V02 ((qmiLocDeleteCelldbDataMaskT_v02)0x00000200) /**<  Delete cell database neighbor information  */
typedef uint32_t qmiLocDeleteClockInfoMaskT_v02;
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000001) /**<  Delete time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_FREQ_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000002) /**<  Delete frequency estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_WEEK_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000004) /**<  Delete week number   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_RTC_TIME_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000008) /**<  Delete RTC time   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_TRANSFER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000010) /**<  Delete time transfer   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GPSTIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000020) /**<  Delete GPS time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GLOTIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000040) /**<  Delete GLONASS time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GLODAY_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000080) /**<  Delete GLONASS day number   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO4YEAR_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000100) /**<  Delete GLONASS four year number   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO_RF_GRP_DELAY_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000200) /**<  Delete GLONASS RF GRP delay   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_DISABLE_TT_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000400) /**<  Delete disable TT   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_LEAPSEC_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00000800) /**<  Delete GG leap second   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_GGTB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00001000) /**<  Delete GG GGTB   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSTIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00002000) /**<  Delete a BDS time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GB_GBTB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00004000) /**<  Delete GLONASS-to-BDS time bias-related information  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_BG_BGTB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00008000) /**<  Delete BDS-to-GLONASS time bias-related information  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSWEEK_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00010000) /**<  Delete the BDS week number  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_BDS_RF_GRP_DELAY_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00020000) /**<  Delete the BDS RF GRP delay   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00040000) /**<  Delete a Galileo time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGPS_TB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00080000) /**<  Delete Galileo-to-GPS time bias-related information   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGLO_TB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00100000) /**<  Delete Galileo-to-GLO time bias-related information   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOBDS_TB_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00200000) /**<  Delete Galileo-to-BDS time bias-related information   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GALWEEK_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x00800000) /**<  Delete the Galileo week number   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_GAL_RF_GRP_DELAY_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x01000000) /**<  Delete the Galileo RF GRP delay   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TIME_EST_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x02000000) /**<  Delete a NavIC time estimate   */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_WEEK_NUMBER_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x04000000) /**<  Delete the NavIC week number  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_RF_GRP_DELAY_V02 ((qmiLocDeleteClockInfoMaskT_v02)0x08000000) /**<  Delete the NavIC RF GRP delay   */
typedef uint64_t qmiLocExtDeleteClockInfoMaskT_v02;
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GPS_TB_V02 ((qmiLocExtDeleteClockInfoMaskT_v02)0x000001ull) /**<  Delete NavIC-to-GPS time bias-related information  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GLO_TB_V02 ((qmiLocExtDeleteClockInfoMaskT_v02)0x000002ull) /**<  Delete NavIC-to-GLO time bias-related information */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_BDS_TB_V02 ((qmiLocExtDeleteClockInfoMaskT_v02)0x000004ull) /**<  Delete NavIC-to-BDS time bias-related information  */
#define QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GAL_TB_V02 ((qmiLocExtDeleteClockInfoMaskT_v02)0x000008ull) /**<  Delete NavIC-to-GAL time bias-related information */
typedef uint8_t qmiLocDeleteSvInfoMaskT_v02;
#define QMI_LOC_MASK_DELETE_EPHEMERIS_V02 ((qmiLocDeleteSvInfoMaskT_v02)0x01) /**<  Delete ephemeris for the satellite  */
#define QMI_LOC_MASK_DELETE_ALMANAC_V02 ((qmiLocDeleteSvInfoMaskT_v02)0x02) /**<  Delete almanac for the satellite  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   SV ID of the satellite to delete data from.
       Range:    \n
         - GPS --     1 to 32 \n
         - SBAS --    33 to 64 \n
         - GLONASS -- 65 to 96
        */

  qmiLocSvSystemEnumT_v02 system;
  /**<   Indicates to which constellation this SV belongs.
 Values: \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite
 */

  qmiLocDeleteSvInfoMaskT_v02 deleteSvInfoMask;
  /**<   Indicates whether to delete the ephemeris or almanac for a satellite. \n
 Values: \n
      - QMI_LOC_MASK_DELETE_EPHEMERIS (0x01) --  Delete ephemeris for the satellite
      - QMI_LOC_MASK_DELETE_ALMANAC (0x02) --  Delete almanac for the satellite
 */
}qmiLocDeleteSvInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   SV ID of the satellite from which to delete data. \n
       Range for BDS -- 201 to 263 */

  qmiLocDeleteSvInfoMaskT_v02 deleteSvInfoMask;
  /**<   Indicates whether to delete the ephemeris or almanac for a satellite. \n
 Values: \n
      - QMI_LOC_MASK_DELETE_EPHEMERIS (0x01) --  Delete ephemeris for the satellite
      - QMI_LOC_MASK_DELETE_ALMANAC (0x02) --  Delete almanac for the satellite
 */
}qmiLocDeleteBDSSvInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   SV ID of the satellite from which to delete data. \n
       Range for Galileo -- 301 to 336 */

  qmiLocDeleteSvInfoMaskT_v02 deleteSvInfoMask;
  /**<   Indicates whether to delete the ephemeris or almanac for a satellite. \n
 Values: \n
      - QMI_LOC_MASK_DELETE_EPHEMERIS (0x01) --  Delete ephemeris for the satellite
      - QMI_LOC_MASK_DELETE_ALMANAC (0x02) --  Delete almanac for the satellite
 */
}qmiLocDeleteGALSvInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Deletes the location engine
                    assistance data. */
typedef struct {

  /* Mandatory */
  /*  Delete All */
  uint8_t deleteAllFlag;
  /**<   Indicates whether to delete all assistance data.\n
       - 0x01 (TRUE)  -- Delete all assistance data; if
                        this flag is set, ignore all the other information
                        contained in the optional fields for this
                        message \n
       - 0x00 (FALSE) -- Use the optional fields in the message
                        to determine which data to delete
        */

  /* Optional */
  /*  Delete SV Information */
  uint8_t deleteSvInfoList_valid;  /**< Must be set to true if deleteSvInfoList is being passed */
  uint32_t deleteSvInfoList_len;  /**< Must be set to # of elements in deleteSvInfoList */
  qmiLocDeleteSvInfoStructT_v02 deleteSvInfoList[QMI_LOC_DELETE_MAX_SV_INFO_LENGTH_V02];
  /**<   \vspace{0.06in} \n List of satellites for which to delete the assistance data.
  */

  /* Optional */
  /*  Delete GNSS Data */
  uint8_t deleteGnssDataMask_valid;  /**< Must be set to true if deleteGnssDataMask is being passed */
  qmiLocDeleteGnssDataMaskT_v02 deleteGnssDataMask;
  /**<   Mask for the GNSS data to delete.
 Values: \n
      - QMI_LOC_MASK_DELETE_GPS_SVDIR (0x00000001) --  Mask to delete GPS SVDIR
      - QMI_LOC_MASK_DELETE_GPS_SVSTEER (0x00000002) --  Mask to delete GPS SVSTEER
      - QMI_LOC_MASK_DELETE_GPS_TIME (0x00000004) --  Mask to delete GPS time
      - QMI_LOC_MASK_DELETE_GPS_ALM_CORR (0x00000008) --  Mask to delete almanac correlation
      - QMI_LOC_MASK_DELETE_GLO_SVDIR (0x00000010) --  Mask to delete GLONASS SVDIR
      - QMI_LOC_MASK_DELETE_GLO_SVSTEER (0x00000020) --  Mask to delete GLONASS SVSTEER
      - QMI_LOC_MASK_DELETE_GLO_TIME (0x00000040) --  Mask to delete GLONASS time
      - QMI_LOC_MASK_DELETE_GLO_ALM_CORR (0x00000080) --  Mask to delete GLONASS almanac correlation
      - QMI_LOC_MASK_DELETE_SBAS_SVDIR (0x00000100) --  Mask to delete SBAS SVDIR
      - QMI_LOC_MASK_DELETE_SBAS_SVSTEER (0x00000200) --  Mask to delete SBAS SVSTEER
      - QMI_LOC_MASK_DELETE_POSITION (0x00000400) --  Mask to delete position estimate
      - QMI_LOC_MASK_DELETE_TIME (0x00000800) --  Mask to delete time estimate
      - QMI_LOC_MASK_DELETE_IONO (0x00001000) --  Mask to delete IONO
      - QMI_LOC_MASK_DELETE_UTC (0x00002000) --  Mask to delete UTC estimate
      - QMI_LOC_MASK_DELETE_HEALTH (0x00004000) --  Mask to delete SV health record
      - QMI_LOC_MASK_DELETE_SADATA (0x00008000) --  Mask to delete SADATA
      - QMI_LOC_MASK_DELETE_RTI (0x00010000) --  Mask to delete RTI
      - QMI_LOC_MASK_DELETE_SV_NO_EXIST (0x00020000) --  Mask to delete SV_NO_EXIST
      - QMI_LOC_MASK_DELETE_FREQ_BIAS_EST (0x00040000) --  Mask to delete frequency bias estimate
      - QMI_LOC_MASK_DELETE_BDS_SVDIR (0x00080000) --  Mask to delete BDS SVDIR
      - QMI_LOC_MASK_DELETE_BDS_SVSTEER (0x00100000) --  Mask to delete BDS SVSTEER
      - QMI_LOC_MASK_DELETE_BDS_TIME (0x00200000) --  Mask to delete BDS time
      - QMI_LOC_MASK_DELETE_BDS_ALM_CORR (0x00400000) --  Mask to delete BDS almanac correlation
      - QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GPS (0x00800000) --  Mask to delete GNSS SV blacklist GPS
      - QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GLO (0x01000000) --  Mask to delete GNSS SV blacklist GLONASS
      - QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_BDS (0x02000000) --  Mask to delete GNSS SV blacklist BDS
      - QMI_LOC_MASK_DELETE_GNSS_SV_BLACKLIST_GAL (0x04000000) --  Mask to delete GNSS SV blacklist Galileo
      - QMI_LOC_MASK_DELETE_GAL_SVDIR (0x08000000) --  Mask to delete Galileo SVDIR
      - QMI_LOC_MASK_DELETE_GAL_SVSTEER (0x10000000) --  Mask to delete Galileo SVSTEER
      - QMI_LOC_MASK_DELETE_GAL_TIME (0x20000000) --  Mask to delete Galileo time
      - QMI_LOC_MASK_DELETE_GAL_ALM_CORR (0x40000000) --  Mask to delete Galileo almanac correlation
 */

  /* Optional */
  /*  Delete Cell Database */
  uint8_t deleteCellDbDataMask_valid;  /**< Must be set to true if deleteCellDbDataMask is being passed */
  qmiLocDeleteCelldbDataMaskT_v02 deleteCellDbDataMask;
  /**<   Mask for the cell database assistance data to delete.
 Values: \n
      - QMI_LOC_MASK_DELETE_CELLDB_POS (0x00000001) --  Delete cell database position
      - QMI_LOC_MASK_DELETE_CELLDB_LATEST_GPS_POS (0x00000002) --  Delete cell database latest GPS position
      - QMI_LOC_MASK_DELETE_CELLDB_OTA_POS (0x00000004) --  Delete cell database OTA position
      - QMI_LOC_MASK_DELETE_CELLDB_EXT_REF_POS (0x00000008) --  Delete cell database external reference position
      - QMI_LOC_MASK_DELETE_CELLDB_TIMETAG (0x00000010) --  Delete cell database time tag
      - QMI_LOC_MASK_DELETE_CELLDB_CELLID (0x00000020) --  Delete cell database cell ID
      - QMI_LOC_MASK_DELETE_CELLDB_CACHED_CELLID (0x00000040) --  Delete cell database cached cell ID
      - QMI_LOC_MASK_DELETE_CELLDB_LAST_SRV_CELL (0x00000080) --  Delete cell database last service cell
      - QMI_LOC_MASK_DELETE_CELLDB_CUR_SRV_CELL (0x00000100) --  Delete cell database current service cell
      - QMI_LOC_MASK_DELETE_CELLDB_NEIGHBOR_INFO (0x00000200) --  Delete cell database neighbor information
 */

  /* Optional */
  /*  Delete Clock Info */
  uint8_t deleteClockInfoMask_valid;  /**< Must be set to true if deleteClockInfoMask is being passed */
  qmiLocDeleteClockInfoMaskT_v02 deleteClockInfoMask;
  /**<   Mask for the clock information assistance data to delete.
 Valid bitmasks: \n
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_EST (0x00000001) --  Delete time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_FREQ_EST (0x00000002) --  Delete frequency estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_WEEK_NUMBER (0x00000004) --  Delete week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_RTC_TIME (0x00000008) --  Delete RTC time
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_TRANSFER (0x00000010) --  Delete time transfer
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GPSTIME_EST (0x00000020) --  Delete GPS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLOTIME_EST (0x00000040) --  Delete GLONASS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLODAY_NUMBER (0x00000080) --  Delete GLONASS day number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO4YEAR_NUMBER (0x00000100) --  Delete GLONASS four year number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO_RF_GRP_DELAY (0x00000200) --  Delete GLONASS RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_DISABLE_TT (0x00000400) --  Delete disable TT
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_LEAPSEC (0x00000800) --  Delete GG leap second
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_GGTB (0x00001000) --  Delete GG GGTB
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSTIME_EST (0x00002000) --  Delete a BDS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GB_GBTB (0x00004000) --  Delete GLONASS-to-BDS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BG_BGTB (0x00008000) --  Delete BDS-to-GLONASS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSWEEK_NUMBER (0x00010000) --  Delete the BDS week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDS_RF_GRP_DELAY (0x00020000) --  Delete the BDS RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTIME_EST (0x00040000) --  Delete a Galileo time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGPS_TB (0x00080000) --  Delete Galileo-to-GPS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGLO_TB (0x00100000) --  Delete Galileo-to-GLO time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOBDS_TB (0x00200000) --  Delete Galileo-to-BDS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALWEEK_NUMBER (0x00800000) --  Delete the Galileo week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GAL_RF_GRP_DELAY (0x01000000) --  Delete the Galileo RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TIME_EST (0x02000000) --  Delete a NavIC time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_WEEK_NUMBER (0x04000000) --  Delete the NavIC week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_RF_GRP_DELAY (0x08000000) --  Delete the NavIC RF GRP delay
 */

  /* Optional */
  /*  Delete BDS SV Info */
  uint8_t deleteBdsSvInfoList_valid;  /**< Must be set to true if deleteBdsSvInfoList is being passed */
  uint32_t deleteBdsSvInfoList_len;  /**< Must be set to # of elements in deleteBdsSvInfoList */
  qmiLocDeleteBDSSvInfoStructT_v02 deleteBdsSvInfoList[QMI_LOC_DELETE_MAX_BDS_SV_INFO_LENGTH_V02];
  /**<   \vspace{0.06in} \n List of BDS satellites to delete the assistance data from.
  */

  /* Optional */
  /*  Delete GAL SV Info */
  uint8_t deleteGalSvInfoList_valid;  /**< Must be set to true if deleteGalSvInfoList is being passed */
  uint32_t deleteGalSvInfoList_len;  /**< Must be set to # of elements in deleteGalSvInfoList */
  qmiLocDeleteGALSvInfoStructT_v02 deleteGalSvInfoList[QMI_LOC_DELETE_MAX_GAL_SV_INFO_LENGTH_V02];
  /**<   \vspace{0.06in} \n List of Galileo satellites to delete the assistance data from.
  */

  /* Optional */
  /*  Delete QZSS-L1S Data */
  uint8_t deleteQzssL1sDataFlag_valid;  /**< Must be set to true if deleteQzssL1sDataFlag is being passed */
  uint8_t deleteQzssL1sDataFlag;
  /**<   Indicates whether to delete QZSS-L1S data;
       if the flag is set, delete data from all QZSS-L1S satellites.
    */
}qmiLocDeleteAssistDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Deletes the location engine
                    assistance data. */
typedef struct {

  /* Mandatory */
  /*  Delete Assist Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_DELETE_ASSIST_DATA_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocDeleteAssistDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Enables/disables XTRA-T session control. */
typedef struct {

  /* Mandatory */
  /*  Enable XTRA-T */
  uint8_t xtraTSessionControl;
  /**<   Indicates whether to enable XTRA-T:\n
       - 0x01 (TRUE) -- Enable XTRA-T \n
       - 0x00 (FALSE) -- Disable XTRA-T */
}qmiLocSetXtraTSessionControlReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Enables/disables XTRA-T session control. */
typedef struct {

  /* Mandatory */
  /*  Set XTRA-T Session Control Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_SET_XTRA_T_SESSION_CONTROL_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetXtraTSessionControlIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the XTRA-T session control value from the location
                    engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetXtraTSessionControlReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the XTRA-T session control value from the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Get XTRA-T Session Control Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_XTRA_T_SESSION_CONTROL_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Enable/Disable XTRA-T */
  uint8_t xtraTSessionControl_valid;  /**< Must be set to true if xtraTSessionControl is being passed */
  uint8_t xtraTSessionControl;
  /**<   Indicates whether to enable XTRA-T:\n
       - 0x01 (TRUE) -- Enable XTRA-T \n
       - 0x00 (FALSE) -- Disable XTRA-T */
}qmiLocGetXtraTSessionControlIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t wifiPositionTime;
  /**<   Common counter (typically, the number of milliseconds since bootup).
        This field is only provided when the modem and host processors are
        synchronized. */
}qmiLocWifiFixTimeStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIFIXERRORCODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_FIX_ERROR_SUCCESS_V02 = 0, /**<  Wi-Fi fix is successful. \n */
  eQMI_LOC_WIFI_FIX_ERROR_WIFI_NOT_AVAILABLE_V02 = 1, /**<  Wi-Fi fix failed because Wi-Fi is not available on the device.\n  */
  eQMI_LOC_WIFI_FIX_ERROR_NO_AP_FOUND_V02 = 2, /**<  Wi-Fi fix failed because no access points are found. \n */
  eQMI_LOC_WIFI_FIX_ERROR_UNAUTHORIZED_V02 = 3, /**<  Wi-Fi fix failed because the server denied access due to bad authorization
       code. \n */
  eQMI_LOC_WIFI_FIX_ERROR_SERVER_UNAVAILABLE_V02 = 4, /**<  Wi-Fi fix failed because the Wi-Fi server is unavailable.\n  */
  eQMI_LOC_WIFI_FIX_ERROR_LOCATION_CANNOT_BE_DETERMINED_V02 = 5, /**<  Wi-Fi fix failed even though APs were found and the server can be reached.
       This might be because the APs found are not in the database. \n */
  eQMI_LOC_WIFI_FIX_ERROR_UNKNOWN_V02 = 6, /**<  Wi-Fi fix failed, but the cause cannot be determined.  */
  QMILOCWIFIFIXERRORCODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiFixErrorCodeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  double lat;
  /**<   Wi-Fi position latitude. \n
        - Type -- Floating point \n
        - Units -- Degrees */

  double lon;
  /**<   Wi-Fi position longitude. \n
        - Type -- Floating point \n
        - Units -- Degrees */

  uint16_t hepe;
  /**<   Wi-Fi position HEPE.\n
        - Units -- Meters */

  uint8_t numApsUsed;
  /**<   Number of Access Points (AP) used to generate a fix. */

  qmiLocWifiFixErrorCodeEnumT_v02 fixErrorCode;
  /**<   Wi-Fi position error code; set to 0 if the fix succeeds. This position
 is only used by a module if the value is 0. If there was a failure,
 the error code provided by the Wi-Fi positioning system can be provided
 here.
 Values: \n
      - eQMI_LOC_WIFI_FIX_ERROR_SUCCESS (0) --  Wi-Fi fix is successful. \n
      - eQMI_LOC_WIFI_FIX_ERROR_WIFI_NOT_AVAILABLE (1) --  Wi-Fi fix failed because Wi-Fi is not available on the device.\n
      - eQMI_LOC_WIFI_FIX_ERROR_NO_AP_FOUND (2) --  Wi-Fi fix failed because no access points are found. \n
      - eQMI_LOC_WIFI_FIX_ERROR_UNAUTHORIZED (3) --  Wi-Fi fix failed because the server denied access due to bad authorization
       code. \n
      - eQMI_LOC_WIFI_FIX_ERROR_SERVER_UNAVAILABLE (4) --  Wi-Fi fix failed because the Wi-Fi server is unavailable.\n
      - eQMI_LOC_WIFI_FIX_ERROR_LOCATION_CANNOT_BE_DETERMINED (5) --  Wi-Fi fix failed even though APs were found and the server can be reached.
       This might be because the APs found are not in the database. \n
      - eQMI_LOC_WIFI_FIX_ERROR_UNKNOWN (6) --  Wi-Fi fix failed, but the cause cannot be determined.
 */
}qmiLocWifiFixPosStructT_v02;  /* Type */
/**
    @}
  */

typedef uint8_t qmiLocWifiApQualifierMaskT_v02;
#define QMI_LOC_WIFI_AP_QUALIFIER_BEING_USED_V02 ((qmiLocWifiApQualifierMaskT_v02)0x01) /**<  Access point is in use by the WPS.  */
#define QMI_LOC_WIFI_AP_QUALIFIER_HIDDEN_SSID_V02 ((qmiLocWifiApQualifierMaskT_v02)0x02) /**<  AP does not broadcast SSID.  */
#define QMI_LOC_WIFI_AP_QUALIFIER_PRIVATE_V02 ((qmiLocWifiApQualifierMaskT_v02)0x04) /**<  AP has encryption turned on.  */
#define QMI_LOC_WIFI_AP_QUALIFIER_INFRASTRUCTURE_MODE_V02 ((qmiLocWifiApQualifierMaskT_v02)0x08) /**<  AP is in infrastructure mode and not in ad-hoc/unknown mode.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t macAddr[QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02];
  /**<   Associated MAC address of the AP. \n
        - Type -- Array of unsigned integers \n
        - Address length -- 6
   */

  int32_t rssi;
  /**<   Receive signal strength indicator.\n
        - Units -- dBm (offset with +100 dB) */

  uint16_t channel;
  /**<   Wi-Fi channel on which a beacon was received. */

  qmiLocWifiApQualifierMaskT_v02 apQualifier;
  /**<   A bitmask of Boolean qualifiers for APs.
        All unused bits in this mask must be set to 0.
        Values: \n
          - 0x01 -- BEING_USED \n
          - 0x02 -- HIDDEN_SSID \n
          - 0x04 -- PRIVATE \n
          - 0x08 -- INFRASTRUCTURE_MODE
         */
}qmiLocWifiApInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  char ssid[QMI_LOC_MAX_WIFI_AP_SSID_STR_LENGTH_V02 + 1];
  /**<   NULL-terminated SSID string of the Wi-Fi AP. Its maximum length according to the ASCII standard is 32 octets. */
}qmiLocWifiApSsidStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects the Wi-Fi position. */
typedef struct {

  /* Optional */
  /*  Wi-Fi Fix Time */
  uint8_t wifiFixTime_valid;  /**< Must be set to true if wifiFixTime is being passed */
  qmiLocWifiFixTimeStructT_v02 wifiFixTime;
  /**<   \vspace{0.06in} \n Time of Wi-Fi position fix. */

  /* Optional */
  /*  Wi-Fi Position */
  uint8_t wifiFixPosition_valid;  /**< Must be set to true if wifiFixPosition is being passed */
  qmiLocWifiFixPosStructT_v02 wifiFixPosition;
  /**<   \vspace{0.06in} \n Wi-Fi position fix. */

  /* Optional */
  /*  Wi-Fi Access Point Information */
  uint8_t apInfo_valid;  /**< Must be set to true if apInfo is being passed */
  uint32_t apInfo_len;  /**< Must be set to # of elements in apInfo */
  qmiLocWifiApInfoStructT_v02 apInfo[QMI_LOC_WIFI_MAX_REPORTED_APS_PER_MSG_V02];
  /**<   \vspace{0.06in} \n AP scan list.
        SSID of the Wi-Fi AP.
        The ordering of the Wi-Fi AP SSID list must match the Wi-Fi AP MAC address list if both are provided,
        that is, the first element of the Wi-Fi AP SSID list must be the SSID of the AP whose MAC
        address is in the first element in the Wi-Fi AP Info MAC Address, and so on. */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horizontalReliability_valid;  /**< Must be set to true if horizontalReliability is being passed */
  qmiLocReliabilityEnumT_v02 horizontalReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Raw HEPE */
  uint8_t rawHepe_valid;  /**< Must be set to true if rawHepe is being passed */
  uint16_t rawHepe;
  /**<   Wi-Fi position raw HEPE, which has no optimization.\n
        - Units -- Meters */

  /* Optional */
  /*  Wi-Fi AP SSID String */
  uint8_t wifiApSsidInfo_valid;  /**< Must be set to true if wifiApSsidInfo is being passed */
  uint32_t wifiApSsidInfo_len;  /**< Must be set to # of elements in wifiApSsidInfo */
  qmiLocWifiApSsidStructT_v02 wifiApSsidInfo[QMI_LOC_WIFI_MAX_REPORTED_APS_PER_MSG_V02];
  /**<   \vspace{0.04in} \n
        The ordering of the Wi-Fi AP SSID list must match the Wi-Fi AP MAC address list if both are provided,
        that is, the first element of the Wi-Fi AP SSID list must be the SSID of the AP whose MAC
        address is in the first element in the Wi-Fi AP Info MAC address, and so on.*/
}qmiLocInjectWifiPositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects the Wi-Fi position. */
typedef struct {

  /* Mandatory */
  /*  Inject Wi-Fi Position Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Wi-Fi Position request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectWifiPositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFISTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_STATUS_AVAILABLE_V02 = 1, /**<  Wi-Fi is available \n */
  eQMI_LOC_WIFI_STATUS_UNAVAILABLE_V02 = 2, /**<  Wi-Fi is not available  */
  QMILOCWIFISTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Notifies the location engine of the Wi-Fi status. */
typedef struct {

  /* Mandatory */
  /*  Availablility of Wi-Fi */
  qmiLocWifiStatusEnumT_v02 wifiStatus;
  /**<   Wi-Fi status information.
 Values: \n
      - eQMI_LOC_WIFI_STATUS_AVAILABLE (1) --  Wi-Fi is available \n
      - eQMI_LOC_WIFI_STATUS_UNAVAILABLE (2) --  Wi-Fi is not available
 */
}qmiLocNotifyWifiStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the location engine of the Wi-Fi status. */
typedef struct {

  /* Mandatory */
  /*  Status of Notify Wi-Fi Status Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Notify Wi-Fi Status request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocNotifyWifiStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the mask of the events for which a client has
                    registered. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetRegisteredEventsReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the mask of the events for which a client has
                    registered. */
typedef struct {

  /* Mandatory */
  /*  Get Registered Events Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Registered Events request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Event Registration Mask */
  uint8_t eventRegMask_valid;  /**< Must be set to true if eventRegMask is being passed */
  qmiLocEventRegMaskT_v02 eventRegMask;
  /**<   Event registration mask.
 The control point must enable the following masks to receive the events:\n
      - QMI_LOC_EVENT_MASK_POSITION_REPORT (0x00000001) --  Position report event indications. \n
      - QMI_LOC_EVENT_MASK_GNSS_SV_INFO (0x00000002) --  Satellite report event indications. These reports are sent at a 1 Hz rate. \n
      - QMI_LOC_EVENT_MASK_NMEA (0x00000004) --  NMEA reports for
       position and satellites in view. The report is at a 1 Hz rate. \n
      - QMI_LOC_EVENT_MASK_NI_NOTIFY_VERIFY_REQ (0x00000008) --  NI Notify/Verify request event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_TIME_REQ (0x00000010) --  Time injection request event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_PREDICTED_ORBITS_REQ (0x00000020) --  Predicted orbits request
       event indications. \n
      - QMI_LOC_EVENT_MASK_INJECT_POSITION_REQ (0x00000040) --  Position injection request event indications. \n
      - QMI_LOC_EVENT_MASK_ENGINE_STATE (0x00000080) --  Engine state report
       event indications. \n
      - QMI_LOC_EVENT_MASK_FIX_SESSION_STATE (0x00000100) --  Fix session status report event indications. \n
      - QMI_LOC_EVENT_MASK_WIFI_REQ (0x00000200) --  Wi-Fi position request event indications. \n
      - QMI_LOC_EVENT_MASK_SENSOR_STREAMING_READY_STATUS (0x00000400) --  Notifications from the location engine indicating its readiness to accept data from the
       sensors (accelerometer, gyroscope, and so on). \n
      - QMI_LOC_EVENT_MASK_TIME_SYNC_REQ (0x00000800) --  Time sync requests
       from the GPS engine. Time sync enables the GPS engine to synchronize
       its clock with the sensor processor's clock. \n
      - QMI_LOC_EVENT_MASK_SET_SPI_STREAMING_REPORT (0x00001000) --  Stationary Position Indicator (SPI) streaming report indications. \n
      - QMI_LOC_EVENT_MASK_LOCATION_SERVER_CONNECTION_REQ (0x00002000) --  Location server requests; generated when the service wishes to
       establish a connection with a location server. \n
      - QMI_LOC_EVENT_MASK_NI_GEOFENCE_NOTIFICATION (0x00004000) --  Notifications related to network-initiated Geofences. These events notify the client
       when a network-initiated Geofence is added, deleted, or edited. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_GEN_ALERT (0x00008000) --  Geofence alerts; generated to inform the client of the changes that can
       affect a Geofence, for example, if GPS is turned off or if the network is
       unavailable. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BREACH_NOTIFICATION (0x00010000) --  Geofence breach; when a UE enters or leaves the perimeter of a Geofence.
      This breach report is for a single Geofence. \n
      - QMI_LOC_EVENT_MASK_PEDOMETER_CONTROL (0x00020000) --  Pedometer control requests from the location engine. The location engine sends
       this event to control the injection of pedometer reports. \n
      - QMI_LOC_EVENT_MASK_MOTION_DATA_CONTROL (0x00040000) --  Motion data control requests from the location engine. The location engine sends
       this event to control the injection of motion data. \n
      - QMI_LOC_EVENT_MASK_BATCH_FULL_NOTIFICATION (0x00080000) --  Notification when a batch is full. The location engine sends this event to
      notify of batch full for ongoing batching session. \n
      - QMI_LOC_EVENT_MASK_LIVE_BATCHED_POSITION_REPORT (0x00100000) --  Position report indications along with an ongoing batching session.
       The location engine sends this event to notify the batched position
       report while a batching session is ongoing. \n
      - QMI_LOC_EVENT_MASK_INJECT_WIFI_AP_DATA_REQ (0x00200000) --  Wi-Fi AP data inject request event indications. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_BREACH_NOTIFICATION (0x00400000) --  Notifications when a Geofence is breached. These events are generated when a UE enters
       or leaves the perimeter of a Geofence. This breach notification is for
       multiple Geofences. Breaches from multiple Geofences are all batched and
       sent in the same notification.  \n
      - QMI_LOC_EVENT_MASK_VEHICLE_DATA_READY_STATUS (0x00800000) --  Notifications from the
       location engine indicating its readiness to accept vehicle data (vehicle
       accelerometer, vehicle angular rate, vehicle odometry, and so on).\n
      - QMI_LOC_EVENT_MASK_GNSS_MEASUREMENT_REPORT (0x01000000) --  System clock and satellite measurement report events (system clock, SV time,
       Doppler, and so on). Reports are generated only for the GNSS satellite constellations
       that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n
      - QMI_LOC_EVENT_MASK_GNSS_SV_POLYNOMIAL_REPORT (0x02000000) --  Satellite position reports as polynomials. Reports are generated only for the GNSS satellite
        constellations that are enabled using QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_PROXIMITY_NOTIFICATION (0x04000000) --  Notifications when a Geofence proximity is entered and exited. The proximity of
      a Geofence might be due to different contexts. These contexts are identified
      using the context ID in this indication. The context of a Geofence can contain Wi-Fi area
      ID lists, IBeacon lists, Cell-ID list, and so forth. \n
      - QMI_LOC_EVENT_MASK_GDT_UPLOAD_BEGIN_REQ (0x08000000) --  Generic Data Transport (GDT) upload session begin request event indications. \n
      - QMI_LOC_EVENT_MASK_GDT_UPLOAD_END_REQ (0x10000000) --  GDT upload session end request event indications. \n
      - QMI_LOC_EVENT_MASK_GEOFENCE_BATCH_DWELL_NOTIFICATION (0x20000000) --  Notifications when a Geofence is dwelled. These events are generated when a UE enters
       or leaves the perimeter of a Geofence and dwells inside or outside for a specified time.
       This dwell notification is for multiple Geofences. Dwells from multiple Geofences are all batched and
       sent in the same notification. \n
      - QMI_LOC_EVENT_MASK_GET_TIME_ZONE_REQ (0x40000000) --  Requests for time zone information from the service.
       These events are generated when there is a need for time zone information in the
       service. \n
      - QMI_LOC_EVENT_MASK_BATCHING_STATUS (0x80000000) --  Asynchronous events related to batching. n
      - QMI_LOC_EVENT_MASK_INTERNAL_STATUS_REPORT (0x100000000) --  The location service internal status report mask. \n
      - QMI_LOC_EVENT_MASK_INJECT_SRN_AP_DATA_REQ (0x200000000) --  Asynchronous events for
       short range node (SRN) RSSI scans, for example, BT, BTLE, NFC, and so on. \n
      - QMI_LOC_EVENT_MASK_GNSS_ONLY_POSITION_REPORT (0x400000000) --  Position report event indications that contain a GNSS only position. \n
      - QMI_LOC_EVENT_MASK_FDCL_SERVICE_REQ (0x800000000) --  FDCL service request. \n
      - QMI_LOC_EVENT_MASK_DC_REPORT (0x1000000000) --  DC report event indications that contains disaster and crisis reports. \n
      - QMI_LOC_EVENT_MASK_ENGINE_LOCK_STATE (0x2000000000) --  Asynchronous events related to the engine lock state. \n
      - QMI_LOC_EVENT_MASK_UNPROPAGATED_POSITION_REPORT (0x4000000000) --  Unpropagated fix. \n
      - QMI_LOC_EVENT_MASK_BS_OBS_DATA_SERVICE_REQ (0x8000000000) --  Base station observed data service request. \n
      - QMI_LOC_EVENT_MASK_EPHEMERIS_REPORT (0x10000000000) --  Ephemeris data for all GNSS constellations. \n
      - QMI_LOC_EVENT_MASK_NEXT_LS_INFO_REPORT (0x20000000000) --  Upcoming leap second information from the service. \n
      - QMI_LOC_EVENT_MASK_GET_BAND_MEASUREMENT_METRICS (0x40000000000) --  The band measurement metrics from the ME. \n
      - QMI_LOC_EVENT_MASK_GNSS_NHZ_MEASUREMENT_REPORT (0x80000000000) --  System clock and satellite
       measurement report events (system clock, SV time, Doppler, and so on) at a rate greater
       than 1 Hz.
       Reports are generated only for the GNSS satellite constellations that are enabled using
       QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG.  \n
      - QMI_LOC_EVENT_MASK_GNSS_EVENT_REPORT (0x100000000000) --  The QMI_LOC_EVENT_REPORT indication. \n
      - QMI_LOC_EVENT_MASK_QUERY_XTRA_INFO (0x200000000000) --  Event indication to trigger XTRA config query from the control point. \n
      - QMI_LOC_EVENT_MASK_SAP_INS_PARAMETERS_REPORT (0x400000000000) --  QMI_LOC_EVENT_SAP_INS_PARAMETERS indication. \n
      - QMI_LOC_EVENT_MASK_LATENCY_INFORMATION_REPORT (0x800000000000) --  QMI_LOC_LATENCY_INFORMATION indication.
 */
}qmiLocGetRegisteredEventsIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCOPERATIONMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_OPER_MODE_DEFAULT_V02 = 1, /**<  Use the default engine mode \n  */
  eQMI_LOC_OPER_MODE_MSB_V02 = 2, /**<  Use the MS-based mode \n */
  eQMI_LOC_OPER_MODE_MSA_V02 = 3, /**<  Use the MS-assisted mode \n  */
  eQMI_LOC_OPER_MODE_STANDALONE_V02 = 4, /**<  Use Standalone mode \n */
  eQMI_LOC_OPER_MODE_CELL_ID_V02 = 5, /**<  Use cell ID; this mode is only valid for GSM/UMTS networks \n */
  eQMI_LOC_OPER_MODE_WWAN_V02 = 6, /**<  Use WWAN measurements to calculate the position; if this mode is
       set, AFLT is used for 1X networks and OTDOA is used
       for LTE networks  */
  QMILOCOPERATIONMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocOperationModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Tells the engine to use the specified operation mode while
                    making the position fixes. */
typedef struct {

  /* Mandatory */
  /*  Operation Mode */
  qmiLocOperationModeEnumT_v02 operationMode;
  /**<   Preferred operation mode.
 Values: \n
      - eQMI_LOC_OPER_MODE_DEFAULT (1) --  Use the default engine mode \n
      - eQMI_LOC_OPER_MODE_MSB (2) --  Use the MS-based mode \n
      - eQMI_LOC_OPER_MODE_MSA (3) --  Use the MS-assisted mode \n
      - eQMI_LOC_OPER_MODE_STANDALONE (4) --  Use Standalone mode \n
      - eQMI_LOC_OPER_MODE_CELL_ID (5) --  Use cell ID; this mode is only valid for GSM/UMTS networks \n
      - eQMI_LOC_OPER_MODE_WWAN (6) --  Use WWAN measurements to calculate the position; if this mode is
       set, AFLT is used for 1X networks and OTDOA is used
       for LTE networks
 */

  /* Optional */
  /*  Minimum Interval Between Position Reports */
  uint8_t minInterval_valid;  /**< Must be set to true if minInterval is being passed */
  uint32_t minInterval;
  /**<   Minimum time interval, specified by the control point, that must elapse between
       position reports. \n
       - Units -- milliseconds \n
       - Default -- 1000 ms
  */
}qmiLocSetOperationModeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Tells the engine to use the specified operation mode while
                    making the position fixes. */
typedef struct {

  /* Mandatory */
  /*  Set Operation Mode Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Operation Mode request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetOperationModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Gets the current operation mode from the engine. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetOperationModeReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Gets the current operation mode from the engine. */
typedef struct {

  /* Mandatory */
  /*  Get Operation Mode Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Operation Mode request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Operation Mode */
  uint8_t operationMode_valid;  /**< Must be set to true if operationMode is being passed */
  qmiLocOperationModeEnumT_v02 operationMode;
  /**<   Current operation mode.
 Values: \n
      - eQMI_LOC_OPER_MODE_DEFAULT (1) --  Use the default engine mode \n
      - eQMI_LOC_OPER_MODE_MSB (2) --  Use the MS-based mode \n
      - eQMI_LOC_OPER_MODE_MSA (3) --  Use the MS-assisted mode \n
      - eQMI_LOC_OPER_MODE_STANDALONE (4) --  Use Standalone mode \n
      - eQMI_LOC_OPER_MODE_CELL_ID (5) --  Use cell ID; this mode is only valid for GSM/UMTS networks \n
      - eQMI_LOC_OPER_MODE_WWAN (6) --  Use WWAN measurements to calculate the position; if this mode is
       set, AFLT is used for 1X networks and OTDOA is used
       for LTE networks
 */
}qmiLocGetOperationModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the SPI status, which
                    indicates whether the device is stationary. */
typedef struct {

  /* Mandatory */
  /*  Stationary Status */
  uint8_t stationary;
  /**<   Indicates whether the device is stationary: \n
       - 0x00 (FALSE) -- Device is not stationary \n
       - 0x01 (TRUE)  -- Device is stationary
    */

  /* Optional */
  /*  Confidence */
  uint8_t confidenceStationary_valid;  /**< Must be set to true if confidenceStationary is being passed */
  uint8_t confidenceStationary;
  /**<   Confidence in the Stationary state expressed as a percentage.\n
       - Range -- 0 to 100 */
}qmiLocSetSpiStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to set the SPI status, which
                    indicates whether the device is stationary. */
typedef struct {

  /* Mandatory */
  /*  Status of SPI Status Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the SPI status request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetSpiStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint8_t qmiLocSensorDataFlagMaskT_v02;
#define QMI_LOC_SENSOR_DATA_FLAG_SIGN_REVERSAL_V02 ((qmiLocSensorDataFlagMaskT_v02)0x01) /**<  Bitmask specifying that a sign reversal is required while interpreting
     the sensor data; only applies to the accelerometer samples  */
#define QMI_LOC_SENSOR_DATA_FLAG_SENSOR_TIME_IS_MODEM_TIME_V02 ((qmiLocSensorDataFlagMaskT_v02)0x02) /**<  Bitmask specifying that the sensor time stamp is the same as the modem
       time stamp  */
#define QMI_LOC_SENSOR_DATA_FLAG_CALIBRATED_DATA_V02 ((qmiLocSensorDataFlagMaskT_v02)0x04) /**<  Bitmask specifying that the injected sensor data is calibrated  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSENSORDATATIMESOURCEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED_V02 = 0, /**<  Sensor time source is unspecified \n */
  eQMI_LOC_SENSOR_TIME_SOURCE_COMMON_V02 = 1, /**<  Time source is common between the sensors and
       the location engine  */
  QMILOCSENSORDATATIMESOURCEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSensorDataTimeSourceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t timeOffset;
  /**<   Sample time offset. This time offset must be
       relative to the timestamp of the first sensor data sample.\n
       - Units -- Milliseconds */

  float xAxis;
  /**<   Sensor x-axis sample. \n
       - Units accelerometer -- Meters per second^2 \n
       - Units gyroscope --     Radians per second \n
       - Units magnetometer --  microTesla */

  float yAxis;
  /**<   Sensor y-axis sample. \n
       - Units accelerometer -- Meters per second^2 \n
       - Units gyroscope --     Radians per second \n
       - Units magnetometer --  microTesla */

  float zAxis;
  /**<   Sensor z-axis sample. \n
       - Units accelerometer -- Meters per second^2 ) \n
       - Units gyroscope --     Radians per second \n
       - Units magnetometer --  microTesla */
}qmiLoc3AxisSensorSampleStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t timeOfFirstSample;
  /**<   Indicates a full 32-bit timestamp of the first (oldest) sample in this
       message. The timestamp is in the time reference scale that is
       used by the sensor time source.\n
       - Units -- Milliseconds */

  qmiLocSensorDataFlagMaskT_v02 flags;
  /**<   Flags to indicate any deviation from the default measurement
 assumptions. Set all unused bits in this field to 0.
 Valid bitmasks:
      - QMI_LOC_SENSOR_DATA_FLAG_SIGN_REVERSAL (0x01) --  Bitmask specifying that a sign reversal is required while interpreting
     the sensor data; only applies to the accelerometer samples
      - QMI_LOC_SENSOR_DATA_FLAG_SENSOR_TIME_IS_MODEM_TIME (0x02) --  Bitmask specifying that the sensor time stamp is the same as the modem
       time stamp
      - QMI_LOC_SENSOR_DATA_FLAG_CALIBRATED_DATA (0x04) --  Bitmask specifying that the injected sensor data is calibrated  */

  uint32_t sensorData_len;  /**< Must be set to # of elements in sensorData */
  qmiLoc3AxisSensorSampleStructT_v02 sensorData[QMI_LOC_SENSOR_DATA_MAX_SAMPLES_V02];
  /**<   Variable length array specifying sensor samples. \n
       - Maximum length of the array -- 50 */
}qmiLoc3AxisSensorSampleListStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t timeOffset;
  /**<   Sample time offset. This time offset must be
       relative to the timestamp of the first sensor sample.\n
       - Units: Milliseconds */

  float temperature;
  /**<   Sensor temperature. \n
       - Type: Floating point \n
       - Units: Degrees Celsius \n
       - Range: -50 to +100.00 */
}qmiLocSensorTemperatureSampleStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSensorDataTimeSourceEnumT_v02 timeSource;
  /**<   Indicates the time source of the sensor data. Location service uses
 this field to identify the time reference used in the
 sensor data timestamps.
 Values: \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED (0) --  Sensor time source is unspecified \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_COMMON (1) --  Time source is common between the sensors and
       the location engine
 */

  uint32_t timeOfFirstSample;
  /**<   Indicates a full 32-bit timestamp of the first (oldest) sample in this
       message. The timestamp is in the time reference scale that is
       used by the sensor time source.\n
       - Units -- Milliseconds */

  uint32_t temperatureData_len;  /**< Must be set to # of elements in temperatureData */
  qmiLocSensorTemperatureSampleStructT_v02 temperatureData[QMI_LOC_SENSOR_DATA_MAX_SAMPLES_V02];
  /**<   Variable length array specifying sensor temperature samples. \n
       - Maximum length of the array -- 50 */
}qmiLocSensorTemperatureSampleListStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject sensor data into the
                    GNSS location engine. */
typedef struct {

  /* Optional */
  /*  Opaque Identifier */
  uint8_t opaqueIdentifier_valid;  /**< Must be set to true if opaqueIdentifier is being passed */
  uint32_t opaqueIdentifier;
  /**<   An opaque identifier that is sent in by the client that is echoed
       in the indication so the client can relate the indication to the
       request. */

  /* Optional */
  /*  3-Axis Accelerometer Data */
  uint8_t threeAxisAccelData_valid;  /**< Must be set to true if threeAxisAccelData is being passed */
  qmiLoc3AxisSensorSampleListStructT_v02 threeAxisAccelData;
  /**<   \vspace{0.06in} \n Accelerometer sensor samples. */

  /* Optional */
  /*  3-Axis Gyroscope Data */
  uint8_t threeAxisGyroData_valid;  /**< Must be set to true if threeAxisGyroData is being passed */
  qmiLoc3AxisSensorSampleListStructT_v02 threeAxisGyroData;
  /**<   \vspace{0.06in} \n Gyroscope sensor samples. */

  /* Optional */
  /*  3-Axis Accelerometer Data Time Source */
  uint8_t threeAxisAccelDataTimeSource_valid;  /**< Must be set to true if threeAxisAccelDataTimeSource is being passed */
  qmiLocSensorDataTimeSourceEnumT_v02 threeAxisAccelDataTimeSource;
  /**<   Time source for the 3-axis accelerometer data. The location service uses
 this field to identify the time reference used in the accelerometer data
 timestamps. If not specified, the location service assumes that the
 time source for the accelereometer data is unknown. \n
 Values: \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED (0) --  Sensor time source is unspecified \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_COMMON (1) --  Time source is common between the sensors and
       the location engine
 */

  /* Optional */
  /*  3-Axis Gyroscope Data Time Source */
  uint8_t threeAxisGyroDataTimeSource_valid;  /**< Must be set to true if threeAxisGyroDataTimeSource is being passed */
  qmiLocSensorDataTimeSourceEnumT_v02 threeAxisGyroDataTimeSource;
  /**<   Time source for the 3-axis gyroscope data. The location service uses
 this field to identify the time reference used in the gyroscope data
 timestamps. If not specified, the location service assumes that the
 time source for the gyroscope data is unknown. \n
 Values: \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED (0) --  Sensor time source is unspecified \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_COMMON (1) --  Time source is common between the sensors and
       the location engine
 */

  /* Optional */
  /*  Accelerometer Temperature Data */
  uint8_t accelTemperatureData_valid;  /**< Must be set to true if accelTemperatureData is being passed */
  qmiLocSensorTemperatureSampleListStructT_v02 accelTemperatureData;
  /**<   \vspace{0.06in}  \n Accelerometer temperature samples. This data is optional and does not
       have to be included in the message along with accelerometer data. */

  /* Optional */
  /*  Gyroscope Temperature Data */
  uint8_t gyroTemperatureData_valid;  /**< Must be set to true if gyroTemperatureData is being passed */
  qmiLocSensorTemperatureSampleListStructT_v02 gyroTemperatureData;
  /**<   \vspace{0.06in} \n Gyroscope temperature samples. This data is optional and does not
       have to be included in the message along with gyroscope data. */

  /* Optional */
  /*  3-Axis Magnetometer Data */
  uint8_t threeAxisMagData_valid;  /**< Must be set to true if threeAxisMagData is being passed */
  qmiLoc3AxisSensorSampleListStructT_v02 threeAxisMagData;
  /**<   \vspace{0.06in} \n Magnetometer sensor samples. */

  /* Optional */
  /*  3-Axis Magnetometer Data Time Source */
  uint8_t threeAxisMagDataTimeSource_valid;  /**< Must be set to true if threeAxisMagDataTimeSource is being passed */
  qmiLocSensorDataTimeSourceEnumT_v02 threeAxisMagDataTimeSource;
  /**<   Time source for the 3-axis magnetometer data. The location service uses
 this field to identify the time reference used in the magnetometer data
 timestamps. If not specified, the location service assumes that the
 time source for the magnetometer data is unknown. \n
 Values: \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED (0) --  Sensor time source is unspecified \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_COMMON (1) --  Time source is common between the sensors and
       the location engine
 */
}qmiLocInjectSensorDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject sensor data into the
                    GNSS location engine. */
typedef struct {

  /* Mandatory */
  /*  Inject Sensor Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Sensor Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Opaque Identifier */
  uint8_t opaqueIdentifier_valid;  /**< Must be set to true if opaqueIdentifier is being passed */
  uint32_t opaqueIdentifier;
  /**<   Opaque identifier that was sent in by the client echoed
       so the client can relate the indication to the request. */

  /* Optional */
  /*  Accelerometer Samples Accepted */
  uint8_t threeAxisAccelSamplesAccepted_valid;  /**< Must be set to true if threeAxisAccelSamplesAccepted is being passed */
  uint8_t threeAxisAccelSamplesAccepted;
  /**<   Lets the client know how many 3-axis accelerometer samples
       were accepted. This field is present only if the accelerometer
       samples were sent in the request. */

  /* Optional */
  /*  Gyroscope Samples Accepted */
  uint8_t threeAxisGyroSamplesAccepted_valid;  /**< Must be set to true if threeAxisGyroSamplesAccepted is being passed */
  uint8_t threeAxisGyroSamplesAccepted;
  /**<   Lets the client know how many 3-axis gyroscope samples were
       accepted. This field is present only if the gyroscope
       samples were sent in the request. */

  /* Optional */
  /*  Accelerometer Temperature Samples Accepted */
  uint8_t accelTemperatureSamplesAccepted_valid;  /**< Must be set to true if accelTemperatureSamplesAccepted is being passed */
  uint8_t accelTemperatureSamplesAccepted;
  /**<   Lets the client know how many accelerometer temperature
       samples were accepted. This field is present only if the accelerometer
       temperature samples were sent in the request. */

  /* Optional */
  /*  Gyroscope Temperature Samples Accepted */
  uint8_t gyroTemperatureSamplesAccepted_valid;  /**< Must be set to true if gyroTemperatureSamplesAccepted is being passed */
  uint8_t gyroTemperatureSamplesAccepted;
  /**<   Lets the client know how many gyroscope temperature samples
       were accepted. This field is present only if the gyroscope
       temperature samples were sent in the request. */

  /* Optional */
  /*  Magnetometer Samples Accepted */
  uint8_t threeAxisMagSamplesAccepted_valid;  /**< Must be set to true if threeAxisMagSamplesAccepted is being passed */
  uint8_t threeAxisMagSamplesAccepted;
  /**<   Lets the client know how many 3-axis magnetometer samples
       were accepted. This field is present only if the magnetometer
       samples were sent in the request. */
}qmiLocInjectSensorDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject time synchronization data. */
typedef struct {

  /* Mandatory */
  /*  Reference Time Sync Counter */
  uint32_t refCounter;
  /**<   Set to the value that was sent to the control point when the
       GNSS location engine requested time synchronization injection. */

  /* Mandatory */
  /*  Sensor Receive Time */
  uint32_t sensorProcRxTime;
  /**<   Value of the sensor time when the control point received the
       Time Sync Inject request from the GNSS location engine.
       Must be monotonically increasing, jitter @latexonly $\leq$ @endlatexonly 1
       millisecond, never stopping until the process is rebooted.\n
       - Units -- Milliseconds */

  /* Mandatory */
  /*  Sensor Transmit Time */
  uint32_t sensorProcTxTime;
  /**<   Value of the sensor time when the control point injects this message
       for use by the GNSS location engine.
       Must be monotonically increasing, jitter @latexonly $\leq$ @endlatexonly 1
       millisecond, never stopping until the process is rebooted.\n
       - Units -- Milliseconds */
}qmiLocInjectTimeSyncDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject time synchronization data. */
typedef struct {

  /* Mandatory */
  /*  Inject Time Sync Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Time Synchronization Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectTimeSyncDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCRADLEMOUNTSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_CRADLE_STATE_NOT_MOUNTED_V02 = 0, /**<  Device is mounted on the cradle \n */
  eQMI_LOC_CRADLE_STATE_MOUNTED_V02 = 1, /**<  Device is not mounted on the cradle \n */
  eQMI_LOC_CRADLE_STATE_UNKNOWN_V02 = 2, /**<  Unknown cradle mount state */
  QMILOCCRADLEMOUNTSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocCradleMountStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the current
                    cradle mount configuration. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetCradleMountConfigReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the current
                    cradle mount configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Cradle Mount Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_CRADLE_MOUNT_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Cradle Mount State */
  uint8_t cradleMountState_valid;  /**< Must be set to true if cradleMountState is being passed */
  qmiLocCradleMountStateEnumT_v02 cradleMountState;
  /**<   Cradle Mount state set by the control point.
 Values: \n
      - eQMI_LOC_CRADLE_STATE_NOT_MOUNTED (0) --  Device is mounted on the cradle \n
      - eQMI_LOC_CRADLE_STATE_MOUNTED (1) --  Device is not mounted on the cradle \n
      - eQMI_LOC_CRADLE_STATE_UNKNOWN (2) --  Unknown cradle mount state
 */

  /* Optional */
  /*  Cradle Mount Confidence */
  uint8_t confidenceCradleMountState_valid;  /**< Must be set to true if confidenceCradleMountState is being passed */
  uint8_t confidenceCradleMountState;
  /**<   Confidence of the Cradle Mount state expressed as a percentage.\n
       - Range: 0 to 100 */
}qmiLocGetCradleMountConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the current
                    cradle mount configuration. */
typedef struct {

  /* Mandatory */
  /*  Cradle Mount State */
  qmiLocCradleMountStateEnumT_v02 cradleMountState;
  /**<   Cradle Mount state set by the control point.
 Values: \n
      - eQMI_LOC_CRADLE_STATE_NOT_MOUNTED (0) --  Device is mounted on the cradle \n
      - eQMI_LOC_CRADLE_STATE_MOUNTED (1) --  Device is not mounted on the cradle \n
      - eQMI_LOC_CRADLE_STATE_UNKNOWN (2) --  Unknown cradle mount state
 */

  /* Optional */
  /*  Cradle Mount Confidence */
  uint8_t confidenceCradleMountState_valid;  /**< Must be set to true if confidenceCradleMountState is being passed */
  uint8_t confidenceCradleMountState;
  /**<   Confidence in the Cradle Mount state expressed as a percentage.\n
       - Range -- 0 to 100 */
}qmiLocSetCradleMountConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to set the current
                    cradle mount configuration. */
typedef struct {

  /* Mandatory */
  /*  Set Cradle Mount Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_SET_CRADLE_MOUNT_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetCradleMountConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCEXTERNALPOWERCONFIGENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_EXTERNAL_POWER_NOT_CONNECTED_V02 = 0, /**<  Device is not connected to an external power source \n */
  eQMI_LOC_EXTERNAL_POWER_CONNECTED_V02 = 1, /**<  Device is connected to an external power source \n  */
  eQMI_LOC_EXTERNAL_POWER_UNKNOWN_V02 = 2, /**<  Unknown external power state  */
  QMILOCEXTERNALPOWERCONFIGENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocExternalPowerConfigEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the current
                    external power configuration. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetExternalPowerConfigReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the current
                    external power configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Ext Power Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_EXTERNAL_POWER_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  External Power State */
  uint8_t externalPowerState_valid;  /**< Must be set to true if externalPowerState is being passed */
  qmiLocExternalPowerConfigEnumT_v02 externalPowerState;
  /**<   Power state injected by the control point.
 Values: \n
      - eQMI_LOC_EXTERNAL_POWER_NOT_CONNECTED (0) --  Device is not connected to an external power source \n
      - eQMI_LOC_EXTERNAL_POWER_CONNECTED (1) --  Device is connected to an external power source \n
      - eQMI_LOC_EXTERNAL_POWER_UNKNOWN (2) --  Unknown external power state
 */
}qmiLocGetExternalPowerConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCBATTERYLEVELENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_BATTERY_LEVEL_UNKNOWN_V02 = 0, /**<  Device battery level is unknown \n */
  eQMI_LOC_BATTERY_LEVEL_VERY_HIGH_V02 = 1, /**<  Device battery level is >75% and <=100% \n */
  eQMI_LOC_BATTERY_LEVEL_HIGH_V02 = 2, /**<  Device battery level is >50% and <=75% \n */
  eQMI_LOC_BATTERY_LEVEL_MEDIUM_V02 = 3, /**<  Device battery level is >25% and <=50% \n */
  eQMI_LOC_BATTERY_LEVEL_LOW_V02 = 4, /**<  Device battery level is >0% and <= 25%  */
  QMILOCBATTERYLEVELENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocBatteryLevelEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the current
                    external power configuration. */
typedef struct {

  /* Mandatory */
  /*  External Power State */
  qmiLocExternalPowerConfigEnumT_v02 externalPowerState;
  /**<   Power state injected by the control point.
 Values: \n
      - eQMI_LOC_EXTERNAL_POWER_NOT_CONNECTED (0) --  Device is not connected to an external power source \n
      - eQMI_LOC_EXTERNAL_POWER_CONNECTED (1) --  Device is connected to an external power source \n
      - eQMI_LOC_EXTERNAL_POWER_UNKNOWN (2) --  Unknown external power state
 */

  /* Optional */
  /*  Battery Level Percent */
  uint8_t batteryLevel_valid;  /**< Must be set to true if batteryLevel is being passed */
  qmiLocBatteryLevelEnumT_v02 batteryLevel;
  /**<   Battery level as injected by the control point.
 Values: \n
      - eQMI_LOC_BATTERY_LEVEL_UNKNOWN (0) --  Device battery level is unknown \n
      - eQMI_LOC_BATTERY_LEVEL_VERY_HIGH (1) --  Device battery level is >75% and <=100% \n
      - eQMI_LOC_BATTERY_LEVEL_HIGH (2) --  Device battery level is >50% and <=75% \n
      - eQMI_LOC_BATTERY_LEVEL_MEDIUM (3) --  Device battery level is >25% and <=50% \n
      - eQMI_LOC_BATTERY_LEVEL_LOW (4) --  Device battery level is >0% and <= 25%
 */
}qmiLocSetExternalPowerConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to set the current
                    external power configuration. */
typedef struct {

  /* Mandatory */
  /*  Set External Power Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_SET_EXTERNAL_POWER_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetExternalPowerConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSERVERPDNENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV4_V02 = 0x01, /**<  IPv4 PDN type \n  */
  eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV6_V02 = 0x02, /**<  IPv6 PDN type \n */
  eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV4V6_V02 = 0x03, /**<  IPv4v6 PDN type \n  */
  eQMI_LOC_APN_PROFILE_PDN_TYPE_PPP_V02 = 0x04, /**<  PPP PDN type  */
  QMILOCSERVERPDNENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocServerPDNEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocServerPDNEnumT_v02 pdnType;
  /**<   PDN type of the APN profile.
 Values: \n
      - eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV4 (0x01) --  IPv4 PDN type \n
      - eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV6 (0x02) --  IPv6 PDN type \n
      - eQMI_LOC_APN_PROFILE_PDN_TYPE_IPV4V6 (0x03) --  IPv4v6 PDN type \n
      - eQMI_LOC_APN_PROFILE_PDN_TYPE_PPP (0x04) --  PPP PDN type
 */

  char apnName[QMI_LOC_MAX_APN_NAME_LENGTH_V02 + 1];
  /**<   APN name. \n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator)-- 101

  */
}qmiLocApnProfilesStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSERVERREQSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SERVER_REQ_STATUS_SUCCESS_V02 = 1, /**<  Location server request was successful \n */
  eQMI_LOC_SERVER_REQ_STATUS_FAILURE_V02 = 2, /**<  Location server request failed  */
  QMILOCSERVERREQSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocServerReqStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inform the service about the
                    status of the location server connection request that the
                    service might have sent via the
                    QMI_LOC_EVENT_LOCATION_SERVER_CONNECTION_REQ_IND event. */
typedef struct {

  /* Mandatory */
  /*  Connection Handle */
  uint32_t connHandle;
  /**<   Connection handle that the service specified in the
       Location Server Connection request event. */

  /* Mandatory */
  /*  Request Type */
  qmiLocServerRequestEnumT_v02 requestType;
  /**<   Type of connection request service that was specified in the
 Location Server Connection Request event.
 Values: \n
      - eQMI_LOC_SERVER_REQUEST_OPEN (1) --  Open a connection to the location server \n
      - eQMI_LOC_SERVER_REQUEST_CLOSE (2) --  Close a connection to the location server
 */

  /* Mandatory */
  /*  Connection Status */
  qmiLocServerReqStatusEnumT_v02 statusType;
  /**<   Status of the connection request.
 Values: \n
      - eQMI_LOC_SERVER_REQ_STATUS_SUCCESS (1) --  Location server request was successful \n
      - eQMI_LOC_SERVER_REQ_STATUS_FAILURE (2) --  Location server request failed
 */

  /* Optional */
  /*  APN Profile */
  uint8_t apnProfile_valid;  /**< Must be set to true if apnProfile is being passed */
  qmiLocApnProfilesStructT_v02 apnProfile;
  /**<   \vspace{0.06in} \n Access point name (APN) profile information is present only when
       requestType is OPEN and statusType is SUCCESS. */

  /* Optional */
  /*  APN Type Mask */
  uint8_t apnTypeMask_valid;  /**< Must be set to true if apnTypeMask is being passed */
  qmiLocApnTypeMaskT_v02 apnTypeMask;
  /**<   Bitmask specifying the APN type for the requested connection.
 This bitmask uniquely identifies a data connection which the AP brought up
 for the data connection request of the modem GPS stack. This mask is
 provided to the data services as part of the policy to identify the correct
 data connection AP.
 In the process, this field is not provided and the legacy behavior takes precedence.
 The modem GPS stack uses an APN name to look up the correct data profile number
 associated with the connection and use it in policy construction. \n
 Valid bitmask: \n
      - QMI_LOC_APN_TYPE_MASK_DEFAULT (0x0000000000000001) --  APN type for default/Internet traffic\n
      - QMI_LOC_APN_TYPE_MASK_IMS (0x0000000000000002) --  APN type for IP Multimedia Subsystem \n
      - QMI_LOC_APN_TYPE_MASK_MMS (0x0000000000000004) --  APN type for multimedia messaging service \n
      - QMI_LOC_APN_TYPE_MASK_DUN (0x0000000000000008) --  APN type for dial up network
      - QMI_LOC_APN_TYPE_MASK_SUPL (0x0000000000000010) --  APN type for secure user plane location \n
      - QMI_LOC_APN_TYPE_MASK_HIPRI (0x0000000000000020) --   APN type for high priority mobile data \n
      - QMI_LOC_APN_TYPE_MASK_FOTA (0x0000000000000040) --   APN type for over the air administration \n
      - QMI_LOC_APN_TYPE_MASK_CBS (0x0000000000000080) --   APN type for carrier branded services \n
      - QMI_LOC_APN_TYPE_MASK_IA (0x0000000000000100) --  APN type for initial attach \n
      - QMI_LOC_APN_TYPE_MASK_EMERGENCY (0x0000000000000200) --  APN type for emergency
 */
}qmiLocInformLocationServerConnStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inform the service about the
                    status of the location server connection request that the
                    service might have sent via the
                    QMI_LOC_EVENT_LOCATION_SERVER_CONNECTION_REQ_IND event. */
typedef struct {

  /* Mandatory */
  /*  Status of Inform Loc Server Conn Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inform Location Server Connection Status request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInformLocationServerConnStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCVXVERSIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_VX_VERSION_V1_ONLY_V02 = 1, /**<  V1 VX version \n */
  eQMI_LOC_VX_VERSION_V2_ONLY_V02 = 2, /**<  V2 VX version  */
  QMILOCVXVERSIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocVxVersionEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSUPLVERSIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUPL_VERSION_1_0_V02 = 1, /**<  SUPL version 1.0 \n  */
  eQMI_LOC_SUPL_VERSION_2_0_V02 = 2, /**<  SUPL version 2.0 \n  */
  eQMI_LOC_SUPL_VERSION_2_0_2_V02 = 3, /**<  SUPL version 2.0.2 \n  */
  eQMI_LOC_SUPL_VERSION_2_0_4_V02 = 4, /**<  SUPL version 2.0.4  */
  QMILOCSUPLVERSIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSuplVersionEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocLppConfigMaskT_v02;
#define QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE_V02 ((qmiLocLppConfigMaskT_v02)0x00000001) /**<  Enable user plane configuration for LTE Positioning Profile (LPP) \n  */
#define QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE_V02 ((qmiLocLppConfigMaskT_v02)0x00000002) /**<  Enable control plane configuration for LPP \n  */
#define QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE_OVER_NR5G_SA_V02 ((qmiLocLppConfigMaskT_v02)0x00000004) /**<  Enable user plane configuration for NR5G (LPP) \n  */
#define QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE_OVER_NR5G_SA_V02 ((qmiLocLppConfigMaskT_v02)0x00000008) /**<  Enable control plane configuration for NR5G (LPP)  */
typedef uint32_t qmiLocAssistedGlonassProtocolMaskT_v02;
#define QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRC_CP_V02 ((qmiLocAssistedGlonassProtocolMaskT_v02)0x00000001) /**<  Assisted GLONASS is supported over RRC in the control plane \n */
#define QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRLP_UP_V02 ((qmiLocAssistedGlonassProtocolMaskT_v02)0x00000002) /**<  Assisted GLONASS is supported over RRLP in the user plane \n  */
#define QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_UP_V02 ((qmiLocAssistedGlonassProtocolMaskT_v02)0x00000004) /**<  Assisted GLONASS is supported over LPP in the user plane;
       QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE must be set
       in the LPP configuration for this to take effect \n */
#define QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_CP_V02 ((qmiLocAssistedGlonassProtocolMaskT_v02)0x00000008) /**<  Assisted GLONASS is supported over LPP in the control plane;
       QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE must be set
       in the LPP configuration for this to take effect  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSUPLHASHALGOENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUPL_HASH_ALGO_SHA1_V02 = 0, /**<  SHA-1 hash algorithm for SUPL version 2.0 or later \n */
  eQMI_LOC_SUPL_HASH_ALGO_SHA256_V02 = 1, /**<  SHA-256 hash algorithm for SUPL version 2.0 or later  */
  QMILOCSUPLHASHALGOENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSuplHashAlgoEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSUPLTLSVERSIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUPL_TLS_VERSION_1_0_V02 = 0, /**<  SUPL TLS version 1.0 \n  */
  eQMI_LOC_SUPL_TLS_VERSION_1_1_V02 = 1, /**<  SUPL TLS version 1.1 \n  */
  eQMI_LOC_SUPL_TLS_VERSION_1_2_V02 = 2, /**<  SUPL TLS version 1.2  */
  QMILOCSUPLTLSVERSIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSuplTlsVersionEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCEMERGENCYPROTOCOLENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_CP_V02 = 0, /**<  Use Control Plane Protocol during an emergency while on WCDMA \n */
  eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_UP_V02 = 1, /**<  Use SUPL 2.0 emergency services during an emergency while on WCDMA  */
  QMILOCEMERGENCYPROTOCOLENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocEmergencyProtocolEnumT_v02;
/**
    @}
  */

typedef uint64_t qmiLocLppeUpAuxTechMaskT_v02;
#define QMI_LOC_LPPE_MASK_UP_DBH_V02 ((qmiLocLppeUpAuxTechMaskT_v02)0x00000001ull) /**<  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe user plane. \n */
#define QMI_LOC_LPPE_MASK_UP_AP_WIFI_MEASUREMENT_V02 ((qmiLocLppeUpAuxTechMaskT_v02)0x00000002ull) /**<  Enable WLAN AP Measurement mode on the LPPe user plane.\n  */
#define QMI_LOC_LPPE_MASK_UP_AP_SRN_BTLE_MEASUREMENT_V02 ((qmiLocLppeUpAuxTechMaskT_v02)0x00000004ull) /**<  Enable SRN BTLE Measurement mode on the LPPe user plane.\n  */
#define QMI_LOC_LPPE_MASK_UP_UBP_V02 ((qmiLocLppeUpAuxTechMaskT_v02)0x00000008ull) /**<  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.  */
typedef uint64_t qmiLocLppeCpAuxTechMaskT_v02;
#define QMI_LOC_LPPE_MASK_CP_DBH_V02 ((qmiLocLppeCpAuxTechMaskT_v02)0x00000001ull) /**<  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe control plane.\n  */
#define QMI_LOC_LPPE_MASK_CP_AP_WIFI_MEASUREMENT_V02 ((qmiLocLppeCpAuxTechMaskT_v02)0x00000002ull) /**<  Enable WLAN AP Measurement mode on the LPPe control plane. \n */
#define QMI_LOC_LPPE_MASK_CP_AP_SRN_BTLE_MEASUREMENT_V02 ((qmiLocLppeCpAuxTechMaskT_v02)0x00000004ull) /**<  Enable SRN BTLE Measurement mode on the LPPe user plane. \n */
#define QMI_LOC_LPPE_MASK_CP_UBP_V02 ((qmiLocLppeCpAuxTechMaskT_v02)0x00000008ull) /**<  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to configure parameters stored
                    in the nonvolatile memory. */
typedef struct {

  /* Optional */
  /*  SUPL Security */
  uint8_t suplSecurity_valid;  /**< Must be set to true if suplSecurity is being passed */
  uint8_t suplSecurity;
  /**<   Indicates whether SUPL security is enabled. \n
       - 0x01 (TRUE) -- SUPL security is enabled \n
       - 0x00 (FALSE) -- SUPL security is disabled
        */

  /* Optional */
  /*  VX Version */
  uint8_t vxVersion_valid;  /**< Must be set to true if vxVersion is being passed */
  qmiLocVxVersionEnumT_v02 vxVersion;
  /**<   VX version.
 Values: \n
      - eQMI_LOC_VX_VERSION_V1_ONLY (1) --  V1 VX version \n
      - eQMI_LOC_VX_VERSION_V2_ONLY (2) --  V2 VX version
 */

  /* Optional */
  /*  SUPL Version */
  uint8_t suplVersion_valid;  /**< Must be set to true if suplVersion is being passed */
  qmiLocSuplVersionEnumT_v02 suplVersion;
  /**<   SUPL version.
 Values: \n
      - eQMI_LOC_SUPL_VERSION_1_0 (1) --  SUPL version 1.0 \n
      - eQMI_LOC_SUPL_VERSION_2_0 (2) --  SUPL version 2.0 \n
      - eQMI_LOC_SUPL_VERSION_2_0_2 (3) --  SUPL version 2.0.2 \n
      - eQMI_LOC_SUPL_VERSION_2_0_4 (4) --  SUPL version 2.0.4
 */

  /* Optional */
  /*  LPP Configuration */
  uint8_t lppConfig_valid;  /**< Must be set to true if lppConfig is being passed */
  qmiLocLppConfigMaskT_v02 lppConfig;
  /**<   LTE Positioning Protocol (LPP) configuration; allows use of LPP
 as an assisted GNSS positioning (AGNSS) protocol over different communication layers
 such as LTE and NR user plane and control plane.

 If LPP is enabled on a LTE or NR, LPP is the preferred AGNSS protcol over
 other AGNSS protocols such as RRLP on the respective communication layer.

 To use other AGNSS protocols such as RRLP over LTE and NR, this configuration must be
 turned off. In addition, the appropriate NV items to enable RRLP must be set.

 Refer to \hyperref[80ND1841]{80-ND184-1}, \hyperref[80YA5181]{80-YA518-1} and \hyperref[80VU9051]{80-VU905-1} for more details.
 Valid bitmasks: \n
      - QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE (0x00000001) --  Enable user plane configuration for LTE Positioning Profile (LPP) \n
      - QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE (0x00000002) --  Enable control plane configuration for LPP \n
      - QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE_OVER_NR5G_SA (0x00000004) --  Enable user plane configuration for NR5G (LPP) \n
      - QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE_OVER_NR5G_SA (0x00000008) --  Enable control plane configuration for NR5G (LPP)
 */

  /* Optional */
  /*  Assisted GLONASS Protocol Mask */
  uint8_t assistedGlonassProtocolMask_valid;  /**< Must be set to true if assistedGlonassProtocolMask is being passed */
  qmiLocAssistedGlonassProtocolMaskT_v02 assistedGlonassProtocolMask;
  /**<   Configures the protocols that the location service supports
 for assisted GLONASS.
 Valid bitmasks: \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRC_CP (0x00000001) --  Assisted GLONASS is supported over RRC in the control plane \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRLP_UP (0x00000002) --  Assisted GLONASS is supported over RRLP in the user plane \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_UP (0x00000004) --  Assisted GLONASS is supported over LPP in the user plane;
       QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE must be set
       in the LPP configuration for this to take effect \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_CP (0x00000008) --  Assisted GLONASS is supported over LPP in the control plane;
       QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE must be set
       in the LPP configuration for this to take effect
 */

  /* Optional */
  /*  SUPL Hash Algorithm */
  uint8_t suplHashAlgo_valid;  /**< Must be set to true if suplHashAlgo is being passed */
  qmiLocSuplHashAlgoEnumT_v02 suplHashAlgo;
  /**<   SUPL hash algorithm to use.
 Values: \n
      - eQMI_LOC_SUPL_HASH_ALGO_SHA1 (0) --  SHA-1 hash algorithm for SUPL version 2.0 or later \n
      - eQMI_LOC_SUPL_HASH_ALGO_SHA256 (1) --  SHA-256 hash algorithm for SUPL version 2.0 or later
 */

  /* Optional */
  /*  SUPL TLS Version */
  uint8_t suplTlsVersion_valid;  /**< Must be set to true if suplTlsVersion is being passed */
  qmiLocSuplTlsVersionEnumT_v02 suplTlsVersion;
  /**<   SUPL Transport Layer Security (TLS) version. This configuration is only
 applicable to SUPL 2.0 or later, as SUPL 1.0 always uses TLS version 1.0.
 Values: \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_0 (0) --  SUPL TLS version 1.0 \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_1 (1) --  SUPL TLS version 1.1 \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_2 (2) --  SUPL TLS version 1.2
 */

  /* Optional */
  /*  Emergency Protocol */
  uint8_t emergencyProtocol_valid;  /**< Must be set to true if emergencyProtocol is being passed */
  qmiLocEmergencyProtocolEnumT_v02 emergencyProtocol;
  /**<   Configures the protocol use during an emergency. \n
 Note: This can only be selected on WCDMA. For GSM
 and 1X, the UE only allows a control plane NI trigger for positioning.
 For LTE, the UE allows either a SUPL or a control plane NI trigger.
 Values: \n
      - eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_CP (0) --  Use Control Plane Protocol during an emergency while on WCDMA \n
      - eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_UP (1) --  Use SUPL 2.0 emergency services during an emergency while on WCDMA
 */

  /* Optional */
  /*  Wi-Fi Scan Injection Timeout Period */
  uint8_t wifiScanInjectTimeout_valid;  /**< Must be set to true if wifiScanInjectTimeout is being passed */
  uint8_t wifiScanInjectTimeout;
  /**<   Configures the timeout duration that the service waits for scan results
       injection from the control point after the event notification is sent. \n
       Values: 0 to 10 seconds

       The minimum value (0 seconds) is the default. At this value, the service
       disables sending the Wi-Fi scan injection notification and ignores any
       scan results injection request.
  */

  /* Optional */
  /*  LPPe User Plane Configure */
  uint8_t lppeUpConfig_valid;  /**< Must be set to true if lppeUpConfig is being passed */
  qmiLocLppeUpAuxTechMaskT_v02 lppeUpConfig;
  /**<   LPPe user plane auxiliary technology mask.
 Valid bitmasks: \n
      - QMI_LOC_LPPE_MASK_UP_DBH (0x00000001) --  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe user plane. \n
      - QMI_LOC_LPPE_MASK_UP_AP_WIFI_MEASUREMENT (0x00000002) --  Enable WLAN AP Measurement mode on the LPPe user plane.\n
      - QMI_LOC_LPPE_MASK_UP_AP_SRN_BTLE_MEASUREMENT (0x00000004) --  Enable SRN BTLE Measurement mode on the LPPe user plane.\n
      - QMI_LOC_LPPE_MASK_UP_UBP (0x00000008) --  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.
 */

  /* Optional */
  /*  LPPe Control Plane Configure */
  uint8_t lppeCpConfig_valid;  /**< Must be set to true if lppeCpConfig is being passed */
  qmiLocLppeCpAuxTechMaskT_v02 lppeCpConfig;
  /**<   LPPe control plane auxiliary technology mask.
 Valid bitmasks: \n
      - QMI_LOC_LPPE_MASK_CP_DBH (0x00000001) --  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe control plane.\n
      - QMI_LOC_LPPE_MASK_CP_AP_WIFI_MEASUREMENT (0x00000002) --  Enable WLAN AP Measurement mode on the LPPe control plane. \n
      - QMI_LOC_LPPE_MASK_CP_AP_SRN_BTLE_MEASUREMENT (0x00000004) --  Enable SRN BTLE Measurement mode on the LPPe user plane. \n
      - QMI_LOC_LPPE_MASK_CP_UBP (0x00000008) --  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.
 */

  /* Optional */
  /*  Emergency Callback Window */
  uint8_t emergencyCallbackWindow_valid;  /**< Must be set to true if emergencyCallbackWindow is being passed */
  uint32_t emergencyCallbackWindow;
  /**<    The emergency callback window extends the period of time
        during which eQMI_LOC_LOCK_MT is ignored.\n
       - Units -- Seconds \n
       - Default -- 0 seconds
  */
}qmiLocSetProtocolConfigParametersReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocProtocolConfigParamMaskT_v02;
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_SECURITY_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000001ull) /**<  Mask for the SUPL security configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_VX_VERSION_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000002ull) /**<  Mask for the VX version configuration parameter \n  */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_VERSION_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000004ull) /**<  Mask for the SUPL version configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPP_CONFIG_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000008ull) /**<  Mask for the LPP configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_ASSISTED_GLONASS_PROTOCOL_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000010ull) /**<  Mask for the assisted GLONASS configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_HASH_ALGO_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000020ull) /**<  Mask for the SUPL hash algorithm configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_TLS_VERSION_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000040ull) /**<  Mask for the SUPL TLS version configuration parameter \n  */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_PROTOCOL_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000080ull) /**<  Mask for the emergency protocol configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_WIFI_SCAN_INJECT_TIMEOUT_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000100ull) /**<  Mask for the Wi-Fi scan injection timeout configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_UP_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000200ull) /**<  Mask for the LPPe user plane configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_CP_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000400ull) /**<  Mask for the LPPe control plane configuration parameter \n */
#define QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_CB_WINDOW_V02 ((qmiLocProtocolConfigParamMaskT_v02)0x0000000000000800ull) /**<  Mask for the emergency callback window configuration parameter  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to configure parameters stored
                    in the nonvolatile memory. */
typedef struct {

  /* Mandatory */
  /*  Set Config Params Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Configuration Parameters request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Failed Parameters */
  uint8_t failedProtocolConfigParamMask_valid;  /**< Must be set to true if failedProtocolConfigParamMask is being passed */
  qmiLocProtocolConfigParamMaskT_v02 failedProtocolConfigParamMask;
  /**<   Identifies parameters that were not set successfully. This field
 is sent only if the status is not SUCCESS.
 Valid bitmasks: \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_SECURITY (0x0000000000000001) --  Mask for the SUPL security configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_VX_VERSION (0x0000000000000002) --  Mask for the VX version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_VERSION (0x0000000000000004) --  Mask for the SUPL version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPP_CONFIG (0x0000000000000008) --  Mask for the LPP configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_ASSISTED_GLONASS_PROTOCOL (0x0000000000000010) --  Mask for the assisted GLONASS configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_HASH_ALGO (0x0000000000000020) --  Mask for the SUPL hash algorithm configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_TLS_VERSION (0x0000000000000040) --  Mask for the SUPL TLS version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_PROTOCOL (0x0000000000000080) --  Mask for the emergency protocol configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_WIFI_SCAN_INJECT_TIMEOUT (0x0000000000000100) --  Mask for the Wi-Fi scan injection timeout configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_UP (0x0000000000000200) --  Mask for the LPPe user plane configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_CP (0x0000000000000400) --  Mask for the LPPe control plane configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_CB_WINDOW (0x0000000000000800) --  Mask for the emergency callback window configuration parameter
 */
}qmiLocSetProtocolConfigParametersIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the configuration
                    parameters stored in the nonvolatile memory. */
typedef struct {

  /* Mandatory */
  /*  Config Parameters */
  qmiLocProtocolConfigParamMaskT_v02 getProtocolConfigParamMask;
  /**<   Mask denoting the configuration parameters to retrieve.
 Valid bitmasks: \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_SECURITY (0x0000000000000001) --  Mask for the SUPL security configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_VX_VERSION (0x0000000000000002) --  Mask for the VX version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_VERSION (0x0000000000000004) --  Mask for the SUPL version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPP_CONFIG (0x0000000000000008) --  Mask for the LPP configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_ASSISTED_GLONASS_PROTOCOL (0x0000000000000010) --  Mask for the assisted GLONASS configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_HASH_ALGO (0x0000000000000020) --  Mask for the SUPL hash algorithm configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_SUPL_TLS_VERSION (0x0000000000000040) --  Mask for the SUPL TLS version configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_PROTOCOL (0x0000000000000080) --  Mask for the emergency protocol configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_WIFI_SCAN_INJECT_TIMEOUT (0x0000000000000100) --  Mask for the Wi-Fi scan injection timeout configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_UP (0x0000000000000200) --  Mask for the LPPe user plane configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_LPPE_CP (0x0000000000000400) --  Mask for the LPPe control plane configuration parameter \n
      - QMI_LOC_PROTOCOL_CONFIG_PARAM_MASK_EMERGENCY_CB_WINDOW (0x0000000000000800) --  Mask for the emergency callback window configuration parameter
 */
}qmiLocGetProtocolConfigParametersReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the configuration
                    parameters stored in the nonvolatile memory. */
typedef struct {

  /* Mandatory */
  /*  Get Config Params Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Configuration Parameters request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  SUPL Security */
  uint8_t suplSecurity_valid;  /**< Must be set to true if suplSecurity is being passed */
  uint8_t suplSecurity;
  /**<   Indicates whether SUPL security is enabled.\n
       - 0x01 (TRUE) -- Enabled
    */

  /* Optional */
  /*  VX Version */
  uint8_t vxVersion_valid;  /**< Must be set to true if vxVersion is being passed */
  qmiLocVxVersionEnumT_v02 vxVersion;
  /**<   VX version.
 Values: \n
      - eQMI_LOC_VX_VERSION_V1_ONLY (1) --  V1 VX version \n
      - eQMI_LOC_VX_VERSION_V2_ONLY (2) --  V2 VX version
 */

  /* Optional */
  /*  SUPL Version */
  uint8_t suplVersion_valid;  /**< Must be set to true if suplVersion is being passed */
  qmiLocSuplVersionEnumT_v02 suplVersion;
  /**<   SUPL version.
 Values: \n
      - eQMI_LOC_SUPL_VERSION_1_0 (1) --  SUPL version 1.0 \n
      - eQMI_LOC_SUPL_VERSION_2_0 (2) --  SUPL version 2.0 \n
      - eQMI_LOC_SUPL_VERSION_2_0_2 (3) --  SUPL version 2.0.2 \n
      - eQMI_LOC_SUPL_VERSION_2_0_4 (4) --  SUPL version 2.0.4
 */

  /* Optional */
  /*  LPP Configuration */
  uint8_t lppConfig_valid;  /**< Must be set to true if lppConfig is being passed */
  qmiLocLppConfigMaskT_v02 lppConfig;
  /**<   LTE Positioning Profile (LPP) configuration. \n
       - 0x00000001 -- LPP_CONFIG_ ENABLE_USER_PLANE \n
       - 0x00000002 -- LPP_CONFIG_ ENABLE_CONTROL_PLANE
     */

  /* Optional */
  /*  Assisted GLONASS Protocol Mask */
  uint8_t assistedGlonassProtocolMask_valid;  /**< Must be set to true if assistedGlonassProtocolMask is being passed */
  qmiLocAssistedGlonassProtocolMaskT_v02 assistedGlonassProtocolMask;
  /**<   Assisted GLONASS protocol mask.
 Valid bitmasks: \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRC_CP (0x00000001) --  Assisted GLONASS is supported over RRC in the control plane \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_RRLP_UP (0x00000002) --  Assisted GLONASS is supported over RRLP in the user plane \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_UP (0x00000004) --  Assisted GLONASS is supported over LPP in the user plane;
       QMI_LOC_LPP_CONFIG_ENABLE_USER_PLANE must be set
       in the LPP configuration for this to take effect \n
      - QMI_LOC_ASSISTED_GLONASS_PROTOCOL_MASK_LPP_CP (0x00000008) --  Assisted GLONASS is supported over LPP in the control plane;
       QMI_LOC_LPP_CONFIG_ENABLE_CONTROL_PLANE must be set
       in the LPP configuration for this to take effect
 */

  /* Optional */
  /*  SUPL Hash Algorithm */
  uint8_t suplHashAlgo_valid;  /**< Must be set to true if suplHashAlgo is being passed */
  qmiLocSuplHashAlgoEnumT_v02 suplHashAlgo;
  /**<   SUPL hash algorithm to use.
 Values: \n
      - eQMI_LOC_SUPL_HASH_ALGO_SHA1 (0) --  SHA-1 hash algorithm for SUPL version 2.0 or later \n
      - eQMI_LOC_SUPL_HASH_ALGO_SHA256 (1) --  SHA-256 hash algorithm for SUPL version 2.0 or later
 */

  /* Optional */
  /*  SUPL TLS Version */
  uint8_t suplTlsVersion_valid;  /**< Must be set to true if suplTlsVersion is being passed */
  qmiLocSuplTlsVersionEnumT_v02 suplTlsVersion;
  /**<   SUPL TLS version. This configuration is only
 applicable to SUPL 2.0 or later, as SUPL 1.0 always uses TLS version 1.0.
 Values: \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_0 (0) --  SUPL TLS version 1.0 \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_1 (1) --  SUPL TLS version 1.1 \n
      - eQMI_LOC_SUPL_TLS_VERSION_1_2 (2) --  SUPL TLS version 1.2
 */

  /* Optional */
  /*  Emergency Protocol */
  uint8_t emergencyProtocol_valid;  /**< Must be set to true if emergencyProtocol is being passed */
  qmiLocEmergencyProtocolEnumT_v02 emergencyProtocol;
  /**<   Protocol to use during emergency.
 Values: \n
      - eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_CP (0) --  Use Control Plane Protocol during an emergency while on WCDMA \n
      - eQMI_LOC_EMERGENCY_PROTOCOL_WCDMA_UP (1) --  Use SUPL 2.0 emergency services during an emergency while on WCDMA
 */

  /* Optional */
  /*  Wi-Fi Scan Injection Timeout Period */
  uint8_t wifiScanInjectTimeout_valid;  /**< Must be set to true if wifiScanInjectTimeout is being passed */
  uint8_t wifiScanInjectTimeout;
  /**<   Timeout duration that the service waits for a scan results
       injection from the control point after the event notification is sent. \n
       Values: \n
       0 to 10 seconds
  */

  /* Optional */
  /*  LPPe User Plane Configure */
  uint8_t lppeUpConfig_valid;  /**< Must be set to true if lppeUpConfig is being passed */
  qmiLocLppeUpAuxTechMaskT_v02 lppeUpConfig;
  /**<   LPPe user plane auxiliary technology mask.
 Valid bitmasks: \n
      - QMI_LOC_LPPE_MASK_UP_DBH (0x00000001) --  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe user plane. \n
      - QMI_LOC_LPPE_MASK_UP_AP_WIFI_MEASUREMENT (0x00000002) --  Enable WLAN AP Measurement mode on the LPPe user plane.\n
      - QMI_LOC_LPPE_MASK_UP_AP_SRN_BTLE_MEASUREMENT (0x00000004) --  Enable SRN BTLE Measurement mode on the LPPe user plane.\n
      - QMI_LOC_LPPE_MASK_UP_UBP (0x00000008) --  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.
 */

  /* Optional */
  /*  LPPe Control Plane Configure */
  uint8_t lppeCpConfig_valid;  /**< Must be set to true if lppeCpConfig is being passed */
  qmiLocLppeCpAuxTechMaskT_v02 lppeCpConfig;
  /**<   LPPe control plane auxiliary technology mask.
 Valid bitmasks: \n
      - QMI_LOC_LPPE_MASK_CP_DBH (0x00000001) --  Enable Device-Based Hybrid (3D High Accuracy Position) mode on the LPPe control plane.\n
      - QMI_LOC_LPPE_MASK_CP_AP_WIFI_MEASUREMENT (0x00000002) --  Enable WLAN AP Measurement mode on the LPPe control plane. \n
      - QMI_LOC_LPPE_MASK_CP_AP_SRN_BTLE_MEASUREMENT (0x00000004) --  Enable SRN BTLE Measurement mode on the LPPe user plane. \n
      - QMI_LOC_LPPE_MASK_CP_UBP (0x00000008) --  Enable the Uncompromised Barometer Pressure Measurement mode on the LPPe user plane.
 */

  /* Optional */
  /*  Emergency Callback Window */
  uint8_t emergencyCallbackWindow_valid;  /**< Must be set to true if emergencyCallbackWindow is being passed */
  uint32_t emergencyCallbackWindow;
  /**<     The emergency callback window extends the period of time
         during which MT LOCK is ignored.
        - Units -- Seconds
        - Default -- 0 seconds
  */
}qmiLocGetProtocolConfigParametersIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSENSORSCONTROLCONFIGSENSORUSEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_ENABLE_V02 = 0, /**<  Request sensors data whenever a position request is
       received. If sensor data are injected, the positioning engine
       attempts to improve the heading and positioning performance using sensors.
       This is the default.\n
  */
  eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_DISABLE_V02 = 1, /**<  Do not use inertial sensors to aid heading and position
       improvement.  */
  QMILOCSENSORSCONTROLCONFIGSENSORUSEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSensorsControlConfigSensorUseEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSENSORSCONTROLCONFIGSENSORPROVIDERENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_SSC_V02 = 0, /**<  Sensors data provider is Snapdragon Sensor Core (SSC) (default) \n
   */
  eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_NATIVE_V02 = 1, /**<  Sensors data provider is on the host processor  */
  QMILOCSENSORSCONTROLCONFIGSENSORPROVIDERENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSensorsControlConfigSensorProviderEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the sensor control configuration. */
typedef struct {

  /* Optional */
  /*  Sensors Usage */
  uint8_t sensorsUsage_valid;  /**< Must be set to true if sensorsUsage is being passed */
  qmiLocSensorsControlConfigSensorUseEnumT_v02 sensorsUsage;
  /**<   Controls how sensors are used to aid heading and positioning
 performance.
 Values: \n
      - eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_ENABLE (0) --  Request sensors data whenever a position request is
       received. If sensor data are injected, the positioning engine
       attempts to improve the heading and positioning performance using sensors.
       This is the default.\n

      - eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_DISABLE (1) --  Do not use inertial sensors to aid heading and position
       improvement.
 */

  /* Optional */
  /*  Sensors Provider */
  uint8_t sensorProvider_valid;  /**< Must be set to true if sensorProvider is being passed */
  qmiLocSensorsControlConfigSensorProviderEnumT_v02 sensorProvider;
  /**<   Controls which sensors data provider to use.
 Values: \n
      - eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_SSC (0) --  Sensors data provider is Snapdragon Sensor Core (SSC) (default) \n

      - eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_NATIVE (1) --  Sensors data provider is on the host processor
 */
}qmiLocSetSensorControlConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the sensor control configuration. */
typedef struct {

  /* Mandatory */
  /*  Set Sensor Control Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Sensor Control Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetSensorControlConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Retrieves the current sensor control configuration. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetSensorControlConfigReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Retrieves the current sensor control configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Sensor Control Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Sensors Control Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Sensors Usage */
  uint8_t sensorsUsage_valid;  /**< Must be set to true if sensorsUsage is being passed */
  qmiLocSensorsControlConfigSensorUseEnumT_v02 sensorsUsage;
  /**<   Controls how sensors are used to aid the heading and positioning
 performance.
 Values: \n
      - eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_ENABLE (0) --  Request sensors data whenever a position request is
       received. If sensor data are injected, the positioning engine
       attempts to improve the heading and positioning performance using sensors.
       This is the default.\n

      - eQMI_LOC_SENSOR_CONFIG_SENSOR_USE_DISABLE (1) --  Do not use inertial sensors to aid heading and position
       improvement.
 */

  /* Optional */
  /*  Sensors Provider */
  uint8_t sensorProvider_valid;  /**< Must be set to true if sensorProvider is being passed */
  qmiLocSensorsControlConfigSensorProviderEnumT_v02 sensorProvider;
  /**<   Controls which sensors data provider to use.
 Values: \n
      - eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_SSC (0) --  Sensors data provider is Snapdragon Sensor Core (SSC) (default) \n

      - eQMI_LOC_SENSOR_CONFIG_USE_PROVIDER_NATIVE (1) --  Sensors data provider is on the host processor
 */
}qmiLocGetSensorControlConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocSensorPropertiesMaskT_v02;
#define QMI_LOC_SENSOR_PROPERTIES_MASK_GYRO_BIAS_VARIANCE_RANDOM_WALK_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000001) /**<  Gyro bias variance random walk parameter \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000002) /**<  Velocity random walk spectral density parameter \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_ACCELERATION_RANDOM_WALK_SPECTRAL_DENSITY_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000004) /**<  Acceleration random walk spectral density parameter \n */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_ANGLE_RANDOM_WALK_SPECTRAL_DENSITY_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000008) /**<  Angle random walk spectral density parameter \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_RATE_RANDOM_WALK_SPECTRAL_DENSITY_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000010) /**<  Random walk spectral density parameter \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_DATA_USE_CONTROL_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000020) /**<  Vehicle data use control parameter \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_VELOCITY_RWSD_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000040) /**<  Vehicle velocity random walk spectral density \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ACCEL_RWSD_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000080) /**<  Vehicle accelerometer random walk spectral density \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGLE_RWSD_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000100) /**<  Vehicle angle random walk spectral density \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGULAR_RATE_RWSD_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000200) /**<  Vehicle angular rate random walk spectral density \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_SCALE_RWSD_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000400) /**<  Vehicle odometry scale random walk spectral density \n  */
#define QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_VARIANCE_V02 ((qmiLocSensorPropertiesMaskT_v02)0x00000800) /**<  Vehicle odometry variance   */
typedef uint64_t qmiLocVehicleDataUseControlMaskT_v02;
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_X_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000001ull) /**<  X-axis vehicle acceleration sensor data \n  */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Y_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000002ull) /**<  Y-axis vehicle acceleration sensor data \n */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Z_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000004ull) /**<  Z-axis vehicle acceleration sensor data \n */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_X_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000010ull) /**<  X-axis vehicle gyroscope data \n */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Y_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000020ull) /**<   Y-axis vehicle gyroscope data \n */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Z_AXIS_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000040ull) /**<  Z-axis vehicle gyroscope data \n */
#define QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ODOMETRY_V02 ((qmiLocVehicleDataUseControlMaskT_v02)0x0000000000000100ull) /**<  Odometry data  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the properties specific to the type of sensor used.
                    The control point must set sensor properties before using them
                    to aid in heading and positioning performance improvement.
   */
typedef struct {

  /* Optional */
  /*  Gyro Bias Random Walk Variance */
  uint8_t gyroBiasVarianceRandomWalk_valid;  /**< Must be set to true if gyroBiasVarianceRandomWalk is being passed */
  float gyroBiasVarianceRandomWalk;
  /**<   Specifies the gyro bias random walk variance parameter as a positive
       floating-point value. This value has internal default value 1.0e-5 radian^2/second^4.
       The gyro bias variance random walk parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians^2 per seconds^4
  */

  /* Optional */
  /*  Velocity Random Walk Spectral Density */
  uint8_t velocityRandomWalkSpectralDensity_valid;  /**< Must be set to true if velocityRandomWalkSpectralDensity is being passed */
  float velocityRandomWalkSpectralDensity;
  /**<   Specifies the velocity random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The velocity random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Meters per seconds^2 per Hz^0.5
  */

  /* Optional */
  /*  Acceleration Random Walk Spectral Density */
  uint8_t accelerationRandomWalkSpectralDensity_valid;  /**< Must be set to true if accelerationRandomWalkSpectralDensity is being passed */
  float accelerationRandomWalkSpectralDensity;
  /**<   Specifies the acceleration random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The acceleration random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Meters per seconds^3/Hz^0.5
  */

  /* Optional */
  /*  Angle Random Walk Spectral Density */
  uint8_t angleRandomWalkSpectralDensity_valid;  /**< Must be set to true if angleRandomWalkSpectralDensity is being passed */
  float angleRandomWalkSpectralDensity;
  /**<   Specifies the angle random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The angle random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians per seconds/Hz^0.5
  */

  /* Optional */
  /*  Rate Random Walk Spectral Density */
  uint8_t rateRandomWalkSpectralDensity_valid;  /**< Must be set to true if rateRandomWalkSpectralDensity is being passed */
  float rateRandomWalkSpectralDensity;
  /**<   Specifies the rate random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The rate random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians per seconds^2/Hz^0.5
  */

  /* Optional */
  /*  Vehicle Data Use Control */
  uint8_t vehicleDataUse_valid;  /**< Must be set to true if vehicleDataUse is being passed */
  qmiLocVehicleDataUseControlMaskT_v02 vehicleDataUse;
  /**<   Identifies which portions of the vehicle data to use in location
 estimation (information provided by the
 QMI_LOC_INJECT_VEHICLE_SENSOR_DATA message). Valid bitmasks: \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_X_AXIS (0x0000000000000001) --  X-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Y_AXIS (0x0000000000000002) --  Y-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Z_AXIS (0x0000000000000004) --  Z-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_X_AXIS (0x0000000000000010) --  X-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Y_AXIS (0x0000000000000020) --   Y-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Z_AXIS (0x0000000000000040) --  Z-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ODOMETRY (0x0000000000000100) --  Odometry data
 @note All other bits are reserved for future use and must be set to 0. */

  /* Optional */
  /*  Vehicle Velocity Random Walk Spectral Density */
  uint8_t vehicleVelocityRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleVelocityRandomWalkSpectralDensity is being passed */
  float vehicleVelocityRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Meters per second^2/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Acceleration Random Walk Spectral Density */
  uint8_t vehicleAccelRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAccelRandomWalkSpectralDensity is being passed */
  float vehicleAccelRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Meters per second^3/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Angle Random Walk Spectral Density */
  uint8_t vehicleAngleRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAngleRandomWalkSpectralDensity is being passed */
  float vehicleAngleRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Radians per second/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Angular Rate Random Walk Spectral Density */
  uint8_t vehicleAngularRateRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAngularRateRandomWalkSpectralDensity is being passed */
  float vehicleAngularRateRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Radians per second^2/Hz^0.5 \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Odometry Scale Factor Random Walk Spectral Density */
  uint8_t vehicleOdometryScaleFactorRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleOdometryScaleFactorRandomWalkSpectralDensity is being passed */
  float vehicleOdometryScaleFactorRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- (1/second)/Hz^0.5      \n
       - Range -- Approximately 0.0001 to 0.001 \n
       - Default -- 0.001 (actual calibration recommended)
  */

  /* Optional */
  /*  Vehicle Odometry Variance */
  uint8_t vehicleOdometryVariance_valid;  /**< Must be set to true if vehicleOdometryVariance is being passed */
  float vehicleOdometryVariance;
  /**<   Vehicle odometry variance of each odometry sample
      (coarseness of measurement). \n
       - Type -- 32-bit float    \n
       - Units -- Meters^2    \n
       - Valid values -- Positive values  \n
       - Default -- None
  */
}qmiLocSetSensorPropertiesReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the properties specific to the type of sensor used.
                    The control point must set sensor properties before using them
                    to aid in heading and positioning performance improvement.
   */
typedef struct {

  /* Mandatory */
  /*  Set Sensor Properties Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Sensor Properties request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Failed Set Sensor Properties */
  uint8_t failedSensorPropertiesMask_valid;  /**< Must be set to true if failedSensorPropertiesMask is being passed */
  qmiLocSensorPropertiesMaskT_v02 failedSensorPropertiesMask;
  /**<   This field is sent only if the status is not SUCCESS.
 Identifies the parameters not set successfully.
 Valid bitmasks:\n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_GYRO_BIAS_VARIANCE_RANDOM_WALK (0x00000001) --  Gyro bias variance random walk parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY (0x00000002) --  Velocity random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_ACCELERATION_RANDOM_WALK_SPECTRAL_DENSITY (0x00000004) --  Acceleration random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_ANGLE_RANDOM_WALK_SPECTRAL_DENSITY (0x00000008) --  Angle random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_RATE_RANDOM_WALK_SPECTRAL_DENSITY (0x00000010) --  Random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_DATA_USE_CONTROL (0x00000020) --  Vehicle data use control parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_VELOCITY_RWSD (0x00000040) --  Vehicle velocity random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ACCEL_RWSD (0x00000080) --  Vehicle accelerometer random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGLE_RWSD (0x00000100) --  Vehicle angle random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGULAR_RATE_RWSD (0x00000200) --  Vehicle angular rate random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_SCALE_RWSD (0x00000400) --  Vehicle odometry scale random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_VARIANCE (0x00000800) --  Vehicle odometry variance

 */
}qmiLocSetSensorPropertiesIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Retrieves the current sensor properties. */
typedef struct {

  /* Mandatory */
  /*  Sensor Properties Config Parameters */
  qmiLocSensorPropertiesMaskT_v02 getSensorPropertiesMask;
  /**<   Mask indicating the sensor properties parameters to retrieve.
 Valid bitmasks:
      - QMI_LOC_SENSOR_PROPERTIES_MASK_GYRO_BIAS_VARIANCE_RANDOM_WALK (0x00000001) --  Gyro bias variance random walk parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VELOCITY_RANDOM_WALK_SPECTRAL_DENSITY (0x00000002) --  Velocity random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_ACCELERATION_RANDOM_WALK_SPECTRAL_DENSITY (0x00000004) --  Acceleration random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_ANGLE_RANDOM_WALK_SPECTRAL_DENSITY (0x00000008) --  Angle random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_RATE_RANDOM_WALK_SPECTRAL_DENSITY (0x00000010) --  Random walk spectral density parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_DATA_USE_CONTROL (0x00000020) --  Vehicle data use control parameter \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_VELOCITY_RWSD (0x00000040) --  Vehicle velocity random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ACCEL_RWSD (0x00000080) --  Vehicle accelerometer random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGLE_RWSD (0x00000100) --  Vehicle angle random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ANGULAR_RATE_RWSD (0x00000200) --  Vehicle angular rate random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_SCALE_RWSD (0x00000400) --  Vehicle odometry scale random walk spectral density \n
      - QMI_LOC_SENSOR_PROPERTIES_MASK_VEHICLE_ODOMETRY_VARIANCE (0x00000800) --  Vehicle odometry variance
 */
}qmiLocGetSensorPropertiesReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Retrieves the current sensor properties. */
typedef struct {

  /* Mandatory */
  /*  Get Sensor Properties Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Sensors Properties request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Gyro Bias Random Walk Variance */
  uint8_t gyroBiasVarianceRandomWalk_valid;  /**< Must be set to true if gyroBiasVarianceRandomWalk is being passed */
  float gyroBiasVarianceRandomWalk;
  /**<   Specifies the gyro bias random walk variance parameter as a positive
       floating-point value. This value has internal default value 1.0e-5 radian^2/second^4.
       The gyro bias variance random walk parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians^2 per seconds^4
  */

  /* Optional */
  /*  Velocity Random Walk Spectral Density */
  uint8_t velocityRandomWalkSpectralDensity_valid;  /**< Must be set to true if velocityRandomWalkSpectralDensity is being passed */
  float velocityRandomWalkSpectralDensity;
  /**<   Specifies the velocity random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The velocity random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Meters per seconds^2/Hz^0.5
  */

  /* Optional */
  /*  Acceleration Random Walk Spectral Density */
  uint8_t accelerationRandomWalkSpectralDensity_valid;  /**< Must be set to true if accelerationRandomWalkSpectralDensity is being passed */
  float accelerationRandomWalkSpectralDensity;
  /**<   Specifies the acceleration random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The acceleration random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Meters per seconds^3/Hz^0.5
  */

  /* Optional */
  /*  Angle Random Walk Spectral Density */
  uint8_t angleRandomWalkSpectralDensity_valid;  /**< Must be set to true if angleRandomWalkSpectralDensity is being passed */
  float angleRandomWalkSpectralDensity;
  /**<   Specifies the angle random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The angle random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians per seconds/Hz^0.5
  */

  /* Optional */
  /*  Rate Random Walk Spectral Density */
  uint8_t rateRandomWalkSpectralDensity_valid;  /**< Must be set to true if rateRandomWalkSpectralDensity is being passed */
  float rateRandomWalkSpectralDensity;
  /**<   Specifies the rate random walk spectral density parameter as a positive
       floating-point value. This value does not have any internal defaults.
       The rate random walk spectral density parameter is derived from either the
       sensors data sheet or a sensors conformance test. \n
       - Units -- Radians per seconds^2/Hz^0.5
  */

  /* Optional */
  /*  Vehicle Data Use Control */
  uint8_t vehicleDataUse_valid;  /**< Must be set to true if vehicleDataUse is being passed */
  qmiLocVehicleDataUseControlMaskT_v02 vehicleDataUse;
  /**<   Identifies which portions of the vehicle data to use in location
 estimation (information provided by the
 QMI_LOC_INJECT_VEHICLE_SENSOR_DATA message). Valid bitmasks: \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_X_AXIS (0x0000000000000001) --  X-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Y_AXIS (0x0000000000000002) --  Y-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ACCEL_Z_AXIS (0x0000000000000004) --  Z-axis vehicle acceleration sensor data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_X_AXIS (0x0000000000000010) --  X-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Y_AXIS (0x0000000000000020) --   Y-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_GYRO_Z_AXIS (0x0000000000000040) --  Z-axis vehicle gyroscope data \n
      - QMI_LOC_VEHICLE_DATA_ENABLE_USE_MASK_ODOMETRY (0x0000000000000100) --  Odometry data
 @note All other bits are reserved for future use and must be set to 0. */

  /* Optional */
  /*  Vehicle Velocity Random Walk Spectral Density */
  uint8_t vehicleVelocityRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleVelocityRandomWalkSpectralDensity is being passed */
  float vehicleVelocityRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Meters per seconds^2/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Acceleration Random Walk Spectral Density */
  uint8_t vehicleAccelRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAccelRandomWalkSpectralDensity is being passed */
  float vehicleAccelRandomWalkSpectralDensity;
  /**<   - Type-- 32-bit float    \n
       - Units -- Meters per seconds^3/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Angle Random Walk Spectral Density */
  uint8_t vehicleAngleRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAngleRandomWalkSpectralDensity is being passed */
  float vehicleAngleRandomWalkSpectralDensity;
  /**<   Vehicle angle random walk spectral density. \n
       - Type -- 32-bit float    \n
       - Units -- Radians per seconds/Hz^0.5     \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Angular Rate Random Walk Spectral Density */
  uint8_t vehicleAngularRateRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleAngularRateRandomWalkSpectralDensity is being passed */
  float vehicleAngularRateRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- Radians per seconds^2/Hz^0.5 \n
       - Valid values -- Positive values  \n
       - Default -- None
  */

  /* Optional */
  /*  Vehicle Odometry Scale Factor Random Walk Spectral Density */
  uint8_t vehicleOdometryScaleFactorRandomWalkSpectralDensity_valid;  /**< Must be set to true if vehicleOdometryScaleFactorRandomWalkSpectralDensity is being passed */
  float vehicleOdometryScaleFactorRandomWalkSpectralDensity;
  /**<   - Type -- 32-bit float    \n
       - Units -- (1/seconds)/Hz^0.5      \n
       - Range -- Approximately 0.0001 to 0.001 \n
       - Default -- 0.001 (actual calibration recommended)
  */

  /* Optional */
  /*  Vehicle Odometry Variance */
  uint8_t vehicleOdometryVariance_valid;  /**< Must be set to true if vehicleOdometryVariance is being passed */
  float vehicleOdometryVariance;
  /**<   Vehicle odometry variance of each odometry sample
      (coarseness of measurement). \n
       - Type -- 32-bit float    \n
       - Units -- Meters^2    \n
       - Valid values -- Positive values  \n
       - Default -- None
  */
}qmiLocGetSensorPropertiesIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSENSORPERFORMANCECONTROLMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_AUTO_V02 = 0, /**<  Sensors usage is determined by the GNSS location engine.
       This mode can optimize power consumption and give a
       power-balanced positioning and heading enhancement using
       inertial sensors \n */
  eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_FORCED_V02 = 1, /**<  Sensors usage is forced ON.
       This mode can be requested by the control point when
       power consumption is not a restriction to the use of
       inertial sensors.  */
  QMILOCSENSORPERFORMANCECONTROLMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSensorPerformanceControlModeEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocSensorAlgorithmMaskT_v02;
#define QMI_LOC_SENSOR_ALGORITHM_MASK_DISABLE_INS_POSITIONING_FILTER_V02 ((qmiLocSensorAlgorithmMaskT_v02)0x00000001) /**<  Do not use inertial sensors in accelerometer-integrated fashion with
       GNSS. They can still be used for aiding in heading improvements.  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Provides fine-grained control of sensor based positioning
                    performance. */
typedef struct {

  /* Optional */
  /*  Sensor Performance Control Mode */
  uint8_t performanceControlMode_valid;  /**< Must be set to true if performanceControlMode is being passed */
  qmiLocSensorPerformanceControlModeEnumT_v02 performanceControlMode;
  /**<   Controls when sensors data is requested during GNSS fix processing.
 This field is relevant only when sensors have been enabled using the
 sensors control configuration.
 Values: \n
      - eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_AUTO (0) --  Sensors usage is determined by the GNSS location engine.
       This mode can optimize power consumption and give a
       power-balanced positioning and heading enhancement using
       inertial sensors \n
      - eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_FORCED (1) --  Sensors usage is forced ON.
       This mode can be requested by the control point when
       power consumption is not a restriction to the use of
       inertial sensors.
 */

  /* Optional */
  /*  Accelerometer Sampling Specification */
  uint8_t accelSamplingSpec_valid;  /**< Must be set to true if accelSamplingSpec is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 accelSamplingSpec;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location
       engine is to request acceleration data to use by the low data rate
       filter. The sensor data rate is specified in terms of the nominal number
       of samples per batch and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 10 Hz sampling rate and 2 Hz batching rate.
  */

  /* Optional */
  /*  Gyroscope Sampling Specification */
  uint8_t gyroSamplingSpec_valid;  /**< Must be set to true if gyroSamplingSpec is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 gyroSamplingSpec;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location
       engine is to request gyro data to use by the high data rate filter.
       The sensor data rate is specified in terms of the nominal number of
       samples per batch and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 10 Hz sampling rate and 2 Hz batching rate.
  */

  /* Optional */
  /*  Algorithm Configuration */
  uint8_t algorithmConfig_valid;  /**< Must be set to true if algorithmConfig is being passed */
  qmiLocSensorAlgorithmMaskT_v02 algorithmConfig;
  /**<   Sets which sensor algorithms to use when processing sensor data.
       Valid bitmasks: \n
       - 0x00000001 -- DISABLE_INS_ POSITIONING_FILTER
    */

  /* Optional */
  /*  High Data Rate Filter Accelerometer Sampling Specification */
  uint8_t accelSamplingSpecHigh_valid;  /**< Must be set to true if accelSamplingSpecHigh is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 accelSamplingSpecHigh;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine is to request
       acceleration data to use by the high data rate filter. The sensor
       data rate is specified in terms of the nominal number of samples per
       batch and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 100 Hz sampling rate and 4 Hz batching rate.
  */

  /* Optional */
  /*  High Data Rate Filter Gyroscope Sampling Specification */
  uint8_t gyroSamplingSpecHigh_valid;  /**< Must be set to true if gyroSamplingSpecHigh is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 gyroSamplingSpecHigh;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine is to request
       gyro data to use by the high data rate filter. The sensor data rate
       is specified in terms of the nominal number of samples per batch and the
       number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 100 Hz sampling rate and 4 Hz batching rate.
  */
}qmiLocSetSensorPerformanceControlConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocSensorPerformanceControlConfigFailureMaskT_v02;
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_PERFORMANCE_MODE_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000001) /**<  Failed to set the performance mode  */
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_ACCEL_SAMPLING_SPEC_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000002) /**<  Failed to set the accelerometer sampling specification  */
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_GYRO_SAMPLING_SPEC_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000004) /**<  Failed to set the gyroscope sampling specification  */
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_ALGORITHM_CONFIG_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000008) /**<  Failed to set the algorithm configuration  */
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_ACCEL_SAMPLING_SPEC_HIGH_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000010) /**<  Failed to set the accelerometer sampling specification  */
#define QMI_LOC_SENSOR_PERFORMANCE_CONTROL_CONFIG_PARAM_MASK_GYRO_SAMPLING_SPEC_HIGH_V02 ((qmiLocSensorPerformanceControlConfigFailureMaskT_v02)0x00000020) /**<  Failed to set the gyroscope sampling specification  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Provides fine-grained control of sensor based positioning
                    performance. */
typedef struct {

  /* Mandatory */
  /*  Set Sensor Perf Control Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Sensor Performance Control Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Failed Configuration */
  uint8_t failedConfiguration_valid;  /**< Must be set to true if failedConfiguration is being passed */
  qmiLocSensorPerformanceControlConfigFailureMaskT_v02 failedConfiguration;
  /**<   Identifies parameters that were not configured successfully. This field
       is sent only when the status is not a success.
       Valid bitmasks: \n
       - 0x00000001 -- PERFORMANCE_ MODE \n
       - 0x00000002 -- ACCEL_SAMPLING_ SPEC \n
       - 0x00000004 -- GYRO_SAMPLING_ SPEC \n
       - 0x00000008 -- ALGORITHM_ CONFIG \n
       - 0x00000010 -- ACCEL_SAMPLING_ SPEC_HIGH \n
       - 0x00000020 -- GYRO_SAMPLING_ SPEC_HIGH
  */
}qmiLocSetSensorPerformanceControlConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Retrieves the current sensor performance control
                    configuration. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetSensorPerformanceControlConfigReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Retrieves the current sensor performance control
                    configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Sensor Perf Control Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Sensor Performance Control Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Performance Control Mode */
  uint8_t performanceControlMode_valid;  /**< Must be set to true if performanceControlMode is being passed */
  qmiLocSensorPerformanceControlModeEnumT_v02 performanceControlMode;
  /**<   Controls when sensor data is requested during GNSS fix processing.
 This field is relevant only when sensors have been enabled using the
 sensor control configuration.
 Values: \n
      - eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_AUTO (0) --  Sensors usage is determined by the GNSS location engine.
       This mode can optimize power consumption and give a
       power-balanced positioning and heading enhancement using
       inertial sensors \n
      - eQMI_LOC_SENSOR_PERFORMANCE_CONTROL_MODE_FORCED (1) --  Sensors usage is forced ON.
       This mode can be requested by the control point when
       power consumption is not a restriction to the use of
       inertial sensors.
 */

  /* Optional */
  /*  Accelerometer Sampling Specification */
  uint8_t accelSamplingSpec_valid;  /**< Must be set to true if accelSamplingSpec is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 accelSamplingSpec;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine is to request
       acceleration data to use by the high data rate filter. The sensor
       data rate is specified in terms of the nominal number of samples per
       batch and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 10 Hz sampling rate and 2 Hz batching rate.
  */

  /* Optional */
  /*  Gyroscope Sampling Specification */
  uint8_t gyroSamplingSpec_valid;  /**< Must be set to true if gyroSamplingSpec is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 gyroSamplingSpec;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine is to request
       gyro data to use by the high data rate filter. The sensor data
       rate is specified in terms of the nominal number of samples per batch
       and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 10 Hz sampling rate and 2 Hz batching rate.
  */

  /* Optional */
  /*  Algorithm Configuration */
  uint8_t algorithmConfig_valid;  /**< Must be set to true if algorithmConfig is being passed */
  qmiLocSensorAlgorithmMaskT_v02 algorithmConfig;
  /**<   Informs which sensor algorithms are set.
       Valid bitmasks: \n
       - 0x00000001 -- DISABLE_INS_ POSITIONING_FILTER
    */

  /* Optional */
  /*  High Data Rate Filter Accelerometer Sampling Specification */
  uint8_t accelSamplingSpecHigh_valid;  /**< Must be set to true if accelSamplingSpecHigh is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 accelSamplingSpecHigh;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine requests
       acceleration data to use by the high data rate filter. The sensor
       data rate is specified in terms of the nominal number of samples per
       batch and the number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 100 Hz sampling rate and 4 Hz batching rate.
  */

  /* Optional */
  /*  High Data Rate Filter Gyroscope Sampling Specification */
  uint8_t gyroSamplingSpecHigh_valid;  /**< Must be set to true if gyroSamplingSpecHigh is being passed */
  qmiLocSensorControlConfigSamplingSpecStructT_v02 gyroSamplingSpecHigh;
  /**<   \vspace{0.06in} \n Sets the nominal rate at which the GNSS location engine is to request
       gyro data to use by the high data rate filter. The sensor data rate
       is specified in terms of the nominal number of samples per batch and the
       number of batches per second.
       However, the final control of the actual requested rate resides with
       the Sensors Manager Module/GNSS location engine. \n
       Default -- 100 Hz sampling rate and 4 Hz batching rate.
  */
}qmiLocGetSensorPerformanceControlConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects a SUPL certificate to use in AGNSS sessions. */
typedef struct {

  /* Mandatory */
  /*  SUPL Certificate ID */
  uint8_t suplCertId;
  /**<   Certificate ID of the SUPL certificate. \n
       - Units -- Bytes \n
       - Range -- 0 to 9  */

  /* Mandatory */
  /*  SUPL Certificate Data */
  uint32_t suplCertData_len;  /**< Must be set to # of elements in suplCertData */
  uint8_t suplCertData[QMI_LOC_MAX_SUPL_CERT_LENGTH_V02];
  /**<   SUPL certificate contents. \n
       - Type -- Array of bytes \n
       - Maximum certificate size -- 2000 bytes */
}qmiLocInjectSuplCertificateReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects a SUPL certificate to use in AGNSS sessions. */
typedef struct {

  /* Mandatory */
  /*  SUPL Certificate Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject SUPL Certificate request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectSuplCertificateIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Deletes a SUPL certificate. */
typedef struct {

  /* Optional */
  /*  SUPL Certificate ID */
  uint8_t suplCertId_valid;  /**< Must be set to true if suplCertId is being passed */
  uint8_t suplCertId;
  /**<   Certificate ID of the SUPL certificate to delete. \n
       - Units -- Bytes \n
       - Range -- 0 to 9 \n
       If suplCertId is not specified,
       all SUPL certificates are deleted. */
}qmiLocDeleteSuplCertificateReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Deletes a SUPL certificate. */
typedef struct {

  /* Mandatory */
  /*  SUPL Certificate Deletion Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Delete SUPL Certificate request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocDeleteSuplCertificateIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocPositionEngineConfigParamMaskT_v02;
#define QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_INJECTED_POSITION_CONTROL_V02 ((qmiLocPositionEngineConfigParamMaskT_v02)0x00000001) /**<  Indicates whether the position engine uses the
       injected position in a direct position calculation.  */
#define QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_FILTER_SV_USAGE_V02 ((qmiLocPositionEngineConfigParamMaskT_v02)0x00000002) /**<  Indicates whether the position engine filters the
       SV usage in the fix.  */
#define QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_STORE_ASSIST_DATA_V02 ((qmiLocPositionEngineConfigParamMaskT_v02)0x00000004) /**<  Indicates whether the position engine stores assistance data
       in persistent memory.  */
#define QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_ENABLE_FASTER_TTFF_V02 ((qmiLocPositionEngineConfigParamMaskT_v02)0x00000008) /**<  Indicates whether the position engine stays on to optimize
       the TTFF for the subsequent position fix.  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to configure position engine
                    functionality. */
typedef struct {

  /* Optional */
  /*  Injected Position Control */
  uint8_t injectedPositionControl_valid;  /**< Must be set to true if injectedPositionControl is being passed */
  uint8_t injectedPositionControl;
  /**<   Controls how the injected position is used in the position engine.\n
       - 0x01 (TRUE) -- Use the injected position in a direct position
                               calculation (default) \n
       - 0x00 (FALSE) -- Do not use the injected position in a direct
                                position calculation
   */

  /* Optional */
  /*  Filter SV Usage */
  uint8_t filterSvUsage_valid;  /**< Must be set to true if filterSvUsage is being passed */
  uint8_t filterSvUsage;
  /**<   Controls whether SV usage is filtered in a position fix.
       Values: \n
       - 0x01 (TRUE) -- Filter the usage of SVs in the fix \n
       - 0x00 (FALSE) -- Do not filter the usage of SVs in the fix (default)
    */

  /* Optional */
  /*  Store Assist Data */
  uint8_t storeAssistData_valid;  /**< Must be set to true if storeAssistData is being passed */
  uint8_t storeAssistData;
  /**<   Controls whether assistance data is stored in
       persistent memory.
       Values: \n
       - 0x01 (TRUE) -- Store assistance data in persistent memory (default) \n
       - 0x00 (FALSE) -- Do not store assistance data in persistent memory

  */

  /* Optional */
  /*  Enable Faster TTFF */
  uint8_t enableFasterTTFF_valid;  /**< Must be set to true if enableFasterTTFF is being passed */
  uint8_t enableFasterTTFF;
  /**<   Allows the receiver to stay on after a position session, to
       collect information that helps reduce the Time To First Fix (TTFF)
       when the next position request is made. The receiver stays
       on only if the engine determines that it must collect some
       information. The receiver stays on for the duration necessary to
       collect the information.
       If enabled, the clients can see a delay in receiving the Engine Off
       event after the position session ends.
       Values: \n
       - 0x01 (TRUE) -- Allow the engine to stay on for reduced TTFF (default) \n
       - 0x00 (FALSE) -- Do not allow the engine to stay on for reduced TTFF
       */
}qmiLocSetPositionEngineConfigParametersReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to configure position engine
                    functionality. */
typedef struct {

  /* Mandatory */
  /*  Set Position Engine Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Configuration Parameters request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Failed Parameters */
  uint8_t failedPositionEngineConfigParamMask_valid;  /**< Must be set to true if failedPositionEngineConfigParamMask is being passed */
  qmiLocPositionEngineConfigParamMaskT_v02 failedPositionEngineConfigParamMask;
  /**<   Identifies the parameters that were not set successfully.
 This field is sent only if the status is other than SUCCESS.
 Valid bitmasks:\n
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_INJECTED_POSITION_CONTROL (0x00000001) --  Indicates whether the position engine uses the
       injected position in a direct position calculation.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_FILTER_SV_USAGE (0x00000002) --  Indicates whether the position engine filters the
       SV usage in the fix.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_STORE_ASSIST_DATA (0x00000004) --  Indicates whether the position engine stores assistance data
       in persistent memory.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_ENABLE_FASTER_TTFF (0x00000008) --  Indicates whether the position engine stays on to optimize
       the TTFF for the subsequent position fix.
 */
}qmiLocSetPositionEngineConfigParametersIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the position engine
                    configuration parameters. */
typedef struct {

  /* Mandatory */
  /*  Config Parameters */
  qmiLocPositionEngineConfigParamMaskT_v02 getPositionEngineConfigParamMask;
  /**<   Mask denoting the configuration parameters to retrieve.
 Valid bitmasks:
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_INJECTED_POSITION_CONTROL (0x00000001) --  Indicates whether the position engine uses the
       injected position in a direct position calculation.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_FILTER_SV_USAGE (0x00000002) --  Indicates whether the position engine filters the
       SV usage in the fix.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_STORE_ASSIST_DATA (0x00000004) --  Indicates whether the position engine stores assistance data
       in persistent memory.
      - QMI_LOC_POSITION_ENGINE_CONFIG_PARAM_MASK_ENABLE_FASTER_TTFF (0x00000008) --  Indicates whether the position engine stays on to optimize
       the TTFF for the subsequent position fix.
 */
}qmiLocGetPositionEngineConfigParametersReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the position engine
                    configuration parameters. */
typedef struct {

  /* Mandatory */
  /*  Get Position Engine Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Configuration Parameters request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Injected Position Control */
  uint8_t injectedPositionControl_valid;  /**< Must be set to true if injectedPositionControl is being passed */
  uint8_t injectedPositionControl;
  /**<   Specifies whether the injected position is used for a direct calculation
       in the position engine.
       Values:\n
       - 0x01 (TRUE) -- The injected position is used in a direct
                               position calculation (default) \n
       - 0x00 (FALSE) -- The injected position is not used in a direct
                                position calculation
  */

  /* Optional */
  /*  Filter SV Usage */
  uint8_t filterSvUsage_valid;  /**< Must be set to true if filterSvUsage is being passed */
  uint8_t filterSvUsage;
  /**<   Specifies whether SV usage is filtered in a position fix.
       Values: \n
       - 0x01 (TRUE) -- SV usage is filtered in the fix\n
       - 0x00 (FALSE) -- SV usage is not filtered in the fix (default)
  */

  /* Optional */
  /*  Store Assist Data */
  uint8_t storeAssistData_valid;  /**< Must be set to true if storeAssistData is being passed */
  uint8_t storeAssistData;
  /**<   Specifies whether assistance data is stored in persistent memory.
       Values:  \n
       - 0x01 (TRUE) -- Assistance data is stored in persistent memory (default) \n
       - 0x00 (FALSE) -- Assistance data is not stored in persistent
                                memory
     */

  /* Optional */
  /*  Enable Faster TTFF */
  uint8_t enableFasterTTFF_valid;  /**< Must be set to true if enableFasterTTFF is being passed */
  uint8_t enableFasterTTFF;
  /**<   Allows the receiver to stay on after a position session, to
       collect information that helps reduce the TTFF
       when the next position request is made. The receiver stays
       on only if the engine determines that it must collect some
       information. The receiver stays on for the duration necessary to
       collect the information.
       If enabled, the clients can see a delay in receiving the Engine Off
       event after the position session ends.
       Values:  \n
       - 0x01 (TRUE) -- Allow the engine to stay on for reduced TTFF (default) \n
       - 0x00 (FALSE) -- Do not allow the engine to stay on for reduced
                               TTFF
       */
}qmiLocGetPositionEngineConfigParametersIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint8_t qmiLocGeofenceBreachMaskT_v02;
#define QMI_LOC_GEOFENCE_BREACH_ENTERING_MASK_V02 ((qmiLocGeofenceBreachMaskT_v02)0x01) /**<  If this mask is set, a breach event is reported
       when the Geofence is entered  */
#define QMI_LOC_GEOFENCE_BREACH_LEAVING_MASK_V02 ((qmiLocGeofenceBreachMaskT_v02)0x02) /**<  If this mask is set, a breach event is reported
       when the Geofence is exited  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCERESPONSIVENESSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_RESPONSIVENESS_LOW_V02 = 0x01, /**<  The Geofence is monitored for a breach at a
       low rate of 15 minutes. The gap between the actual breach and
       the time it is reported is higher. This
       setting results in lower power usage. \n */
  eQMI_LOC_GEOFENCE_RESPONSIVENESS_MED_V02 = 0x02, /**<  The Geofence is monitored for a breach at a
       medium rate of 2 minutes. This is the default setting.\n  */
  eQMI_LOC_GEOFENCE_RESPONSIVENESS_HIGH_V02 = 0x03, /**<  The Geofence is monitored for a breach at a
       high rate of 10 seconds. The gap between the actual breach and
       the time it is reported is low. This results
       in higher power usage. \n */
  eQMI_LOC_GEOFENCE_RESPONSIVENESS_ULTRA_HIGH_V02 = 0x04, /**<  The Geofence is monitored for a breach at a
       very high rate of 1 second. The gap between the actual breach and
       the time it is reported is very low. This results
       in very high power usage. This setting must be avoided whenever
       possible because of the drastic power implications. \n */
  eQMI_LOC_GEOFENCE_RESPONSIVENESS_CUSTOM_V02 = 0x05, /**<  The Geofence is monitored for a breach at a
       user defined rate. The gap between the actual breach and
       the time it is reported depends on the user setting. The power implication
       is inversely proportional to the responsiveness value set by the user.
       The higher the responsiveness value, the lower the power implications, and vice-versa.  */
  QMILOCGEOFENCERESPONSIVENESSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceResponsivenessEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  double latitude;
  /**<   Latitude of the center of the Geofence.*/

  double longitude;
  /**<   Longitude of the center of the Geofence.*/

  uint32_t radius;
  /**<   Radius of the circular Geofence in meters. */
}qmiLocCircularGeofenceArgsStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEPOSITIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_POSITION_INSIDE_V02 = 0x01, /**<  Position is inside a Geofence \n */
  eQMI_LOC_GEOFENCE_POSITION_OUTSIDE_V02 = 0x02, /**<  Position is outside a Geofence  */
  QMILOCGEOFENCEPOSITIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofencePositionEnumT_v02;
/**
    @}
  */

typedef uint8_t qmiLocGeofenceDwellTypeMaskT_v02;
#define QMI_LOC_GEOFENCE_DWELL_TYPE_INSIDE_MASK_V02 ((qmiLocGeofenceDwellTypeMaskT_v02)0x01) /**<  If this mask is set, a dwell event is reported
       when a user dwells inside the Geofence for a specified time \n */
#define QMI_LOC_GEOFENCE_DWELL_TYPE_OUTSIDE_MASK_V02 ((qmiLocGeofenceDwellTypeMaskT_v02)0x02) /**<  If this mask is set, a dwell event is reported
       when a user dwells outside the Geofence for a specified time  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to add a circular Geofence. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The transaction ID
       is returned in the QMI_LOC_ADD_CIRCULAR_GEOFENCE_IND
       indication. */

  /* Mandatory */
  /*  Circular Geofence Arguments */
  qmiLocCircularGeofenceArgsStructT_v02 circularGeofenceArgs;

  /* Mandatory */
  /*  Breach Event Mask */
  qmiLocGeofenceBreachMaskT_v02 breachMask;
  /**<   Specifies the breach events in which the client is interested.
       Values: \n
       - 0x01 -- GEOFENCE_BREACH_ ENTERING_MASK \n
       - 0x02 -- GEOFENCE_BREACH_ LEAVING_MASK
    */

  /* Mandatory */
  /*  Include Position in Breach Event */
  uint8_t includePosition;
  /**<   Specifies whether the Geofence engine includes the position
       in a breach event.\n
       Values: \n
       - 0x01 (TRUE) -- Position is reported with the breach event \n
       - 0x00 (FALSE) -- Position is not reported with the breach
                                event
        */

  /* Optional */
  /*  Responsiveness */
  uint8_t responsiveness_valid;  /**< Must be set to true if responsiveness is being passed */
  qmiLocGeofenceResponsivenessEnumT_v02 responsiveness;
  /**<   Specifies the rate of detection for a Geofence breach.
 This can impact the time lag between the actual breach event and
 when it is reported. This parameter has power implications
 and must be fine-tuned to optimize power savings.\n
 Values: \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_LOW (0x01) --  The Geofence is monitored for a breach at a
       low rate of 15 minutes. The gap between the actual breach and
       the time it is reported is higher. This
       setting results in lower power usage. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_MED (0x02) --  The Geofence is monitored for a breach at a
       medium rate of 2 minutes. This is the default setting.\n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_HIGH (0x03) --  The Geofence is monitored for a breach at a
       high rate of 10 seconds. The gap between the actual breach and
       the time it is reported is low. This results
       in higher power usage. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_ULTRA_HIGH (0x04) --  The Geofence is monitored for a breach at a
       very high rate of 1 second. The gap between the actual breach and
       the time it is reported is very low. This results
       in very high power usage. This setting must be avoided whenever
       possible because of the drastic power implications. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_CUSTOM (0x05) --  The Geofence is monitored for a breach at a
       user defined rate. The gap between the actual breach and
       the time it is reported depends on the user setting. The power implication
       is inversely proportional to the responsiveness value set by the user.
       The higher the responsiveness value, the lower the power implications, and vice-versa.
 */

  /* Optional */
  /*  Confidence */
  uint8_t confidence_valid;  /**< Must be set to true if confidence is being passed */
  qmiLocGeofenceConfidenceEnumT_v02 confidence;
  /**<   Given a breach event, the confidence determines the probability
 that the breach happened at the Geofence boundary.
 This parameter has power implications and
 must be fine-tuned to optimize power savings.
 Values: \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_LOW (0x01) --  Geofence engine indicates a breach with
       low confidence; this setting results in lower
       power usage, and it can impact the yield because
       incorrect breach events can be sent \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_MED (0x02) --  (Default) Geofence engine indicates a breach with
       medium confidence \n
      - eQMI_LOC_GEOFENCE_CONFIDENCE_HIGH (0x03) --  Geofence engine indicates a breach with
       high confidence; this setting results in higher
       power usage
 */

  /* Optional */
  /*  Custom Responsiveness Value */
  uint8_t customResponsivenessValue_valid;  /**< Must be set to true if customResponsivenessValue is being passed */
  uint32_t customResponsivenessValue;
  /**<   Specifies in seconds the user-defined rate of detection for a Geofence breach.
       This might impact the time lag between the actual breach event and
       when it is reported. The gap between the actual breach and
       the time it is reported depends on the user setting. The power implication
       is inversely proportional to the responsiveness value set by the user.
       The higher the responsiveness value, the lower the power implications, and vice-versa.
       If this field is set, the responsiveness is always treated
       as eQMI_LOC_GEOFENCE_ RESPONSIVENESS_CUSTOM.
       The minimum value supported in this field is 1 second, and the maximum value is 65535 seconds.
       An error is returned if an attempt is made to set this to an unsupported value.
       If this field is set, the responsiveness is always treated
       as eQMI_LOC_GEOFENCE_ RESPONSIVENESS_CUSTOM, which means that the other responsiveness
       types, such as eQMI_LOC_GEOFENCE _RESPONSIVENESS_LOW, eQMI_LOC_GEOFENCE_ RESPONSIVENESS_MEDIUM,
       eQMI_LOC_GEOFENCE_ RESPONSIVENESS_HIGH, and eQMI_LOC_GEOFENCE_ RESPONSIVENESS_ULTRA_HIGH are all
       disregarded.
       If this field is not set, the responsiveness is treated as
       eQMI_LOC_GEOFENCE_ RESPONSIVENESS_LOW, eQMI_LOC_GEOFENCE_RESPONSIVENESS_MEDIUM,
       eQMI_LOC_GEOFENCE_RESPONSIVENESS_HIGH, or eQMI_LOC_GEOFENCE_RESPONSIVENESS_ULTRA_HIGH.
  */

  /* Optional */
  /*  Dwell Time of Geofence */
  uint8_t dwellTime_valid;  /**< Must be set to true if dwellTime is being passed */
  uint32_t dwellTime;
  /**<   Dwell time is the time in seconds a user spends in the Geofence before a dwell
       event is sent.
  */

  /* Optional */
  /*  Geofence Dwell Type */
  uint8_t dwellTypeMask_valid;  /**< Must be set to true if dwellTypeMask is being passed */
  qmiLocGeofenceDwellTypeMaskT_v02 dwellTypeMask;
  /**<   Type of dwell event in which the user is interested.
 Values: \n
      - QMI_LOC_GEOFENCE_DWELL_TYPE_INSIDE_MASK (0x01) --  If this mask is set, a dwell event is reported
       when a user dwells inside the Geofence for a specified time \n
      - QMI_LOC_GEOFENCE_DWELL_TYPE_OUTSIDE_MASK (0x02) --  If this mask is set, a dwell event is reported
       when a user dwells outside the Geofence for a specified time
 */
}qmiLocAddCircularGeofenceReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to add a circular Geofence. */
typedef struct {

  /* Mandatory */
  /*  Add Circular Geofence Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Add Circular Geofence request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Add Circular
       Geofence request. This parameter is always present
       when the status field is set to SUCCESS. */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Geofence identifier allocated by the engine.
       The client must include this identifier in all transactions
       pertaining to this Geofence. */
}qmiLocAddCircularGeofenceIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to delete a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence that is to delete. */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_DELETE_GEOFENCE_IND
       indication returns the transaction ID. */
}qmiLocDeleteGeofenceReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to delete a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Delete Geofence Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_DELETE_GEOFENCE_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence that was deleted. */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Delete
       Geofence request. This parameter is always present
       when the status field is set to SUCCESS. */
}qmiLocDeleteGeofenceIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEORIGINENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_ORIGIN_NETWORK_V02 = 1, /**<  Geofence was initiated by a network-initiated client \n */
  eQMI_LOC_GEOFENCE_ORIGIN_DEVICE_V02 = 2, /**<  Geofence was initiated by the device  */
  QMILOCGEOFENCEORIGINENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceOriginEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCESTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_STATE_ACTIVE_V02 = 1, /**<  Geofence is being actively monitored \n */
  eQMI_LOC_GEOFENCE_STATE_SUSPEND_V02 = 2, /**<  Geofence monitoring is suspended  */
  QMILOCGEOFENCESTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence that to query. */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_QUERY_GEOFENCE_IND
       indication returns the transaction ID. */
}qmiLocQueryGeofenceReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Query Geofence Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Query Geofence request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence that was queried. */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Query
       Geofence request. This parameter is always present
       when the status field is set to SUCCESS. */

  /* Optional */
  /*  Geofence Origin */
  uint8_t geofenceOrigin_valid;  /**< Must be set to true if geofenceOrigin is being passed */
  qmiLocGeofenceOriginEnumT_v02 geofenceOrigin;
  /**<   Originator of the Geofence.
 Values: \n
      - eQMI_LOC_GEOFENCE_ORIGIN_NETWORK (1) --  Geofence was initiated by a network-initiated client \n
      - eQMI_LOC_GEOFENCE_ORIGIN_DEVICE (2) --  Geofence was initiated by the device
 */

  /* Optional */
  /*  Position with Respect to Geofence */
  uint8_t posWrtGeofence_valid;  /**< Must be set to true if posWrtGeofence is being passed */
  qmiLocGeofencePositionEnumT_v02 posWrtGeofence;
  /**<   Indicates whether the client is inside or outside
 the Geofence.
 Values: \n
      - eQMI_LOC_GEOFENCE_POSITION_INSIDE (0x01) --  Position is inside a Geofence \n
      - eQMI_LOC_GEOFENCE_POSITION_OUTSIDE (0x02) --  Position is outside a Geofence
 */

  /* Optional */
  /*  Circular Geofence Parameters */
  uint8_t circularGeofenceArgs_valid;  /**< Must be set to true if circularGeofenceArgs is being passed */
  qmiLocCircularGeofenceArgsStructT_v02 circularGeofenceArgs;

  /* Optional */
  /*  Geofence State */
  uint8_t geofenceState_valid;  /**< Must be set to true if geofenceState is being passed */
  qmiLocGeofenceStateEnumT_v02 geofenceState;
  /**<   Specifies whether to actively monitor the Geofenced.
 Values: \n
      - eQMI_LOC_GEOFENCE_STATE_ACTIVE (1) --  Geofence is being actively monitored \n
      - eQMI_LOC_GEOFENCE_STATE_SUSPEND (2) --  Geofence monitoring is suspended
 */
}qmiLocQueryGeofenceIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocMotionDetectionSourceMaskT_v02;
#define QMI_LOC_MOTION_DETECTION_SOURCE_SENSORS_V02 ((qmiLocMotionDetectionSourceMaskT_v02)0x00000001) /**<  Sensors are used for motion detection\n  */
#define QMI_LOC_MOTION_DETECTION_SOURCE_WIFI_V02 ((qmiLocMotionDetectionSourceMaskT_v02)0x00000002) /**<  Wi-Fi is used for motion detection \n */
#define QMI_LOC_MOTION_DETECTION_SOURCE_WWAN_V02 ((qmiLocMotionDetectionSourceMaskT_v02)0x00000004) /**<  Wireless WAN is used for motion detection  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGEOFENCEMOTIONSTATESENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GEOFENCE_MOTION_STATE_STATIONARY_V02 = 0, /**<  Motion state Stationary -- Handset is completely stationary \n */
  eQMI_LOC_GEOFENCE_MOTION_STATE_FIDDLE_V02 = 1, /**<  Motion state Fiddle -- Handset is not in motion but is being "fiddled" with \n */
  eQMI_LOC_GEOFENCE_MOTION_STATE_WALK_V02 = 2, /**<  Motion state Walk -- User is walking with the handset \n */
  eQMI_LOC_GEOFENCE_MOTION_STATE_RUN_V02 = 3, /**<  Motion state Run -- User is running with the handset \n */
  eQMI_LOC_GEOFENCE_MOTION_STATE_DRIVE_V02 = 4, /**<  Motion state Drive -- User is driving with the handset    */
  QMILOCGEOFENCEMOTIONSTATESENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGeofenceMotionStatesEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocGeofenceMotionStatesEnumT_v02 motionState;
  /**<   Motion state for which information is being configured. */

  float motionStateSpeed;
  /**<    Motion state speed in milliseconds; positive floating values.
        The state speed must be configured carefully. Very low speed
        configuration for a state might result in missing Geofence
        breaches in some scenarios.

        Typical motion state speeds: \n
        - Stationary speed -- 0 meters per second
        - Fiddle speed -- 0 meters per second \n
        - Walk speed -- 3 meters per second    \n
        - Run speed -- 8 meters per second \n
        - Drive speed -- 56 meters per second
  */
}qmiLocGeofenceMotionStateConfigStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the Geofence engine configuration. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The transaction ID
       is returned with the QMI_LOC_SET_GEOFENCE_ENGINE_CONFIG_IND
       indication. */

  /* Optional */
  /*  GNSS Unavailable Indication Timeout */
  uint8_t gnssUnavailableIndicationTimeout_valid;  /**< Must be set to true if gnssUnavailableIndicationTimeout is being passed */
  uint32_t gnssUnavailableIndicationTimeout;
  /**<   In a bad GNSS environment, this is the timeout after which the Geofence
       engine sends out a GNSS Unavailable alert. The GNSS Unavailable
       alert is sent under the following conditions: \n
       - If gnssUnavailableIndicationTimeout is less than
             gnssPositionSessionTimeout, the GNSS
             unavailable timeout indication is sent after
             gnssPositionSessionTimeout expires \n
       - If gnssPositionSessionTimeout is less than
             gnssUnavailableIndicationTimeout, the
             GNSS Unavailable timeout indication is sent after
             gnssUnavailableIndicationTimeout expires
     */

  /* Optional */
  /*  Max Geofences */
  uint8_t maxGeofences_valid;  /**< Must be set to true if maxGeofences is being passed */
  uint32_t maxGeofences;
  /**<   Identifies the maximum number of Geofences that the Geofence enginer can support.
       If this number is less than the deployed
       Geofences, this command fails.
       If the command succeeds, the engine supports the maximum number of
       Geofences requested, provided there is enough memory to support that
       many Geofences. Increasing this value to a very large number in a
       constrained memory environment might affect other modules negatively.
       This value is determined by phone manufacturers. The default value
       is 200. */

  /* Optional */
  /*  Enable Motion Detection Sources */
  uint8_t enableMotionDetectionSources_valid;  /**< Must be set to true if enableMotionDetectionSources is being passed */
  qmiLocMotionDetectionSourceMaskT_v02 enableMotionDetectionSources;
  /**<   Identifies the sources that the Geofence engine can enable for motion detection.
 The sources of motion detection that the Geofence enginer enable are dependent on the platform.
 These sources are only set once at boot time, they are not expected to change after that.
 Any attempt to set the value of the motion detection sources at runtime results in an undefined behavior.
 Values: \n
      - QMI_LOC_MOTION_DETECTION_SOURCE_SENSORS (0x00000001) --  Sensors are used for motion detection\n
      - QMI_LOC_MOTION_DETECTION_SOURCE_WIFI (0x00000002) --  Wi-Fi is used for motion detection \n
      - QMI_LOC_MOTION_DETECTION_SOURCE_WWAN (0x00000004) --  Wireless WAN is used for motion detection  */

  /* Optional */
  /*  Enable Coarse Position Injection Usage */
  uint8_t enableCpiUsage_valid;  /**< Must be set to true if enableCpiUsage is being passed */
  uint8_t enableCpiUsage;
  /**<   Indicates whether the Geofence engine uses external Coarse Position Injection (CPI).\n
       - 0x01 (TRUE)  -- CPI is enabled (default) \n
       - 0x00 (FALSE) -- CPI is disabled
    */

  /* Optional */
  /*  GNSS Position QOS Session Timeout */
  uint8_t gnssPositionSessionTimeout_valid;  /**< Must be set to true if gnssPositionSessionTimeout is being passed */
  uint32_t gnssPositionSessionTimeout;
  /**<   Identifies the session timeout value (in seconds) for requesting a
         position in a bad GNSS environment.
         Values:  \n
       - If the gnssUnavailableIndicationTimeout value is less than
         gnssPositionSessionTimeout, in a bad GNSS environment, the GNSS
         Unavailable timeout indication is sent after
         gnssPositionSessionTimeout expires.\n
         - If gnssPositionSessionTimeout is less than gnssUnavailableIndicationTimeout,
         in a bad GNSS environment, the GNSS Unavailable timeout indication
         is sent after gnssUnavailableIndicationTimeout expires.
    */

  /* Optional */
  /*  GNSS Position Maximum Position Uncertainity Acceptable */
  uint8_t gnssPositionMaxPuncAcceptable_valid;  /**< Must be set to true if gnssPositionMaxPuncAcceptable is being passed */
  uint32_t gnssPositionMaxPuncAcceptable;
  /**<   GNSS maximum position uncertainity in meters acceptable by
         the Geofence engine.
         Values: \n
         - All positive values
    */

  /* Optional */
  /*  Medium Responsiveness Value */
  uint8_t mediumResponsivenessValue_valid;  /**< Must be set to true if mediumResponsivenessValue is being passed */
  uint32_t mediumResponsivenessValue;
  /**<   Medium responsiveness value in seconds that the Geofence engine
         uses for all medium responsiveness Geofences in the Geofence engine.
         Values: \n
         - Positive values (in seconds) \n
         - If the value is configured for less than 30 seconds, the value is
               set at 30 seconds \n
         - If the value is configured for more than 600 seconds, the value is
               set at 600 seconds \n
         - Default -- The Geofence engine uses 120 seconds as the medium
                          responsiveness value \n

         If the medium responsiveness value is changed, the responsiveness
         of the existing medium responsiveness Geofence does not change until the next
         position fix, which is based on the previous medium responsiveness
         setting.
    */

  /* Optional */
  /*  Challenging GNSS Environment Minimum CPI Wait Interval */
  uint8_t chalGnssEnvMinCpiWaitInterval_valid;  /**< Must be set to true if chalGnssEnvMinCpiWaitInterval is being passed */
  uint32_t chalGnssEnvMinCpiWaitInterval;
  /**<   Number of seconds that the Geofence engine is to wait between
         CPI requests in challenging a GNSS environment.
         Values: \n
         - Positive values (in seconds)
     */

  /* Optional */
  /*  Geofence Motion State Information */
  uint8_t motionStateInfo_valid;  /**< Must be set to true if motionStateInfo is being passed */
  uint32_t motionStateInfo_len;  /**< Must be set to # of elements in motionStateInfo */
  qmiLocGeofenceMotionStateConfigStructT_v02 motionStateInfo[QMI_LOC_GEOFENCE_MAX_MOTION_STATES_V02];
  /**<   \vspace{4pt} \n  Motion state information (for example, motion state speed) that the
         Geofence engine is to use.
   */
}qmiLocSetGeofenceEngineConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to set the Geofence engine configuration. */
typedef struct {

  /* Mandatory */
  /*  Set Geofence Engine Configuration Status. */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Geofence Engine Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Set Geofence Configuration
       request. This parameter is always present if the status
       field is set to SUCCESS. */
}qmiLocSetGeofenceEngineConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the Geofence engine configuration. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The transaction ID
       is returned with the QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_IND
       indication. */
}qmiLocGetGeofenceEngineConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the Geofence engine configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Geofence Engine Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_REQ
       request. This parameter is always present
       if the status field is set to SUCCESS. */

  /* Optional */
  /*  GPS Unavailable Indication Timeout */
  uint8_t gnssUnavailableIndicationTimeout_valid;  /**< Must be set to true if gnssUnavailableIndicationTimeout is being passed */
  uint32_t gnssUnavailableIndicationTimeout;
  /**<   In a bad GNSS environment, the timeout after which the Geofence engine
       sends out a GNSS unavailable indication. */

  /* Optional */
  /*  Max Geofences */
  uint8_t maxGeofences_valid;  /**< Must be set to true if maxGeofences is being passed */
  uint32_t maxGeofences;
  /**<   Identifies the maximum number of supported Geofences
       in the Geofence engine.  */

  /* Optional */
  /*  Enabled Motion Detection Sources */
  uint8_t enabledMotionDetectionSources_valid;  /**< Must be set to true if enabledMotionDetectionSources is being passed */
  qmiLocMotionDetectionSourceMaskT_v02 enabledMotionDetectionSources;
  /**<   Identifies the enabled sources for motion detection
 by the Geofence engine.
 Values: \n
      - QMI_LOC_MOTION_DETECTION_SOURCE_SENSORS (0x00000001) --  Sensors are used for motion detection\n
      - QMI_LOC_MOTION_DETECTION_SOURCE_WIFI (0x00000002) --  Wi-Fi is used for motion detection \n
      - QMI_LOC_MOTION_DETECTION_SOURCE_WWAN (0x00000004) --  Wireless WAN is used for motion detection  */

  /* Optional */
  /*  Enabled for CPI Position Injection Usage */
  uint8_t enabledCpiUsage_valid;  /**< Must be set to true if enabledCpiUsage is being passed */
  uint8_t enabledCpiUsage;
  /**<   Indicates whether CPI usage is enabled. \n
       - 0x01 (TRUE)  -- enabled \n
       - 0x00 (FALSE) -- disabled
    */
}qmiLocGetGeofenceEngineConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to edit a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence to edit. */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID specified in the Edit Geofence
       request. This parameter is always present when the
       status field is set to SUCCESS.
 */

  /* Optional */
  /*  Geofence State */
  uint8_t geofenceState_valid;  /**< Must be set to true if geofenceState is being passed */
  qmiLocGeofenceStateEnumT_v02 geofenceState;
  /**<   Specifies whether to actively monitor the Geofence.
 Values: \n
      - eQMI_LOC_GEOFENCE_STATE_ACTIVE (1) --  Geofence is being actively monitored \n
      - eQMI_LOC_GEOFENCE_STATE_SUSPEND (2) --  Geofence monitoring is suspended
 */

  /* Optional */
  /*  Breach Event Mask */
  uint8_t breachMask_valid;  /**< Must be set to true if breachMask is being passed */
  qmiLocGeofenceBreachMaskT_v02 breachMask;
  /**<   Specifies the breach events in which the client is interested.
       Values: \n
       - 0x01 -- GEOFENCE_BREACH_ ENTERING_MASK \n
       - 0x02 -- GEOFENCE_BREACH_ LEAVING_MASK
     */

  /* Optional */
  /*  Responsiveness */
  uint8_t responsiveness_valid;  /**< Must be set to true if responsiveness is being passed */
  qmiLocGeofenceResponsivenessEnumT_v02 responsiveness;
  /**<   Specifies the rate of detection for a Geofence breach.
 This might impact the time lag between the actual breach event and
 when it is reported. This parameter has power implications
 and must be fine-tuned to optimize power savings.
 Values: \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_LOW (0x01) --  The Geofence is monitored for a breach at a
       low rate of 15 minutes. The gap between the actual breach and
       the time it is reported is higher. This
       setting results in lower power usage. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_MED (0x02) --  The Geofence is monitored for a breach at a
       medium rate of 2 minutes. This is the default setting.\n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_HIGH (0x03) --  The Geofence is monitored for a breach at a
       high rate of 10 seconds. The gap between the actual breach and
       the time it is reported is low. This results
       in higher power usage. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_ULTRA_HIGH (0x04) --  The Geofence is monitored for a breach at a
       very high rate of 1 second. The gap between the actual breach and
       the time it is reported is very low. This results
       in very high power usage. This setting must be avoided whenever
       possible because of the drastic power implications. \n
      - eQMI_LOC_GEOFENCE_RESPONSIVENESS_CUSTOM (0x05) --  The Geofence is monitored for a breach at a
       user defined rate. The gap between the actual breach and
       the time it is reported depends on the user setting. The power implication
       is inversely proportional to the responsiveness value set by the user.
       The higher the responsiveness value, the lower the power implications, and vice-versa.
 */
}qmiLocEditGeofenceReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocGeofenceConfigParamMaskT_v02;
#define QMI_LOC_GEOFENCE_PARAM_MASK_GEOFENCE_STATE_V02 ((qmiLocGeofenceConfigParamMaskT_v02)0x00000001) /**<  Mask for the Geofence state parameter. \n  */
#define QMI_LOC_GEOFENCE_PARAM_MASK_BREACH_MASK_V02 ((qmiLocGeofenceConfigParamMaskT_v02)0x00000002) /**<  Mask for Geofence breach mask parameter.  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to edit a Geofence. */
typedef struct {

  /* Mandatory */
  /*  Edit Geofence Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Edit Geofence request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence that was edited. */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Identifies the transaction. The transaction ID
       is specified in the Edit Geofence request. */

  /* Optional */
  /*  Failed Parameters */
  uint8_t failedParams_valid;  /**< Must be set to true if failedParams is being passed */
  qmiLocGeofenceConfigParamMaskT_v02 failedParams;
  /**<   Specified only when the status is not set to SUCCESS. A set mask corresponding to a field
       indicates that the Geofence parameter cannot be edited.
       Values:\n
       - 0x00000001 -- GEOFENCE_PARAM_ MASK_GEOFENCE_STATE\n
       - 0x00000002 -- GEOFENCE_PARAM_ MASK_BREACH_MASK
    */
}qmiLocEditGeofenceIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to get time zone information. */
typedef struct {

  /* Mandatory */
  /*  Get Time Zone Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get Time Zone Info request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocEventGetTimeZoneReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint64_t dstOffset;
  /**<   Offset for Daylight Savings Time in seconds. This is zero if the time zone is not in Daylight Savings
       Time during the specified UTC timestamp. */

  uint64_t rawOffset;
  /**<   Offset from UTC (in seconds) for the current location. This does not take daylight savings into account. */
}qmiLocTimeZoneStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject time zone information. */
typedef struct {

  /* Mandatory */
  /*  UTC Time */
  uint64_t timeUtc;
  /**<   UTC time since Jan. 1, 1970.\n
       - Units -- Milliseconds */

  /* Mandatory */
  /*  Time Zone Information */
  qmiLocTimeZoneStructT_v02 timeZone;
}qmiLocInjectTimeZoneInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject time zone information. */
typedef struct {

  /* Mandatory */
  /*  Inject Time Zone Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the inject time zone information.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectTimeZoneInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the best available
                    position estimate from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_GET_BEST_AVAILABLE_POSITION_IND
       indication returns the transaction ID. */

  /* Optional */
  /*  GNSS Special Request Type */
  uint8_t specialReqType_valid;  /**< Must be set to true if specialReqType is being passed */
  qmiLocSpecialReqEnumT_v02 specialReqType;
  /**<   QMI_LOC client requests for best available location with special
 service request types set, honor this request even when GPS and privacy NVs
 do not allow fix requests for this client.
 If not set, ignore the field and process the client request
 according to GPS lock and privacy settings.
 Values: \n
      - eQMI_LOC_SPECIAL_REQUEST_SHORT_CODE (1) --  The QMI_LOC client requests for location fix with Special
       Service type set with Short Code, allow even when GPS and privacy NVs
       do not allow fix requests for this client.
 */
}qmiLocGetBestAvailablePositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the best available
                    position estimate from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get Best Available Position Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_BEST_AVAILABLE_POSITION_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Get Best
       Available Position request. This parameter is
       always present when the status field is set to
       SUCCESS. */

  /* Optional */
  /*  Latitude */
  uint8_t latitude_valid;  /**< Must be set to true if latitude is being passed */
  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0 \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
   */

  /* Optional */
  /*  Longitude */
  uint8_t longitude_valid;  /**< Must be set to true if longitude is being passed */
  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0 \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
   */

  /* Optional */
  /*   Circular Horizontal Position Uncertainty */
  uint8_t horUncCircular_valid;  /**< Must be set to true if horUncCircular is being passed */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units -- Meters */

  /* Optional */
  /*  Altitude With Respect to Ellipsoid */
  uint8_t altitudeWrtEllipsoid_valid;  /**< Must be set to true if altitudeWrtEllipsoid is being passed */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   - Units -- Meters */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   - Units -- Milliseconds since Jan. 1, 1970
     */

  /* Optional */
  /*  Time Uncertainty */
  uint8_t timeUnc_valid;  /**< Must be set to true if timeUnc is being passed */
  float timeUnc;
  /**<   - Units -- Milliseconds */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Minor Axis */
  uint8_t horUncEllipseSemiMinor_valid;  /**< Must be set to true if horUncEllipseSemiMinor is being passed */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Major Axis */
  uint8_t horUncEllipseSemiMajor_valid;  /**< Must be set to true if horUncEllipseSemiMajor is being passed */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Azimuth */
  uint8_t horUncEllipseOrientAzimuth_valid;  /**< Must be set to true if horUncEllipseOrientAzimuth is being passed */
  float horUncEllipseOrientAzimuth;
  /**<   Elliptical horizontal uncertainty azimuth of orientation. \n
       - Units -- Decimal degrees\n
       - Range -- 0 to 180 */

  /* Optional */
  /*  Horizontal Circular Confidence */
  uint8_t horCircularConfidence_valid;  /**< Must be set to true if horCircularConfidence is being passed */
  uint8_t horCircularConfidence;
  /**<   Horizontal circular uncertainty confidence. \n
       - Units -- Percent\n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Horizontal Elliptical Confidence */
  uint8_t horEllipticalConfidence_valid;  /**< Must be set to true if horEllipticalConfidence is being passed */
  uint8_t horEllipticalConfidence;
  /**<   Horizontal elliptical uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horReliability_valid;  /**< Must be set to true if horReliability is being passed */
  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Horizontal Speed */
  uint8_t horSpeed_valid;  /**< Must be set to true if horSpeed is being passed */
  float horSpeed;
  /**<   Horizontal speed.\n
       - Units -- Meters per second  */

  /* Optional */
  /*  Horizontal Speed Uncertainty */
  uint8_t horSpeedUnc_valid;  /**< Must be set to true if horSpeedUnc is being passed */
  float horSpeedUnc;
  /**<   Horizontal speed uncertainty. \n
       - Units -- Meters per second */

  /* Optional */
  /*  Altitude With Respect to Sea Level */
  uint8_t altitudeWrtMeanSeaLevel_valid;  /**< Must be set to true if altitudeWrtMeanSeaLevel is being passed */
  float altitudeWrtMeanSeaLevel;
  /**<   Altitude with respect to mean sea level. \n
       - Units -- Meters */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Reliability */
  uint8_t vertReliability_valid;  /**< Must be set to true if vertReliability is being passed */
  qmiLocReliabilityEnumT_v02 vertReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Vertical Speed */
  uint8_t vertSpeed_valid;  /**< Must be set to true if vertSpeed is being passed */
  float vertSpeed;
  /**<   - Units -- Meters per second */

  /* Optional */
  /*  Vertical Speed Uncertainty */
  uint8_t vertSpeedUnc_valid;  /**< Must be set to true if vertSpeedUnc is being passed */
  float vertSpeedUnc;
  /**<   - Units -- Meters per second */

  /* Optional */
  /*  Heading */
  uint8_t heading_valid;  /**< Must be set to true if heading is being passed */
  float heading;
  /**<   - Units -- Degrees \n
         - Range -- 0 to 359.999  */

  /* Optional */
  /*  Heading Uncertainty */
  uint8_t headingUnc_valid;  /**< Must be set to true if headingUnc is being passed */
  float headingUnc;
  /**<   - Type -- Floating point \n
       - Range -- 0 to 359.999 */

  /* Optional */
  /*  Magnetic Deviation */
  uint8_t magneticDeviation_valid;  /**< Must be set to true if magneticDeviation is being passed */
  float magneticDeviation;
  /**<   Difference between the bearing to true north and the bearing shown
      on a magnetic compass. The deviation is positive when the magnetic
      north is east of true north. */

  /* Optional */
  /*  Technology Used Mask */
  uint8_t technologyMask_valid;  /**< Must be set to true if technologyMask is being passed */
  qmiLocPosTechMaskT_v02 technologyMask;
  /**<   Technology used in computing this fix.
 Valid bitmasks: \n
      - QMI_LOC_POS_TECH_MASK_SATELLITE (0x00000001) --  Satellites were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_CELLID (0x00000002) --  Cell towers were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_WIFI (0x00000004) --  Wi-Fi access points were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_SENSORS (0x00000008) --  Sensors were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_REFERENCE_LOCATION (0x00000010) --  Reference location was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION (0x00000020) --  Coarse position injected into the location engine was used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_AFLT (0x00000040) --  AFLT was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_HYBRID (0x00000080) --  GNSS and network-provided measurements were used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_DRE (0x00000100) --  Dead reckoning engine (DRE) was used to generate the fix.
 */

  /* Optional */
  /*  Dilution of Precision */
  uint8_t DOP_valid;  /**< Must be set to true if DOP is being passed */
  qmiLocDOPStructT_v02 DOP;

  /* Optional */
  /*  GPS Time */
  uint8_t gpsTime_valid;  /**< Must be set to true if gpsTime is being passed */
  qmiLocGPSTimeStructT_v02 gpsTime;

  /* Optional */
  /*  Time Source */
  uint8_t timeSrc_valid;  /**< Must be set to true if timeSrc is being passed */
  qmiLocTimeSourceEnumT_v02 timeSrc;
  /**<   Values: \n
      - eQMI_LOC_TIME_SRC_INVALID (0) --  Invalid time \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TRANSFER (1) --  Time is set by the 1X system \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TAGGING (2) --  Time is set by WCDMA/GSM time tagging (that is,
       associating network time with GPS time) \n
      - eQMI_LOC_TIME_SRC_EXTERNAL_INPUT (3) --  Time is set by an external injection \n
      - eQMI_LOC_TIME_SRC_TOW_DECODE (4) --  Time is set after decoding over-the-air GPS navigation data
       from one GPS satellite \n
      - eQMI_LOC_TIME_SRC_TOW_CONFIRMED (5) --  Time is set after decoding over-the-air GPS navigation data
       from multiple satellites \n
      - eQMI_LOC_TIME_SRC_TOW_AND_WEEK_CONFIRMED (6) --  Both time of the week and the GPS week number are known \n
      - eQMI_LOC_TIME_SRC_NAV_SOLUTION (7) --  Time is set by the position engine after the fix is obtained \n
      - eQMI_LOC_TIME_SRC_SOLVE_FOR_TIME (8) --  Time is set by the position engine after performing SFT;
       this is done when the clock time uncertainty is large \n
      - eQMI_LOC_TIME_SRC_GLO_TOW_DECODE (9) --  Time is set after decoding GLO satellites \n
      - eQMI_LOC_TIME_SRC_TIME_TRANSFORM (10) --  Time is set after transforming the GPS to GLO time \n
      - eQMI_LOC_TIME_SRC_WCDMA_SLEEP_TIME_TAGGING (11) --  Time is set by the sleep time tag provided by the WCDMA network \n
      - eQMI_LOC_TIME_SRC_GSM_SLEEP_TIME_TAGGING (12) --  Time is set by the sleep time tag provided by the GSM network \n
      - eQMI_LOC_TIME_SRC_UNKNOWN (13) --  Source of the time is unknown \n
      - eQMI_LOC_TIME_SRC_SYSTEM_TIMETICK (14) --  Time is derived from the system clock (better known as the slow clock);
       GNSS time is maintained irrespective of the GNSS receiver state \n
      - eQMI_LOC_TIME_SRC_QZSS_TOW_DECODE (15) --  Time is set after decoding QZSS satellites \n
      - eQMI_LOC_TIME_SRC_BDS_TOW_DECODE (16) --  Time is set after decoding BDS satellites \n
      - eQMI_LOC_TIME_SRC_GAL_TOW_DECODE (17) --  Time is set after decoding Galileo satellites \n
      - eQMI_LOC_TIME_SRC_NAVIC_TOW_DECODE (18) --  Time is set after decoding NavIC satellites
 */

  /* Optional */
  /*  Sensor Data Usage */
  uint8_t sensorDataUsage_valid;  /**< Must be set to true if sensorDataUsage is being passed */
  qmiLocSensorUsageIndicatorStructT_v02 sensorDataUsage;

  /* Optional */
  /*  SVs Used to Calculate the Fix */
  uint8_t gnssSvUsedList_valid;  /**< Must be set to true if gnssSvUsedList is being passed */
  uint32_t gnssSvUsedList_len;  /**< Must be set to # of elements in gnssSvUsedList */
  uint16_t gnssSvUsedList[QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
       used for calculating this position report. The following
       information is associated with each SV ID: \n
       Range: \n
       - GPS --     1 to 32 \n
       - GLONASS -- 65 to 96  \n
       - SBAS --    120 to 158 and 183 to 191 \n
       - QZSS --    193 to 197 \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414
       */

  /* Optional */
  /*  Extended Dilution of Precision */
  uint8_t extDOP_valid;  /**< Must be set to true if extDOP is being passed */
  qmiLocExtDOPStructT_v02 extDOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  Spoof Report */
  uint8_t spoofReportMask_valid;  /**< Must be set to true if spoofReportMask is being passed */
  qmiLocSpoofMaskT_v02 spoofReportMask;
  /**<   The set bit indicates the domain that is suspected to be spoofed. \n
      - QMI_LOC_POSITION_SPOOFED (0x00000001) --  Position \n
      - QMI_LOC_TIME_SPOOFED (0x00000002) --  Time \n
      - QMI_LOC_NAVIGATION_DATA_SPOOFED (0x00000004) --  Navigation data
 */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   If the service reports expandedGnssSvUsedList, gnssSvUsedList is
       not reported. Each entry in the list contains the SV ID of a satellite
       used to calculate this position report. The following
       information is associated with each SV ID. \n
       Range: \n
       - GPS --     1 to 32 \n
       - GLONASS -- 65 to 96 \n
       - QZSS --    193 to 197 \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414
      */

  /* Optional */
  /*  Satellite Signal Types in the SVs Used List */
  uint8_t gnssSvUsedSignalTypeList_valid;  /**< Must be set to true if gnssSvUsedSignalTypeList is being passed */
  uint32_t gnssSvUsedSignalTypeList_len;  /**< Must be set to # of elements in gnssSvUsedSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSvUsedSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedGnssSvUsedList. The
 signal type list is aligned with the SVs in expandedGnssSvUsedList. Value 0
 means invalid.\n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */
}qmiLocGetBestAvailablePositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCMOTIONSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_MOTION_STATE_UNKNOWN_V02 = 0, /**<  Device state is not known \n */
  eQMI_LOC_MOTION_STATE_STATIONARY_V02 = 1, /**<  Device state is Stationary \n */
  eQMI_LOC_MOTION_STATE_IN_MOTION_V02 = 2, /**<  Device state is In Motion  */
  QMILOCMOTIONSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocMotionStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCMOTIONMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_MOTION_MODE_UNKNOWN_V02 = 0, /**<  Device movement is not known  */
  eQMI_LOC_MOTION_MODE_STATIONARY_V02 = 1, /**<  Device is not moving  */
  eQMI_LOC_MOTION_MODE_PEDESTRIAN_UNKNOWN_V02 = 200, /**<  Device movement is in Pedestrian mode; nothing else is known about the movement  */
  eQMI_LOC_MOTION_MODE_PEDESTRIAN_WALKING_V02 = 201, /**<  Device movement is in pedestrian Walking mode  */
  eQMI_LOC_MOTION_MODE_PEDESTRIAN_RUNNING_V02 = 202, /**<  Device movement is in pedestrian Running mode  */
  eQMI_LOC_MOTION_MODE_VEHICLE_UNKNOWN_V02 = 300, /**<  Device movement is in Vehicular mode; nothing else is known about the movement  */
  QMILOCMOTIONMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocMotionModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocMotionStateEnumT_v02 motion_state;
  /**<   Current motion state of the user.
 Values: \n
      - eQMI_LOC_MOTION_STATE_UNKNOWN (0) --  Device state is not known \n
      - eQMI_LOC_MOTION_STATE_STATIONARY (1) --  Device state is Stationary \n
      - eQMI_LOC_MOTION_STATE_IN_MOTION (2) --  Device state is In Motion
 */

  qmiLocMotionModeEnumT_v02 motion_mode;
  /**<   Modes of user motion.
 Values: \n
      - eQMI_LOC_MOTION_MODE_UNKNOWN (0) --  Device movement is not known
      - eQMI_LOC_MOTION_MODE_STATIONARY (1) --  Device is not moving
      - eQMI_LOC_MOTION_MODE_PEDESTRIAN_UNKNOWN (200) --  Device movement is in Pedestrian mode; nothing else is known about the movement
      - eQMI_LOC_MOTION_MODE_PEDESTRIAN_WALKING (201) --  Device movement is in pedestrian Walking mode
      - eQMI_LOC_MOTION_MODE_PEDESTRIAN_RUNNING (202) --  Device movement is in pedestrian Running mode
      - eQMI_LOC_MOTION_MODE_VEHICLE_UNKNOWN (300) --  Device movement is in Vehicular mode; nothing else is known about the movement
 */

  float probability_of_state;
  /**<   Probability that the device is actually undergoing the motion state
       specified by the combination of the values of motion_state, motion_mode,
       and motion_sub_mode. \vspace{0.1in}

       This value is a floating point number in the range of 0 to 100, in
       units of percent probability. Any value greater than 99.9999 is
       applied as 99.9999. \vspace{0.1in}

       It is recommended that if a particular combination of motion_state and
       motion_mode cannot be determined with more than 50 percent confidence,
       that a more general statement of user motion be made.
       For example, if the mode of In-Motion + Pedestrian-Running can only be
       determined with 50 percent probability, and the simpler statement of In-Motion
       can be determined with 90 percent probability, it is recommended that this field
       be used to simply state In-Motion with 90 percent probability. \vspace{0.1in}

       If the motion_state is not known, the value in this field is not used.
  */

  uint16_t age;
  /**<   Age of the motion data in milliseconds at the time of injection.
  */

  uint16_t timeout;
  /**<   If the age of the motion data input exceeds the timeout value, the data
       is no longer used. The timeout value is in units of milliseconds.
       Values in the range of 0 to 10000 are accepted. If 65535 is provided,
       the motion data input is applied until the next input is
       received. \n

       If the determination of motion data is an instantaneous observation
       and no notice is guaranteed via the QMI on a change in the
       state of the motion data, it is recommended to set this field to 0. \vspace{0.1in}

       If the determination of motion data is continuously monitored
       external to the QMI and an update is always applied to the QMI upon any
       change in state, a value of 65535 is used for this field.
       In this case, if a certain mode is set and is not later
       unset (for example, by sending in the request message with a user motion
       state of Unknown), the value is applied indefinitely.
  */
}qmiLocMotionDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects motion data for MSM GPS service use. */
typedef struct {

  /* Mandatory */
  /*  Motion Data */
  qmiLocMotionDataStructT_v02 motion_data;
}qmiLocInjectMotionDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects motion data for MSM GPS service use. */
typedef struct {

  /* Mandatory */
  /*  Inject Motion Data Request Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Motion Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectMotionDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to retrieve the list of network
                    initiated Geofence IDs. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The same transaction ID
       is returned in the QMI_LOC_GET_NI_GEOFENCE_ID_LIST_IND indication. */
}qmiLocGetNiGeofenceIdListReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to retrieve the list of network
                    initiated Geofence IDs. */
typedef struct {

  /* Mandatory */
  /*  Get NI Geofence ID List Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get NI Geofence ID List request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the Get NI
       Geofence ID List request. */

  /* Optional */
  /*  NI Geofence ID List */
  uint8_t niGeofenceIdList_valid;  /**< Must be set to true if niGeofenceIdList is being passed */
  uint32_t niGeofenceIdList_len;  /**< Must be set to # of elements in niGeofenceIdList */
  uint32_t niGeofenceIdList[QMI_LOC_MAX_NI_GEOFENCE_ID_LIST_LENGTH_V02];
  /**<   List containing the NI Geofence IDs. \n
       - Type -- Array of unsigned 32-bit integers \n
       - Maximum NI Geofence ID list length -- 16 */
}qmiLocGetNiGeofenceIdListIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t MCC;
  /**<   GSM mobile country code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t MNC;
  /**<   GSM mobile network code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t LAC;
  /**<   GSM location area code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t CID;
  /**<   GSM cell identification. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */
}qmiLocGSMCellIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects GSM cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  GSM Cell ID */
  qmiLocGSMCellIdStructT_v02 gsmCellId;
  /**<   \vspace{0.06in} \n Identifies the GSM cell on which the device is camped. */

  /* Mandatory */
  /*  Roaming Status */
  uint8_t roamingStatus;
  /**<   Indicates whether the device is roaming.
       - 0x01 (TRUE)  -- Device is roaming
       - 0x00 (FALSE) -- Device is not roaming
       */

  /* Optional */
  /*  Timing Advance */
  uint8_t timingAdvance_valid;  /**< Must be set to true if timingAdvance is being passed */
  uint32_t timingAdvance;
  /**<   Round trip delay between the MS and the BS, in units of 3.69 microseconds.
       Refer to 3GPP \hyperref[TS 05.10]{TS 05.10} and \hyperref[TS 45.010]{TS 45.010}. */
}qmiLocInjectGSMCellInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects GSM cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Inject GSM Cell Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject GSM Cell Info request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectGSMCellInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCROAMINGSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_PHONE_NOT_ROAMING_V02 = 1, /**<  Modem is camped on a home network \n */
  eQMI_LOC_PHONE_ROAMING_V02 = 2, /**<  Modem is camped on a roaming network  */
  QMILOCROAMINGSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocRoamingStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t mcc;
  /**<   WCDMA mobile country code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t mnc;
  /**<   WCDMA mobile network code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t cid;
  /**<   WCDMA cell identity. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */
}qmiLocWCDMACellIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects WCDMA cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  WCDMA Cell ID */
  qmiLocWCDMACellIdStructT_v02 wcdmaCellId;
  /**<   \n Identifies the WCDMA cell on which the device is camped. */

  /* Mandatory */
  /*  Roaming Status */
  qmiLocRoamingStatusEnumT_v02 roamingStatus;
  /**<   Indicates whether the device is roaming.
 Values: \n
      - eQMI_LOC_PHONE_NOT_ROAMING (1) --  Modem is camped on a home network \n
      - eQMI_LOC_PHONE_ROAMING (2) --  Modem is camped on a roaming network
 */

  /* Optional */
  /*  Cell Frequency */
  uint8_t freq_valid;  /**< Must be set to true if freq is being passed */
  uint32_t freq;
  /**<   Frequency information of the serving cell. \n
       - Valid range -- 0 to 16383 \n
       Refer to 3GPP \hyperref[TS 25.331]{TS 25.331}. */

  /* Optional */
  /*  Primary Scrambling Code */
  uint8_t psc_valid;  /**< Must be set to true if psc is being passed */
  uint32_t psc;
  /**<   Primary scrambling code of the serving cell. \n
       - Valid range -- 0 to 511 \n
       Refer to 3GPP \hyperref[TS 25.331]{TS 25.331}. */
}qmiLocInjectWCDMACellInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects WCDMA cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Inject WCDMA Cell Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject WCDMA Cell Info request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectWCDMACellInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t mcc;
  /**<   TDSCDMA mobile country code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t mnc;
  /**<   TDSCDMA mobile network code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */

  uint32_t cid;
  /**<   TDSCDMA cell identity. Refer to 3GPP \hyperref[TS 25.331]{TS 25.331}. */

  uint32_t lac;
  /**<   TDSCDMA location area code. Refer to \hyperref[ITU-T E.212]{ITU-T E.212}. */
}qmiLocTDSCDMACellIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects TDSCDMA cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  TDSCDMA Cell ID */
  qmiLocTDSCDMACellIdStructT_v02 tdscdmaCellId;
  /**<   \n Identifies the TDSCDMA cell on which the device is camped. */

  /* Mandatory */
  /*  Roaming Status */
  qmiLocRoamingStatusEnumT_v02 roamingStatus;
  /**<   Indicates whether the device is roaming.
 Values: \n
      - eQMI_LOC_PHONE_NOT_ROAMING (1) --  Modem is camped on a home network \n
      - eQMI_LOC_PHONE_ROAMING (2) --  Modem is camped on a roaming network
 */

  /* Optional */
  /*  Cell Frequency */
  uint8_t freq_valid;  /**< Must be set to true if freq is being passed */
  uint32_t freq;
  /**<   Frequency information of the serving cell. \n
       - Valid range -- 0 to 16383 \n
       Refer to 3GPP \hyperref[TS 25.331]{TS 25.331}. */
}qmiLocInjectTDSCDMACellInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects TDSCDMA cell information into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Inject TDSCDMA Cell Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject TDSCDMA Cell Info request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectTDSCDMACellInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects the subscriber ID of the phone into the location engine. */
typedef struct {

  /* Optional */
  /*  Preferred IMSI */
  uint8_t preferredIMSI_valid;  /**< Must be set to true if preferredIMSI is being passed */
  uint64_t preferredIMSI;
  /**<   IMSI number of the preferred RAT; refer to \hyperref[ITU-T E.212]{ITU-T E.212}.*/

  /* Optional */
  /*  Preferred MSISDN */
  uint8_t preferredMSISDN_valid;  /**< Must be set to true if preferredMSISDN is being passed */
  uint64_t preferredMSISDN;
  /**<   MSISDN number of the preferred RAT; refer to \hyperref[ITU-T E.212]{ITU-T E.212}.*/
}qmiLocInjectSubscriberIDReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects the subscriber ID of the phone into the location engine. */
typedef struct {

  /* Mandatory */
  /*  Inject Subscriber ID Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Subscriber ID request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectSubscriberIDIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCINJECTEDNETWORKINITIATEDMESSAGETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_INJECTED_NETWORK_INITIATED_MESSAGE_TYPE_SUPL_V02 = 0, /**<  SUPL network-initiated message is being injected.  */
  QMILOCINJECTEDNETWORKINITIATEDMESSAGETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocInjectedNetworkInitiatedMessageTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects a network-initiated message into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Injected Network Initiated Message Type */
  qmiLocInjectedNetworkInitiatedMessageTypeEnumT_v02 injectedNIMessageType;
  /**<   Type of the network-initiated message being injected.
 Values: \n
      - eQMI_LOC_INJECTED_NETWORK_INITIATED_MESSAGE_TYPE_SUPL (0) --  SUPL network-initiated message is being injected.  */

  /* Mandatory */
  /*  Injected Network Initiated Message */
  uint32_t injectedNIMessage_len;  /**< Must be set to # of elements in injectedNIMessage */
  uint8_t injectedNIMessage[QMI_LOC_MAX_INJECTED_NETWORK_INITIATED_MESSAGE_LENGTH_V02];
  /**<   Network-initiated message body.
       If the inject NI message type is TYPE_SUPL, the message contains
       a SUPL INIT message as defined in OMA-TS-ULP-V2_\hyperref[020110527C]{0-20110527-C}. */
}qmiLocInjectNetworkInitiatedMessageReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects a network-initiated message into the location
                    engine. */
typedef struct {

  /* Mandatory */
  /*  Inject Network Initiated Message Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Network Initiated Message request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectNetworkInitiatedMessageIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Notifies the location engine that the device is out of
                    service. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocWWANOutOfServiceNotificationReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the location engine that the device is out of
                    service. */
typedef struct {

  /* Mandatory */
  /*  Notify WWAN Out of Service Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Notify WWAN Out of Service request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocWWANOutOfServiceNotificationIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject pedometer data
                    into the location engine. */
typedef struct {

  /* Mandatory */
  /*  Time Source */
  qmiLocSensorDataTimeSourceEnumT_v02 timeSource;
  /**<   Time source for the pedometer. The location service uses
 this field to identify the time reference used in the
 pedometer data time stamp.
 Values: \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_UNSPECIFIED (0) --  Sensor time source is unspecified \n
      - eQMI_LOC_SENSOR_TIME_SOURCE_COMMON (1) --  Time source is common between the sensors and
       the location engine
 */

  /* Mandatory */
  /*  Pedometer Report Timestamp */
  uint32_t timestamp;
  /**<   Time stamp of the last step event in this report, that is, the time stamp
       of the step event that caused this report to be generated.
       The time stamp is in the time reference scale
       used by the pedometer time source. \n
       - Units -- Milliseconds */

  /* Mandatory */
  /*  Time Interval */
  uint32_t timeInterval;
  /**<   Time interval during which the step count was calculated. Subtracting
       timeInterval from the timestamp field yields the time when
       the step detection for the first step in this report started. \n
       - Units -- Milliseconds */

  /* Mandatory */
  /*  Step Count */
  uint32_t stepCount;
  /**<   Number of steps counted during the time interval. */

  /* Optional */
  /*  Step Confidence */
  uint8_t stepConfidence_valid;  /**< Must be set to true if stepConfidence is being passed */
  uint8_t stepConfidence;
  /**<   Confidence associated with the step. This field is only applicable
       for a single step report, that is, if the step count is one. \n
       - Range -- 0 to 100 \n
       \textbf{Note:} The report is ignored if confidence is 0. */

  /* Optional */
  /*  Step Count Uncertainty */
  uint8_t stepCountUncertainty_valid;  /**< Must be set to true if stepCountUncertainty is being passed */
  float stepCountUncertainty;
  /**<   Uncertainty (in steps) associated with the step count. */

  /* Optional */
  /*  Step Rate */
  uint8_t stepRate_valid;  /**< Must be set to true if stepRate is being passed */
  float stepRate;
  /**<   Current estimate for the rate of steps per second. \n
       - Units -- steps per second \n
       - Range -- >= 0.0 */
}qmiLocPedometerReportReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject pedometer data
                    into the location engine. */
typedef struct {

  /* Mandatory */
  /*  Status of Pedometer Report Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Pedometer Report request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocPedometerReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCBATCHINGTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_LOCATION_BATCHING_V02 = 1, /**<  Location batching (default) \n  */
  eQMI_LOC_OUTDOOR_TRIP_BATCHING_V02 = 2, /**<  Outdoor trip batching  */
  QMILOCBATCHINGTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocBatchingTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the batching size. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction; the QMI_LOC_GET_BATCH_SIZE_IND
       indication returns the transaction ID. */

  /* Mandatory */
  /*  Requested Batch Size */
  uint32_t batchSize;
  /**<   Request the service with the number of location fixes to batch. */

  /* Optional */
  /*  Batching Type */
  uint8_t batchType_valid;  /**< Must be set to true if batchType is being passed */
  qmiLocBatchingTypeEnumT_v02 batchType;
  /**<   Identifies the batching type.
 Values: \n
      - eQMI_LOC_LOCATION_BATCHING (1) --  Location batching (default) \n
      - eQMI_LOC_OUTDOOR_TRIP_BATCHING (2) --  Outdoor trip batching
 */
}qmiLocGetBatchSizeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the batching size. */
typedef struct {

  /* Mandatory */
  /*  Get Batch Size Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_BATCH_SIZE_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_GET_BATCH_SIZE_REQ request.
       */

  /* Mandatory */
  /*  Batch Size Supported */
  uint32_t batchSize;
  /**<   Number of location fixes that the service is able to batch.
       The batch size value is returned as 0 in the case of a failure status.
  */
}qmiLocGetBatchSizeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to initiate a location batching session. */
typedef struct {

  /* Optional */
  /*  Minimum Interval Between Position Reports */
  uint8_t minInterval_valid;  /**< Must be set to true if minInterval is being passed */
  uint32_t minInterval;
  /**<   Minimum time interval, specified by the control point, that must elapse between
       position reports. \n
       - Units -- milliseconds \n
       - Default -- 60000 ms
  */

  /* Optional */
  /*  Horizontal Accuracy Level */
  uint8_t horizontalAccuracyLevel_valid;  /**< Must be set to true if horizontalAccuracyLevel is being passed */
  qmiLocAccuracyLevelEnumT_v02 horizontalAccuracyLevel;
  /**<   Specifies the horizontal accuracy level required by the control point.
 If not specified, accuracy defaults to low.
 Values: \n
      - eQMI_LOC_ACCURACY_LOW (1) --  Low accuracy \n
      - eQMI_LOC_ACCURACY_MED (2) --  Medium accuracy \n
      - eQMI_LOC_ACCURACY_HIGH (3) --  High accuracy
 */

  /* Optional */
  /*  Fix Session Timeout Period */
  uint8_t fixSessionTimeout_valid;  /**< Must be set to true if fixSessionTimeout is being passed */
  uint32_t fixSessionTimeout;
  /**<   Configures the fix session timeout duration. \n
       - Units -- Milliseconds \n
       - Default -- 20,000 ms
  */

  /* Optional */
  /*  Minimum Distance */
  uint8_t minDistance_valid;  /**< Must be set to true if minDistance is being passed */
  uint32_t minDistance;
  /**<   Specifies the minimum distance to traverse before a
       position is batched.
       If no distance is specified, the positions are batched after
       the minInterval period expires. If both minInterval and minDistance are
       specified, the position are batched only after minInterval has
       expired and  minDistance has been traversed. \n
       - Units -- Meters
  */

  /* Optional */
  /*  Batch All Positions */
  uint8_t batchAllPos_valid;  /**< Must be set to true if batchAllPos is being passed */
  uint8_t batchAllPos;
  /**<   Values: \n
       - TRUE -- All positions that are available must be batched. For example,
              if any other type of positioning is active (such as 1 Hz tracking), all
              positions computed for that use case are also batched. This can
              result in the BATCH_FULL indication getting generated earlier. \n
       - FALSE -- Only positions that meet the time and/or distance criteria are batched
                  (default).
  */

  /* Optional */
  /*  Request ID */
  uint8_t requestId_valid;  /**< Must be set to true if requestId is being passed */
  uint32_t requestId;
  /**<   Identifies the request; a batching client can start multiple batching
       requests with different batching parameters,
       however, positions corresponding to all requests from the same client are
       batched in the same buffer. A request ID value of 0 is considered invalid. \n
       - Valid values -- 0x01 -- 0xFFFFFFFF
  */
}qmiLocStartBatchingReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to initiate a location batching session. */
typedef struct {

  /* Mandatory */
  /*  Start Batching Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Start Batching request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Request ID */
  uint8_t requestId_valid;  /**< Must be set to true if requestId is being passed */
  uint32_t requestId;
  /**<   Identifies the request. A batching client can start multiple batching
       requests with different batching parameters, however, positions
       corresponding to all requests from the same client are
       batched in the same buffer. \n
       - Valid values -- -0x01 - 0xFFFFFFFF
  */
}qmiLocStartBatchingIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used to notify the control point that the batched buffer is full. */
typedef struct {

  /* Mandatory */
  /*  Number of Entries in the Batch During Full Event */
  uint32_t batchCount;
  /**<   Number of entries in the batch during a full event.
  */

  /* Optional */
  /*  Batching Type */
  uint8_t batchType_valid;  /**< Must be set to true if batchType is being passed */
  qmiLocBatchingTypeEnumT_v02 batchType;
  /**<   Identifies the batching type.
 Values: \n
      - eQMI_LOC_LOCATION_BATCHING (1) --  Location batching (default) \n
      - eQMI_LOC_OUTDOOR_TRIP_BATCHING (2) --  Outdoor trip batching
 */

  /* Optional */
  /*  Accumulated OTB Distance */
  uint8_t accumulatedDistance_valid;  /**< Must be set to true if accumulatedDistance is being passed */
  uint32_t accumulatedDistance;
  /**<   The accumulated outdoor trip batching (OTB) distance if the batchType is Outdoor Trip. \n
       - Units -- Meters
  */

  /* Optional */
  /*  Number of Batched Position Reports */
  uint8_t batchedPosition_valid;  /**< Must be set to true if batchedPosition is being passed */
  uint32_t batchedPosition;
  /**<   The number of position reports that have been batched from the last
       QMI_LOC_START_OUTDOOR_TRIP_BATCHING_REQ.
  */
}qmiLocEventBatchFullIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocBatchedReportValidFieldsMaskT_v02;
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_LATITUDE_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000001ull) /**<  Latitude field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_LONGITUDE_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000002ull) /**<  Longitude field\n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_HOR_CIR_UNC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000004ull) /**<  Horizontal circular uncertainty field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_HOR_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000008ull) /**<  Horizontal speed field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_UNC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000010ull) /**<  Speed uncertainty field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_ALT_WRT_ELP_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000020ull) /**<  Altitude with respect to ellipsoid field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_VER_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000040ull) /**<  Vertical speed field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_HEADING_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000080ull) /**<  Heading field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_HEADING_UNC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000100ull) /**<  Heading uncertainty field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_TECH_MASK_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000200ull) /**<  Technology source mask field \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_TIMESTAMP_UTC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000400ull) /**<  UTC timestamp field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_TIME_UNC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00000800ull) /**<  Time uncertainty field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_MAGNETIC_DEV_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00001000ull) /**<  Magnetic deviation field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_VERT_UNC_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00002000ull) /**<  Vertical uncertainty field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_HOR_CONF_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00004000ull) /**<  Horizontal confidence field  \n  */
#define QMI_LOC_BATCHED_REPORT_MASK_VALID_TIMESTAMP_GPS_V02 ((qmiLocBatchedReportValidFieldsMaskT_v02)0x00008000ull) /**<  GPS timestamp field   */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t fixId;
  /**<   Fix count for the session. The count starts at 0 and increments by one for
       each successive batched position report for a particular session. */

  qmiLocBatchedReportValidFieldsMaskT_v02 validFields;
  /**<   Mask of valid fields for this fix.
 Valid bitmasks: \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_LATITUDE (0x00000001) --  Latitude field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_LONGITUDE (0x00000002) --  Longitude field\n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_HOR_CIR_UNC (0x00000004) --  Horizontal circular uncertainty field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_HOR (0x00000008) --  Horizontal speed field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_UNC (0x00000010) --  Speed uncertainty field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_ALT_WRT_ELP (0x00000020) --  Altitude with respect to ellipsoid field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_SPEED_VER (0x00000040) --  Vertical speed field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_HEADING (0x00000080) --  Heading field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_HEADING_UNC (0x00000100) --  Heading uncertainty field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_TECH_MASK (0x00000200) --  Technology source mask field \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_TIMESTAMP_UTC (0x00000400) --  UTC timestamp field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_TIME_UNC (0x00000800) --  Time uncertainty field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_MAGNETIC_DEV (0x00001000) --  Magnetic deviation field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_VERT_UNC (0x00002000) --  Vertical uncertainty field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_HOR_CONF (0x00004000) --  Horizontal confidence field  \n
      - QMI_LOC_BATCHED_REPORT_MASK_VALID_TIMESTAMP_GPS (0x00008000) --  GPS timestamp field
 */

  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0  \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
     */

  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0  \n
        - Positive values indicate eastern longitude\n
        - Negative values indicate western longitude
        */

  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units -- Meters */

  float speedHorizontal;
  /**<   Horizontal speed.\n
       - Units -- Meters per second */

  float speedUnc;
  /**<   3D speed uncertainty.\n
       - Units -- Meters per second */

  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  float speedVertical;
  /**<   Vertical speed.\n
         - Units -- Meters per second */

  float heading;
  /**<   Heading.\n
         - Units -- Degrees \n
         - Range -- 0 to 359.999  */

  float headingUnc;
  /**<   Heading uncertainty.\n
       - Units -- Degrees \n
       - Range -- 0 to 359.999 */

  qmiLocPosTechMaskT_v02 technologyMask;
  /**<   Technology used in computing this fix.
 Valid bitmasks: \n
      - QMI_LOC_POS_TECH_MASK_SATELLITE (0x00000001) --  Satellites were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_CELLID (0x00000002) --  Cell towers were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_WIFI (0x00000004) --  Wi-Fi access points were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_SENSORS (0x00000008) --  Sensors were used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_REFERENCE_LOCATION (0x00000010) --  Reference location was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION (0x00000020) --  Coarse position injected into the location engine was used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_AFLT (0x00000040) --  AFLT was used to generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_HYBRID (0x00000080) --  GNSS and network-provided measurements were used to
        generate the fix. \n
      - QMI_LOC_POS_TECH_MASK_DRE (0x00000100) --  Dead reckoning engine (DRE) was used to generate the fix.
 */

  uint64_t timestampUtc;
  /**<   UTC timestamp. \n
       - Units -- Milliseconds since Jan. 1, 1970 */

  float timeUnc;
  /**<   - Units -- milliseconds */

  float magneticDeviation;
  /**<   Difference between the bearing to true north and the bearing shown
      on a magnetic compass. The deviation is positive when the magnetic
      north is east of true north. */

  float vertUnc;
  /**<   Vertical uncertainty.\n
       - Units -- Meters */

  uint8_t horConfidence;
  /**<   Horizontal confidence. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  qmiLocGPSTimeStructT_v02 gpsTime;
  /**<   Number of weeks since Jan. 5, 1980, and milliseconds into the current week. */
}qmiLocBatchedReportStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used to notify the control point with the live batched
                    position report. */
typedef struct {

  /* Mandatory */
  /*  Batched Position Report */
  qmiLocBatchedReportStructT_v02 liveBatchedReport;
  /**<   \n Live position report that is also batched. */
}qmiLocEventLiveBatchedPositionReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to retrieve fixes from the batch. */
typedef struct {

  /* Mandatory */
  /*  Number of Fix Entries to Retrieve from the Batch */
  uint32_t numberOfEntries;
  /**<   Number of fix entries to retrieve from the batch. \n
       - Maximum limit -- QMI_LOC_READ_FROM_BATCH_MAX_SIZE.
  */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_READ_FROM_BATCH_IND
       indication returns the transaction ID. */

  /* Optional */
  /*  Batching Type */
  uint8_t batchType_valid;  /**< Must be set to true if batchType is being passed */
  qmiLocBatchingTypeEnumT_v02 batchType;
  /**<   Identifies the batching type.
 Values: \n
      - eQMI_LOC_LOCATION_BATCHING (1) --  Location batching (default) \n
      - eQMI_LOC_OUTDOOR_TRIP_BATCHING (2) --  Outdoor trip batching
 */
}qmiLocReadFromBatchReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to retrieve fixes from the batch. */
typedef struct {

  /* Mandatory */
  /*  Read from Batch Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_READ_FROM_BATCH_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_READ_FROM_BATCH_REQ
       request.
       */

  /* Optional */
  /*  Number of Fix Entries Returned from the Batch */
  uint8_t numberOfEntries_valid;  /**< Must be set to true if numberOfEntries is being passed */
  uint32_t numberOfEntries;
  /**<   Number of fix entries returned from the batch. */

  /* Optional */
  /*  List of Batched Position Reports Returned */
  uint8_t batchedReportList_valid;  /**< Must be set to true if batchedReportList is being passed */
  uint32_t batchedReportList_len;  /**< Must be set to # of elements in batchedReportList */
  qmiLocBatchedReportStructT_v02 batchedReportList[QMI_LOC_READ_FROM_BATCH_MAX_SIZE_V02];
  /**<   \n List of fix reports returned from the batch. */
}qmiLocReadFromBatchIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to stop an ongoing batching session. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID of the request. */

  /* Optional */
  /*  Request ID */
  uint8_t requestId_valid;  /**< Must be set to true if requestId is being passed */
  uint32_t requestId;
  /**<   Identifies the location batching request that must be stopped.
       A location batching client can start multiple batching requests. \n
       Values: \n
       - 0x01 -- 0xFFFFFFFF
  */

  /* Optional */
  /*  Batching Type */
  uint8_t batchType_valid;  /**< Must be set to true if batchType is being passed */
  qmiLocBatchingTypeEnumT_v02 batchType;
  /**<   Identifies the batching type.
 Values: \n
      - eQMI_LOC_LOCATION_BATCHING (1) --  Location batching (default) \n
      - eQMI_LOC_OUTDOOR_TRIP_BATCHING (2) --  Outdoor trip batching
 */
}qmiLocStopBatchingReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to stop an ongoing batching session. */
typedef struct {

  /* Mandatory */
  /*  Stop Batching Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_STOP_BATCHING_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_STOP_BATCHING_REQ request.
  */

  /* Optional */
  /*  Request ID */
  uint8_t requestId_valid;  /**< Must be set to true if requestId is being passed */
  uint32_t requestId;
  /**<   Identifies the location batching request that was stopped.
       A location batching client can start multiple batching requests. \n
       Values: \n
       - 0x01 -- 0xFFFFFFFF
  */
}qmiLocStopBatchingIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to release the batching buffer. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. */

  /* Optional */
  /*  Batching Type */
  uint8_t batchType_valid;  /**< Must be set to true if batchType is being passed */
  qmiLocBatchingTypeEnumT_v02 batchType;
  /**<   Identifies the batching type.
 Values: \n
      - eQMI_LOC_LOCATION_BATCHING (1) --  Location batching (default) \n
      - eQMI_LOC_OUTDOOR_TRIP_BATCHING (2) --  Outdoor trip batching
 */
}qmiLocReleaseBatchReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to release the batching buffer. */
typedef struct {

  /* Mandatory */
  /*  Release Batch Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_RELEASE_BATCH_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Transaction ID specified in the QMI_LOC_RELEASE_BATCH_REQ request.
  */
}qmiLocReleaseBatchIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to inject Wi-Fi AP data. */
typedef struct {

  /* Optional */
  /*  E911 Mode */
  uint8_t e911Mode_valid;  /**< Must be set to true if e911Mode is being passed */
  uint8_t e911Mode;
  /**<   Indicates whether the GPS engine is in E911 mode when this
       indication is sent to the client.
       Values: \n
       - 0x01 (TRUE) -- GPS engine is in E911 mode \n
       - 0x00 (FALSE) -- GPS engine is not in E911 mode
    */
}qmiLocEventInjectWifiApDataReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIAPDATADEVICETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_A_V02 = 0, /**<  Wi-Fi AP device is 802.11a. \n */
  eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_B_V02 = 1, /**<  Wi-Fi AP device is 802.11b. \n */
  eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_G_V02 = 2, /**<  Wi-Fi AP device is 802.11g.  */
  QMILOCWIFIAPDATADEVICETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiApDataDeviceTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIAPDATARTDUNITTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_MICROSEC_V02 = 0, /**<  Wi-Fi AP data Round-trip Delay (RTD) is in microseconds. \n */
  eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_HUNDREDS_OF_NANOSEC_V02 = 1, /**<  Wi-Fi AP data RTD is in hundreds of nanoseconds. \n */
  eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_TENS_OF_NANOSEC_V02 = 2, /**<  Wi-Fi AP data RTD is in tens of nanoseconds. \n */
  eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_NANOSEC_V02 = 3, /**<  Wi-Fi AP data RTD is in nanoseconds. \n */
  eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_TENTH_OF_NANOSEC_V02 = 4, /**<  Wi-Fi AP data RTD is in tenths of nanoseconds.  */
  QMILOCWIFIAPDATARTDUNITTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiApDataRtdUnitTypeEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocWifiApDataMaskT_v02;
#define QMI_LOC_WIFI_APDATA_MASK_AP_TRANSMIT_POWER_V02 ((qmiLocWifiApDataMaskT_v02)0x00000001) /**<  AP transmit power is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_AP_ANTENNA_GAIN_V02 ((qmiLocWifiApDataMaskT_v02)0x00000002) /**<  AP antenna gain is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_AP_SNR_V02 ((qmiLocWifiApDataMaskT_v02)0x00000004) /**<  AP signal-to-noise ratio is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_AP_DEVICE_TYPE_V02 ((qmiLocWifiApDataMaskT_v02)0x00000008) /**<  AP device type is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_AP_RSSI_V02 ((qmiLocWifiApDataMaskT_v02)0x00000010) /**<  AP RSSI is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_AP_CHANNEL_V02 ((qmiLocWifiApDataMaskT_v02)0x00000020) /**<  AP channel is valid    */
#define QMI_LOC_WIFI_APDATA_MASK_AP_ROUNDTRIP_DELAY_V02 ((qmiLocWifiApDataMaskT_v02)0x00000040) /**<  AP roundtrip delay is valid    */
#define QMI_LOC_WIFI_APDATA_MASK_AP_ROUNDTRIP_DELAY_ACCURACY_V02 ((qmiLocWifiApDataMaskT_v02)0x00000080) /**<  AP roundtrip delay accuracy is valid   */
#define QMI_LOC_WIFI_APDATA_MASK_MOBILE_SNR_V02 ((qmiLocWifiApDataMaskT_v02)0x00000100) /**<  Mobile signal-to-noise ratio is valid   */
#define QMI_LOC_WIFI_APDATA_MASK_MOBILE_RSSI_V02 ((qmiLocWifiApDataMaskT_v02)0x00000200) /**<  Mobile RSSI is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_RSSI_TIMESTAMP_V02 ((qmiLocWifiApDataMaskT_v02)0x00000400) /**<  RSSI timestamp is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_MEASUREMENT_AGE_V02 ((qmiLocWifiApDataMaskT_v02)0x00000800) /**<  Measurement age is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_SERVING_AP_V02 ((qmiLocWifiApDataMaskT_v02)0x00001000) /**<  Serving access point is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_FREQUENCY_V02 ((qmiLocWifiApDataMaskT_v02)0x00002000) /**<  Channel frequency is valid  */
#define QMI_LOC_WIFI_APDATA_MASK_SSID_V02 ((qmiLocWifiApDataMaskT_v02)0x00004000) /**<  SSID is valid  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocWifiApDataMaskT_v02 wifiApDataMask;
  /**<   Specifies which Wi-Fi AP scan information types are in use.
 Values: \n
      - QMI_LOC_WIFI_APDATA_MASK_AP_TRANSMIT_POWER (0x00000001) --  AP transmit power is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_ANTENNA_GAIN (0x00000002) --  AP antenna gain is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_SNR (0x00000004) --  AP signal-to-noise ratio is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_DEVICE_TYPE (0x00000008) --  AP device type is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_RSSI (0x00000010) --  AP RSSI is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_CHANNEL (0x00000020) --  AP channel is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_ROUNDTRIP_DELAY (0x00000040) --  AP roundtrip delay is valid
      - QMI_LOC_WIFI_APDATA_MASK_AP_ROUNDTRIP_DELAY_ACCURACY (0x00000080) --  AP roundtrip delay accuracy is valid
      - QMI_LOC_WIFI_APDATA_MASK_MOBILE_SNR (0x00000100) --  Mobile signal-to-noise ratio is valid
      - QMI_LOC_WIFI_APDATA_MASK_MOBILE_RSSI (0x00000200) --  Mobile RSSI is valid
      - QMI_LOC_WIFI_APDATA_MASK_RSSI_TIMESTAMP (0x00000400) --  RSSI timestamp is valid
      - QMI_LOC_WIFI_APDATA_MASK_MEASUREMENT_AGE (0x00000800) --  Measurement age is valid
      - QMI_LOC_WIFI_APDATA_MASK_SERVING_AP (0x00001000) --  Serving access point is valid
      - QMI_LOC_WIFI_APDATA_MASK_FREQUENCY (0x00002000) --  Channel frequency is valid
      - QMI_LOC_WIFI_APDATA_MASK_SSID (0x00004000) --  SSID is valid  */

  uint8_t macAddress[QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02];
  /**<   MAC address. \n
       Each address is of length QMI_LOC_WIFI_MAC_ADDR_LENGTH.
  */

  int32_t apTransmitPower;
  /**<   AP transmit power in dBm.  */

  int32_t apAntennaGain;
  /**<   AP antenna gain in dBI. */

  int32_t apSignalToNoise;
  /**<   AP SNR received at the mobile device. */

  qmiLocWifiApDataDeviceTypeEnumT_v02 apDeviceType;
  /**<   List of AP device types.\n      - eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_A (0) --  Wi-Fi AP device is 802.11a. \n
      - eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_B (1) --  Wi-Fi AP device is 802.11b. \n
      - eQMI_LOC_WIFI_AP_DATA_DEVICE_TYPE_WLAN_802_11_G (2) --  Wi-Fi AP device is 802.11g.  */

  int32_t apRssi;
  /**<   AP signal strength indicator in dBm. */

  uint16_t apChannel;
  /**<   AP Wi-Fi channel on which a beacon was received. */

  uint32_t apRoundTripDelay;
  /**<   Round trip delay between the mobile device and the AP, in units of
       apRoundTripDelayUnit. */

  qmiLocWifiApDataRtdUnitTypeEnumT_v02 apRoundTripDelayUnit;
  /**<   Units of apRoundTripDelay and its accuracy; mandatory if apRoundTripDelay
 is present. \n      - eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_MICROSEC (0) --  Wi-Fi AP data Round-trip Delay (RTD) is in microseconds. \n
      - eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_HUNDREDS_OF_NANOSEC (1) --  Wi-Fi AP data RTD is in hundreds of nanoseconds. \n
      - eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_TENS_OF_NANOSEC (2) --  Wi-Fi AP data RTD is in tens of nanoseconds. \n
      - eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_NANOSEC (3) --  Wi-Fi AP data RTD is in nanoseconds. \n
      - eQMI_LOC_WIFI_AP_DATA_RTD_UNIT_TENTH_OF_NANOSEC (4) --  Wi-Fi AP data RTD is in tenths of nanoseconds.  */

  uint8_t apRoundTripDelayAccuracy;
  /**<   AP's accuracy of round trip delay apRoundTripDelay, in units of
       apRoundTripDelayUnit. */

  int32_t mobileSignalToNoise;
  /**<   Mobile SNR received at the AP. */

  int32_t mobileRssi;
  /**<   Mobile signal strength at the AP. */
}qmiLocWifiApDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  int64_t rssiTimestamp;
  /**<   Measurement time stamp corresponding to when the beacon was received. \n
       Units -- Milliseconds*/

  int32_t measAge;
  /**<   Measurements age; -1 means information is not available.\n
       Units -- Milliseconds */

  uint8_t servingAccessPoint;
  /**<   Indicates whether a set of WLAN-AP measurements
       were obtained for a serving WLAN-AP (TRUE) or a nonserving WLAN-AP (FALSE).
       A target device with multiple radio support can indicate more than
       one type of serving access for the same time instant.*/

  uint32_t channelFrequency;
  /**<   Primary channel frequency.\n
       Units -- MHz */

  char ssid[QMI_LOC_MAX_WIFI_AP_SSID_STR_LENGTH_V02 + 1];
  /**<   NULL-terminated SSID of the Wi-Fi AP.
       Its maximum length according to the ASCII standard is 32 octets. */

  int32_t apHighResolutionRssi;
  /**<   AP signal strength indicator in dBm.\n
       Units -- 0.1 dBm */
}qmiLocWifiApAdditionalDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWLANAPERRENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WLAN_AP_ERR_UNKNOWN_V02 = 0, /**<  Error is unknown \n */
  eQMI_LOC_WLAN_AP_ERR_NO_REQ_MEAS_AVAILABLE_V02 = 1, /**<  None of the requested measurements could be provided \n  */
  eQMI_LOC_WLAN_AP_ERR_WIFI_OFF_V02 = 2, /**<  Wi-Fi is off  */
  QMILOCWLANAPERRENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWlanApErrEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects Wi-Fi AP data. */
typedef struct {

  /* Mandatory */
  /*  Wi-Fi AP Scan Data */
  uint32_t wifiApInfo_len;  /**< Must be set to # of elements in wifiApInfo */
  qmiLocWifiApDataStructT_v02 wifiApInfo[QMI_LOC_WIFI_MAX_REPORTED_APS_PER_MSG_V02];
  /**<   \n List of Wi-Fi AP scan information entered by the control point. */

  /* Optional */
  /*  Failure Reason for WLAN-AP Measurements Not Available  */
  uint8_t errorCause_valid;  /**< Must be set to true if errorCause is being passed */
  qmiLocWlanApErrEnumT_v02 errorCause;
  /**<   If WLAN-AP measurements are not available,
 indicate the reason for the error/failure.
 This field is not present when WLAN-AP measurements are available.
 Values: \n
      - eQMI_LOC_WLAN_AP_ERR_UNKNOWN (0) --  Error is unknown \n
      - eQMI_LOC_WLAN_AP_ERR_NO_REQ_MEAS_AVAILABLE (1) --  None of the requested measurements could be provided \n
      - eQMI_LOC_WLAN_AP_ERR_WIFI_OFF (2) --  Wi-Fi is off  */

  /* Optional */
  /*  Scan Request Timestamp */
  uint8_t requestTimestamp_valid;  /**< Must be set to true if requestTimestamp is being passed */
  int64_t requestTimestamp;
  /**<   UTC timestamp at which the scan was requested. \n
       - Units -- Milliseconds */

  /* Optional */
  /*  Scan Receive Timestamp */
  uint8_t receiveTimestamp_valid;  /**< Must be set to true if receiveTimestamp is being passed */
  int64_t receiveTimestamp;
  /**<   UTC timestamp at which the scan was received. \n
       - Units -- Milliseconds */

  /* Optional */
  /*  Free Scan or On-Demand Scan */
  uint8_t onDemandScan_valid;  /**< Must be set to true if onDemandScan is being passed */
  uint8_t onDemandScan;
  /**<   Indicates whether the modem requested this scan.\n
        - 0x00 (FALSE) -- The Wi-Fi AP data injection was not requested by the modem (free scan).\n
        - 0x01 (TRUE) -- The Wi-Fi AP data injection was requested by the modem (0n-demand scan).
      */

  /* Optional */
  /*  Wi-Fi AP Additional Measurements Scan Data */
  uint8_t wifiApInfoA_valid;  /**< Must be set to true if wifiApInfoA is being passed */
  uint32_t wifiApInfoA_len;  /**< Must be set to # of elements in wifiApInfoA */
  qmiLocWifiApAdditionalDataStructT_v02 wifiApInfoA[QMI_LOC_WIFI_MAX_REPORTED_APS_PER_MSG_V02];
  /**<   \n List of Wi-Fi AP additional measurements scan information entered by the control point.
          The order and the number of additional measurements must be the same as wifiApInfo. */

  /* Optional */
  /*  UE Wi-Fi Mac Address */
  uint8_t ueMacAddress_valid;  /**< Must be set to true if ueMacAddress is being passed */
  uint8_t ueMacAddress[QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02];
  /**<   Wi-Fi MAC address of the UE. \n
       Address is of length QMI_LOC_WIFI_MAC_ADDR_LENGTH.
  */
}qmiLocInjectWifiApDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects Wi-Fi AP data. */
typedef struct {

  /* Mandatory */
  /*  Wi-Fi AP Scan Information Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Wi-Fi AP Scan Information request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectWifiApDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIACCESSPOINTATTACHSTATESENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_ACCESS_POINT_ATTACHED_V02 = 0, /**<  Attached to an access point \n */
  eQMI_LOC_WIFI_ACCESS_POINT_DETACHED_V02 = 1, /**<  Detached from an access point \n */
  eQMI_LOC_WIFI_ACCESS_POINT_HANDOVER_V02 = 2, /**<  Handed over to another access point  */
  QMILOCWIFIACCESSPOINTATTACHSTATESENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiAccessPointAttachStatesEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject the Wi-Fi attachment status. */
typedef struct {

  /* Mandatory */
  /*  Attach State */
  qmiLocWifiAccessPointAttachStatesEnumT_v02 attachState;
  /**<   Wi-Fi access point attach state.
 Values: \n
      - eQMI_LOC_WIFI_ACCESS_POINT_ATTACHED (0) --  Attached to an access point \n
      - eQMI_LOC_WIFI_ACCESS_POINT_DETACHED (1) --  Detached from an access point \n
      - eQMI_LOC_WIFI_ACCESS_POINT_HANDOVER (2) --  Handed over to another access point  */

  /* Optional */
  /*  Access Point MAC Address */
  uint8_t accessPointMacAddress_valid;  /**< Must be set to true if accessPointMacAddress is being passed */
  uint8_t accessPointMacAddress[QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02];
  /**<   MAC address of the access point to which the Wi-Fi is attached.
        This must always be specified if the attach state is Handover.
        */

  /* Optional */
  /*  Wi-Fi AP SSID String */
  uint8_t wifiApSsid_valid;  /**< Must be set to true if wifiApSsid is being passed */
  char wifiApSsid[QMI_LOC_MAX_WIFI_AP_SSID_STR_LENGTH_V02 + 1];
  /**<   The NULL-terminated SSID of the Wi-Fi AP. Its maximum length according to the ASCII standard is 32 octets. */
}qmiLocNotifyWifiAttachmentStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject the Wi-Fi attachment status. */
typedef struct {

  /* Mandatory */
  /*  Status of Wi-Fi Attachment Status Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of Wi-Fi Attachment Status request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocNotifyWifiAttachmentStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCWIFIENABLEDSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_WIFI_ENABLED_FALSE_V02 = 0, /**<  Wi-Fi is disabled on the device \n */
  eQMI_LOC_WIFI_ENABLED_TRUE_V02 = 1, /**<  Wi-Fi is enabled on the device  */
  QMILOCWIFIENABLEDSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocWifiEnabledStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject the Wi-Fi enabled status. */
typedef struct {

  /* Mandatory */
  /*  Enabled Status */
  qmiLocWifiEnabledStatusEnumT_v02 enabledStatus;
  /**<   Wi-Fi enabled status on the device.
 Values: \n
      - eQMI_LOC_WIFI_ENABLED_FALSE (0) --  Wi-Fi is disabled on the device \n
      - eQMI_LOC_WIFI_ENABLED_TRUE (1) --  Wi-Fi is enabled on the device  */
}qmiLocNotifyWifiEnabledStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject the Wi-Fi enabled status. */
typedef struct {

  /* Mandatory */
  /*  Status of Wi-Fi Enabled Status Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Wi-Fi Enabled Status request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocNotifyWifiEnabledStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point whether the GNSS location engine is
                    ready to accept vehicle data. */
typedef struct {

  /* Optional */
  /*  Vehicle Accelerometer Ready Status */
  uint8_t vehicleAccelReadyStatus_valid;  /**< Must be set to true if vehicleAccelReadyStatus is being passed */
  uint8_t vehicleAccelReadyStatus;
  /**<   The location service uses this TLV to let a control point know when it is
       ready to receive vehicle accelerometer data input.
       Values: \n
       - 0x00 -- Not ready  \n
       - 0x01 -- Ready */

  /* Optional */
  /*  Vehicle Angular Rate Ready Status */
  uint8_t vehicleAngularRateReadyStatus_valid;  /**< Must be set to true if vehicleAngularRateReadyStatus is being passed */
  uint8_t vehicleAngularRateReadyStatus;
  /**<   The location service uses this TLV to let a control point know when it is
       ready to receive vehicle angular rate data input.
       Values: \n
       - 0x00 -- Not ready \n
       - 0x01 -- Ready */

  /* Optional */
  /*  Vehicle Odometry Ready Status */
  uint8_t vehicleOdometryReadyStatus_valid;  /**< Must be set to true if vehicleOdometryReadyStatus is being passed */
  uint8_t vehicleOdometryReadyStatus;
  /**<   The location service uses this TLV to let a control point know when it is
       ready to receive vehicle odometry data input.
       Values: \n
       - 0x00 -- Not ready \n
       - 0x01 -- Ready*/
}qmiLocEventVehicleDataReadyIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t timeOffset;
  /**<   Sample time offset. This time offset must be
       relative to the vehicle sensor time of the first sample. \n
       - Units -- Microseconds \n
       - Range -- Up to over 4000 seconds */

  uint32_t axisSample_len;  /**< Must be set to # of elements in axisSample */
  float axisSample[QMI_LOC_VEHICLE_SENSOR_DATA_MAX_AXES_V02];
  /**<   Sensor axis sample.   \n
       - Type -- Floating point   \n
       - Units accelerometer -- Meters per seconds^2 \n
       - Units gyroscope -- Radians per seconds \n
       Note: The axes samples must be in the following order: \n
             1. X-axis \n
             2. Y-axis \n
             3. Z-axis */
}qmiLocVehicleSensorSampleStructT_v02;  /* Type */
/**
    @}
  */

typedef uint8_t qmiLocAxesMaskT_v02;
#define QMI_LOC_MASK_X_AXIS_V02 ((qmiLocAxesMaskT_v02)0x01) /**<  X-axis is valid \n  */
#define QMI_LOC_MASK_Y_AXIS_V02 ((qmiLocAxesMaskT_v02)0x02) /**<  Y-axis is valid \n  */
#define QMI_LOC_MASK_Z_AXIS_V02 ((qmiLocAxesMaskT_v02)0x04) /**<  Z-axis is valid  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t sampleTimeBase;
  /**<   32-bit time tag of the reference time from which
       all samples in this message are offset. This time must
       be the same as or (slightly) earlier than the first (oldest)
       sample in this message. \n
       - Units -- Milliseconds \n
       - Range -- Approx. 4 million seconds, or almost 50 days between rollovers */

  qmiLocAxesMaskT_v02 axesValidity;
  /**<   Axes that are valid for all sensor samples.
 Values: \n
      - QMI_LOC_MASK_X_AXIS (0x01) --  X-axis is valid \n
      - QMI_LOC_MASK_Y_AXIS (0x02) --  Y-axis is valid \n
      - QMI_LOC_MASK_Z_AXIS (0x04) --  Z-axis is valid  */

  uint32_t sensorData_len;  /**< Must be set to # of elements in sensorData */
  qmiLocVehicleSensorSampleStructT_v02 sensorData[QMI_LOC_VEHICLE_SENSOR_DATA_MAX_SAMPLES_V02];
  /**<   Variable length array specifying the on-vehicle sensor samples;
       maximum length of the array is 50 */
}qmiLocVehicleSensorSampleListStructType_v02;  /* Type */
/**
    @}
  */

typedef uint32_t qmiLocVehicleOdometryMeasDeviationMaskType_v02;
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_REVERSE_MOVEMENT_V02 ((qmiLocVehicleOdometryMeasDeviationMaskType_v02)0x00000001) /**<  Odometry data in this message includes at least some data where
       the vehicle might have been moving in the reverse direction; this
       bit must be set if odometry data might be in reverse, and must
       not be set if odometry data is all in the forward direction \n  */
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_AFFECTED_BY_ERRORS_V02 ((qmiLocVehicleOdometryMeasDeviationMaskType_v02)0x00000002) /**<  Odometry data in this message includes at least some data affected
       by a major error source affecting distance-traveled accuracy,
       such as wheel slippage due to skidding, gravel, snow, or ice, as
       detected by the vehicle, for example, via an ABS or other system \n  */
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_ABSOLUTE_MEASUREMENT_V02 ((qmiLocVehicleOdometryMeasDeviationMaskType_v02)0x00000004) /**<  Odometry data in this message is an absolute amount since the vehicle
       began service, and is the same vehicle that is regularly used with
       this device (so that the offset of this value, since the last time
       this measurement was used by the location engine, can safely be used
       as a likely correct estimate of distance traveled since last
       use)  */
typedef uint32_t qmiLocVehicleOdometryWheelFlagsMaskT_v02;
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_LEFT_AND_RIGHT_AVERAGE_V02 ((qmiLocVehicleOdometryWheelFlagsMaskT_v02)0x00000001) /**<  Average of left and right non-turning wheels \n  */
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_LEFT_V02 ((qmiLocVehicleOdometryWheelFlagsMaskT_v02)0x00000002) /**<  Left side, non-turning wheel \n  */
#define QMI_LOC_MASK_VEHICLE_ODOMETRY_RIGHT_V02 ((qmiLocVehicleOdometryWheelFlagsMaskT_v02)0x00000004) /**<  Right side, non-turning wheel  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t timeOffset;
  /**<   Sample time offset; must be
       relative to the sensor time of the first sample. \n
       - Units -- Microseconds \n
       - Range -- Up to over 4000 seconds */

  uint32_t distanceTravelled_len;  /**< Must be set to # of elements in distanceTravelled */
  uint32_t distanceTravelled[QMI_LOC_VEHICLE_ODOMETRY_MAX_MEASUREMENTS_V02];
  /**<    Distance traveled (odometry) sample offset. \n
        - Units of accumulated distance -- Millimeters \n
        - Range -- Over 4000 kilometers\n

        This measurement (with units in millimeters) is added to
        the distance_travelled_base measurement (in meters) to
        get the total distance traveled sample value.

        Note: The order of measurements must be as follows: \n
        1. Left and right average  \n
        2. Left \n
        3. Right
   */
}qmiLocVehicleOdometrySampleStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t sampleTimeBase;
  /**<   32-bit time tag of a reference time from which
       all samples in this message are offset. This time must
       be the same or slightly earlier than the first (oldest)
       sample in this message. \n
       - Units -- 1 millisecond \n
       - Range -- ~4 million seconds, or almost 50 days between rollovers */

  qmiLocVehicleOdometryMeasDeviationMaskType_v02 flags;
  /**<   Flags indicating any deviation from the default measurement
 assumptions. Valid bitmasks: \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_REVERSE_MOVEMENT (0x00000001) --  Odometry data in this message includes at least some data where
       the vehicle might have been moving in the reverse direction; this
       bit must be set if odometry data might be in reverse, and must
       not be set if odometry data is all in the forward direction \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_AFFECTED_BY_ERRORS (0x00000002) --  Odometry data in this message includes at least some data affected
       by a major error source affecting distance-traveled accuracy,
       such as wheel slippage due to skidding, gravel, snow, or ice, as
       detected by the vehicle, for example, via an ABS or other system \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_ABSOLUTE_MEASUREMENT (0x00000004) --  Odometry data in this message is an absolute amount since the vehicle
       began service, and is the same vehicle that is regularly used with
       this device (so that the offset of this value, since the last time
       this measurement was used by the location engine, can safely be used
       as a likely correct estimate of distance traveled since last
       use)  */

  qmiLocVehicleOdometryWheelFlagsMaskT_v02 wheelFlags;
  /**<   Wheels for which measurements are provided
 in the following samples, where one or more of the following
 bits must be set, and data samples aligned with these axes must
 appear in groups, in this order.
 Valid bitmasks: \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_LEFT_AND_RIGHT_AVERAGE (0x00000001) --  Average of left and right non-turning wheels \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_LEFT (0x00000002) --  Left side, non-turning wheel \n
      - QMI_LOC_MASK_VEHICLE_ODOMETRY_RIGHT (0x00000004) --  Right side, non-turning wheel  */

  uint32_t distanceTravelledBase;
  /**<   Distance traveled base. \n
        - Units of accumulated distance -- Meters \n
        - Range -- Over 4,000,000 kilometers \n

        Distance traveled (odometry) must be reported in a continuously
        accumulating way from device power up. It can be incremental distance
        starting at 0, or another arbitrary point, from device power up, or the
        absolute distance traveled by the vehicle
        (and if so, set QMI_LOC_MASK_VEHICLE_ODOMETRY_ABSOLUTE_MEASUREMENT),
        as long as it grows incrementally from device power up.

        This distance_travelled_base is added to the distance_travelled_offset
        of each sample (below) to get the absolute distance of each sample
        point.

        Distance traveled errors are primarily due to the
        scale factor, with some allowance for noise due to minor slippage
        events (for example, gravel).
        Major wheel slippage events that affect odometry
        must be flagged -- see the flags field.

        Other events, such as a vehicle traveling in reverse, can
        also affect the available accuracy of this information, and notification
        of those events must be provided -- see the flags field. */

  uint32_t odometryData_len;  /**< Must be set to # of elements in odometryData */
  qmiLocVehicleOdometrySampleStructT_v02 odometryData[QMI_LOC_VEHICLE_SENSOR_DATA_MAX_SAMPLES_V02];
  /**<   Variable length array specifying the odometry samples.
       Maximum length of the array is 50. */
}qmiLocVehicleOdometrySampleListStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects on-vehicle sensor data into the location engine. */
typedef struct {

  /* Optional */
  /*  On-Vehicle Accelerometer Data */
  uint8_t accelData_valid;  /**< Must be set to true if accelData is being passed */
  qmiLocVehicleSensorSampleListStructType_v02 accelData;
  /**<   \vspace{0.06in} \n Vehicle accelerometer sensor samples. */

  /* Optional */
  /*  On-Vehicle Angular Rotation Data */
  uint8_t angRotationData_valid;  /**< Must be set to true if angRotationData is being passed */
  qmiLocVehicleSensorSampleListStructType_v02 angRotationData;
  /**<   \vspace{0.06in} \n Vehicle angular rotation data sensor samples. */

  /* Optional */
  /*  Odometry Data */
  uint8_t odometryData_valid;  /**< Must be set to true if odometryData is being passed */
  qmiLocVehicleOdometrySampleListStructT_v02 odometryData;
  /**<   \vspace{0.06in} \n Odometer sensor samples. */

  /* Optional */
  /*  External Time Sync Information */
  uint8_t changeInTimeScales_valid;  /**< Must be set to true if changeInTimeScales is being passed */
  int32_t changeInTimeScales;
  /**<   This field is used in conjunction with an external
       time-sync mechanism that is aligning the vehicle sensor time scale
       with the on-device sensor time scale to ensure that updates in
       that time offset do not appear as jumps in the relative sensor time
       of the samples provided in this message. If there is no such sync
       mechanism, for example, if only the vehicle time is provided, this field
       can be left at 0.

       This field is defined as the change from the previously-sent QMI
       message with similar TLVs 0x10, 0x11, or 0x12 in it, to this QMI
       message in the amount that the sensor_time is ahead of an
       external vehicle time. \n
       - Units -- Microseconds \n
       - Range -- Approximately -2100 seconds to + 2100 seconds, where
                full-scale (minimum and maximum value) is interpreted
                as equal to or greater than this value of an offset change
                (unlikely to be reached in practice, unless there is a
                startup, major resync, or some other rollover event). */
}qmiLocInjectVehicleSensorDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects on-vehicle sensor data into the location engine. */
typedef struct {

  /* Mandatory */
  /*  Inject Vehicle Sensor Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Vehicle Sensor Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectVehicleSensorDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the first available WWAN
                    position from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_GET_AVAILABLE_WWAN_POSITION_IND indication
       returns the transaction ID. */
}qmiLocGetAvailWwanPositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the first available WWAN
                    position from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Get Available WWAN Position Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_GET_AVAILABLE_WWAN_POSITION_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the
       QMI_LOC_GET_AVAILABLE_WWAN_POSITION_REQ request. This parameter is
       always present when the status field is set to SUCCESS. */

  /* Optional */
  /*  Latitude */
  uint8_t latitude_valid;  /**< Must be set to true if latitude is being passed */
  double latitude;
  /**<   Latitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0 \n
         - Positive values indicate northern latitude \n
         - Negative values indicate southern latitude
    */

  /* Optional */
  /*  Longitude */
  uint8_t longitude_valid;  /**< Must be set to true if longitude is being passed */
  double longitude;
  /**<   Longitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units --  Degrees \n
       - Range -- -180.0 to 180.0 \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
      */

  /* Optional */
  /*  Circular Horizontal Position Uncertainty */
  uint8_t horUncCircular_valid;  /**< Must be set to true if horUncCircular is being passed */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units -- Meters */

  /* Optional */
  /*  Altitude With Respect to Ellipsoid */
  uint8_t altitudeWrtEllipsoid_valid;  /**< Must be set to true if altitudeWrtEllipsoid is being passed */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   Vertical uncertainty.\n
       - Units -- Meters */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds since Jan. 1, 1970 */

  /* Optional */
  /*  Time Uncertainty */
  uint8_t timeUnc_valid;  /**< Must be set to true if timeUnc is being passed */
  float timeUnc;
  /**<  - Units -- Milliseconds */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Minor Axis */
  uint8_t horUncEllipseSemiMinor_valid;  /**< Must be set to true if horUncEllipseSemiMinor is being passed */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty. \n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Major Axis */
  uint8_t horUncEllipseSemiMajor_valid;  /**< Must be set to true if horUncEllipseSemiMajor is being passed */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty. \n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Azimuth */
  uint8_t horUncEllipseOrientAzimuth_valid;  /**< Must be set to true if horUncEllipseOrientAzimuth is being passed */
  float horUncEllipseOrientAzimuth;
  /**<   Elliptical horizontal uncertainty azimuth of orientation. \n
       - Units -- Decimal degrees \n
       - Range -- 0 to 180 */

  /* Optional */
  /*  Horizontal Circular Confidence */
  uint8_t horCircularConfidence_valid;  /**< Must be set to true if horCircularConfidence is being passed */
  uint8_t horCircularConfidence;
  /**<   Horizontal circular uncertainty confidence. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Horizontal Elliptical Confidence */
  uint8_t horEllipticalConfidence_valid;  /**< Must be set to true if horEllipticalConfidence is being passed */
  uint8_t horEllipticalConfidence;
  /**<   Horizontal elliptical uncertainty confidence. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horReliability_valid;  /**< Must be set to true if horReliability is being passed */
  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Altitude With Respect to Sea Level */
  uint8_t altitudeWrtMeanSeaLevel_valid;  /**< Must be set to true if altitudeWrtMeanSeaLevel is being passed */
  float altitudeWrtMeanSeaLevel;
  /**<   Altitude with respect to mean sea level. \n
       - Units -- Meters */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence. \n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Reliability */
  uint8_t vertReliability_valid;  /**< Must be set to true if vertReliability is being passed */
  qmiLocReliabilityEnumT_v02 vertReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  GPS Time */
  uint8_t gpsTime_valid;  /**< Must be set to true if gpsTime is being passed */
  qmiLocGPSTimeStructT_v02 gpsTime;

  /* Optional */
  /*  Time Source */
  uint8_t timeSrc_valid;  /**< Must be set to true if timeSrc is being passed */
  qmiLocTimeSourceEnumT_v02 timeSrc;
  /**<   Time source.
 Values: \n
      - eQMI_LOC_TIME_SRC_INVALID (0) --  Invalid time \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TRANSFER (1) --  Time is set by the 1X system \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TAGGING (2) --  Time is set by WCDMA/GSM time tagging (that is,
       associating network time with GPS time) \n
      - eQMI_LOC_TIME_SRC_EXTERNAL_INPUT (3) --  Time is set by an external injection \n
      - eQMI_LOC_TIME_SRC_TOW_DECODE (4) --  Time is set after decoding over-the-air GPS navigation data
       from one GPS satellite \n
      - eQMI_LOC_TIME_SRC_TOW_CONFIRMED (5) --  Time is set after decoding over-the-air GPS navigation data
       from multiple satellites \n
      - eQMI_LOC_TIME_SRC_TOW_AND_WEEK_CONFIRMED (6) --  Both time of the week and the GPS week number are known \n
      - eQMI_LOC_TIME_SRC_NAV_SOLUTION (7) --  Time is set by the position engine after the fix is obtained \n
      - eQMI_LOC_TIME_SRC_SOLVE_FOR_TIME (8) --  Time is set by the position engine after performing SFT;
       this is done when the clock time uncertainty is large \n
      - eQMI_LOC_TIME_SRC_GLO_TOW_DECODE (9) --  Time is set after decoding GLO satellites \n
      - eQMI_LOC_TIME_SRC_TIME_TRANSFORM (10) --  Time is set after transforming the GPS to GLO time \n
      - eQMI_LOC_TIME_SRC_WCDMA_SLEEP_TIME_TAGGING (11) --  Time is set by the sleep time tag provided by the WCDMA network \n
      - eQMI_LOC_TIME_SRC_GSM_SLEEP_TIME_TAGGING (12) --  Time is set by the sleep time tag provided by the GSM network \n
      - eQMI_LOC_TIME_SRC_UNKNOWN (13) --  Source of the time is unknown \n
      - eQMI_LOC_TIME_SRC_SYSTEM_TIMETICK (14) --  Time is derived from the system clock (better known as the slow clock);
       GNSS time is maintained irrespective of the GNSS receiver state \n
      - eQMI_LOC_TIME_SRC_QZSS_TOW_DECODE (15) --  Time is set after decoding QZSS satellites \n
      - eQMI_LOC_TIME_SRC_BDS_TOW_DECODE (16) --  Time is set after decoding BDS satellites \n
      - eQMI_LOC_TIME_SRC_GAL_TOW_DECODE (17) --  Time is set after decoding Galileo satellites \n
      - eQMI_LOC_TIME_SRC_NAVIC_TOW_DECODE (18) --  Time is set after decoding NavIC satellites
 */
}qmiLocGetAvailWwanPositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPREMIUMSERVICEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_PREMIUM_SERVICE_GTP_CELL_V02 = 0, /**<  Premium service -- Global terrestrial positioning for the cell \n */
  eQMI_LOC_PREMIUM_SERVICE_SAP_V02 = 1, /**<  Premium service -- Sensor-assisted positioning \n */
  eQMI_LOC_PREMIUM_SERVICE_GTP_ENH_CELL_V02 = 2, /**<  Premium service -- Global terrestrial positioning enhanced cell \n */
  eQMI_LOC_PREMIUM_SERVICE_GTP_WIFI_V02 = 3, /**<  Premium service -- Global terrestrial positioning for Wi-Fi  */
  QMILOCPREMIUMSERVICEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPremiumServiceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPREMIUMSERVICECFGENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_PREMIUM_SERVICE_DISABLED_V02 = 0, /**<  Premium service disabled \n  */
  eQMI_LOC_PREMIUM_SERVICE_ENABLED_BASIC_V02 = 1, /**<  Premium service enabled for basic \n */
  eQMI_LOC_PREMIUM_SERVICE_ENABLED_PREMIUM_V02 = 2, /**<  Premium service enabled for premium \n */
  eQMI_LOC_PREMIUM_SERVICE_ENABLED_THIRDPARTY_V02 = 3, /**<  Premium service enabled for third party integration  */
  QMILOCPREMIUMSERVICECFGENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPremiumServiceCfgEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the configuration */
typedef struct {

  /* Mandatory */
  /*  Set Premium Service Type */
  qmiLocPremiumServiceEnumT_v02 premiumServiceType;
  /**<   Specifies the premium service to configure.
 Values: \n
      - eQMI_LOC_PREMIUM_SERVICE_GTP_CELL (0) --  Premium service -- Global terrestrial positioning for the cell \n
      - eQMI_LOC_PREMIUM_SERVICE_SAP (1) --  Premium service -- Sensor-assisted positioning \n
      - eQMI_LOC_PREMIUM_SERVICE_GTP_ENH_CELL (2) --  Premium service -- Global terrestrial positioning enhanced cell \n
      - eQMI_LOC_PREMIUM_SERVICE_GTP_WIFI (3) --  Premium service -- Global terrestrial positioning for Wi-Fi
 */

  /* Mandatory */
  /*  Set Premium Service Configuration */
  qmiLocPremiumServiceCfgEnumT_v02 premiumServiceCfg;
  /**<   Specifies the premium service configuration mode.
 Values: \n
      - eQMI_LOC_PREMIUM_SERVICE_DISABLED (0) --  Premium service disabled \n
      - eQMI_LOC_PREMIUM_SERVICE_ENABLED_BASIC (1) --  Premium service enabled for basic \n
      - eQMI_LOC_PREMIUM_SERVICE_ENABLED_PREMIUM (2) --  Premium service enabled for premium \n
      - eQMI_LOC_PREMIUM_SERVICE_ENABLED_THIRDPARTY (3) --  Premium service enabled for third party integration
 */
}qmiLocSetPremiumServicesCfgReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to set the configuration */
typedef struct {

  /* Mandatory */
  /*  Set Premium Service Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Premium Services Configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocSetPremiumServicesCfgIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCXTRAVERSIONCHECKENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_XTRA_VERSION_CHECK_DISABLE_V02 = 0, /**<  XTRA file version check is not required  \n */
  eQMI_LOC_XTRA_VERSION_CHECK_AUTO_V02 = 1, /**<  XTRA file version check is required; the location service decides the expected version
       based on the preprovisioned XTRA version configuration \n  */
  eQMI_LOC_XTRA_VERSION_CHECK_XTRA2_V02 = 2, /**<  Check the XTRA file against XTRA2 format \n  */
  eQMI_LOC_XTRA_VERSION_CHECK_XTRA3_V02 = 3, /**<  Check the XTRA file against XTRA3 format \n */
  eQMI_LOC_XTRA_VERSION_CHECK_XTRA3_1_V02 = 4, /**<  Check the XTRA file against XTRA3.1 format  */
  QMILOCXTRAVERSIONCHECKENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocXtraVersionCheckEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to enable or disable XTRA version
                    verification. */
typedef struct {

  /* Mandatory */
  /*  Set XTRA Version Check Mode */
  qmiLocXtraVersionCheckEnumT_v02 xtraVersionCheckMode;
  /**<   Specifies XTRA version check mode.
 Values: \n
      - eQMI_LOC_XTRA_VERSION_CHECK_DISABLE (0) --  XTRA file version check is not required  \n
      - eQMI_LOC_XTRA_VERSION_CHECK_AUTO (1) --  XTRA file version check is required; the location service decides the expected version
       based on the preprovisioned XTRA version configuration \n
      - eQMI_LOC_XTRA_VERSION_CHECK_XTRA2 (2) --  Check the XTRA file against XTRA2 format \n
      - eQMI_LOC_XTRA_VERSION_CHECK_XTRA3 (3) --  Check the XTRA file against XTRA3 format \n
      - eQMI_LOC_XTRA_VERSION_CHECK_XTRA3_1 (4) --  Check the XTRA file against XTRA3.1 format
 */
}qmiLocSetXtraVersionCheckReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to enable or disable XTRA version
                    verification. */
typedef struct {

  /* Mandatory */
  /*  Set XTRA Version Check Mode Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set XTRA version check request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocSetXtraVersionCheckIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sets the satellite constellations of interest for reporting. */
typedef struct {

  /* Optional */
  /*  GNSS Measurement Report Constellation Control */
  uint8_t measReportConfig_valid;  /**< Must be set to true if measReportConfig is being passed */
  qmiLocGNSSConstellEnumT_v02 measReportConfig;
  /**<   GNSS measurement report constellation control. \n
 Values: \n
      - eQMI_SYSTEM_GPS (0x01) --  Enable GPS \n
      - eQMI_SYSTEM_GLO (0x02) --  Enable GLONASS \n
      - eQMI_SYSTEM_BDS (0x04) --  Enable BDS \n
      - eQMI_SYSTEM_GAL (0x08) --  Enable Galileo \n
      - eQMI_SYSTEM_QZSS (0x10) --  Enable QZSS \n
      - eQMI_SYSTEM_NAVIC (0x20) --  Enable NavIC
 */

  /* Optional */
  /*  SV Polynomial Report Constellation Control */
  uint8_t svPolyReportConfig_valid;  /**< Must be set to true if svPolyReportConfig is being passed */
  qmiLocGNSSConstellEnumT_v02 svPolyReportConfig;
  /**<   SV polynomial report constellation control. \n
 Values: \n
      - eQMI_SYSTEM_GPS (0x01) --  Enable GPS \n
      - eQMI_SYSTEM_GLO (0x02) --  Enable GLONASS \n
      - eQMI_SYSTEM_BDS (0x04) --  Enable BDS \n
      - eQMI_SYSTEM_GAL (0x08) --  Enable Galileo \n
      - eQMI_SYSTEM_QZSS (0x10) --  Enable QZSS \n
      - eQMI_SYSTEM_NAVIC (0x20) --  Enable NavIC
 */

  /* Optional */
  /*  Request Full Ephemeris Data */
  uint8_t reportFullEphemerisDb_valid;  /**< Must be set to true if reportFullEphemerisDb is being passed */
  uint8_t reportFullEphemerisDb;
  /**<   Request indicating that the client needs complete ephemeris. */

  /* Optional */
  /*  Request Complete SV Polynomial Data */
  uint8_t reportFullSvPolyDb_valid;  /**< Must be set to true if reportFullSvPolyDb is being passed */
  uint8_t reportFullSvPolyDb;
  /**<   Request indicating that the client needs complete SV polynomials. */

  /* Optional */
  /*  Request Complete Iono Data */
  uint8_t reportFullIonoDb_valid;  /**< Must be set to true if reportFullIonoDb is being passed */
  uint8_t reportFullIonoDb;
  /**<   Request indicating client needs complete Iono. */
}qmiLocSetGNSSConstRepConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sets the satellite constellations of interest for reporting. */
typedef struct {

  /* Mandatory */
  /*  Set GNSS Constellation Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GNSS constellation.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetGNSSConstRepConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSOURCEOFFREQENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_FREQ_SOURCE_INVALID_V02 = 0, /**<  Source of the frequency is invalid \n  */
  eQMI_LOC_FREQ_SOURCE_EXTERNAL_V02 = 1, /**<  Source of the frequency is from an external injection \n  */
  eQMI_LOC_FREQ_SOURCE_PE_CLK_REPORT_V02 = 2, /**<  Source of the frequency is from the GNSS navigation engine \n  */
  eQMI_LOC_FREQ_SOURCE_UNKNOWN_V02 = 3, /**<  Source of the frequency is unknown  */
  QMILOCSOURCEOFFREQENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSourceofFreqEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCMEASUREMENTCODETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GNSS_CODE_TYPE_A_V02 = 0, /**<  Galileo E1A, Galileo E6A, IRNSS L5A, IRNSS SA. \n */
  eQMI_LOC_GNSS_CODE_TYPE_B_V02 = 1, /**<  Galileo E1B, Galileo E6B, IRNSS L5B, IRNSS SB. \n */
  eQMI_LOC_GNSS_CODE_TYPE_C_V02 = 2, /**<  GPS L1 C/A,  GPS L2 C/A, GLONASS G1 C/A, GLONASS G2 C/A, Galileo E1C,
       Galileo E6C, SBAS L1 C/A, QZSS L1 C/A, IRNSS L5C. \n  */
  eQMI_LOC_GNSS_CODE_TYPE_I_V02 = 3, /**<  GPS L5 I, GLONASS G3 I, Galileo E5a I, Galileo E5b I, Galileo E5a+b I,
       SBAS L5 I, QZSS L5 I, BDS B1 I, BDS B2 I, BDS B3 I. \n  */
  eQMI_LOC_GNSS_CODE_TYPE_L_V02 = 4, /**<  GPS L1C (P), GPS L2C (L), QZSS L1C (P), QZSS L2C (L), LEX(6) L. \n  */
  eQMI_LOC_GNSS_CODE_TYPE_M_V02 = 5, /**<  GPS L1M, GPS L2M. \n  */
  eQMI_LOC_GNSS_CODE_TYPE_P_V02 = 6, /**<  GPS L1P, GPS L2P, GLONASS G1P, GLONASS G2P.\n  */
  eQMI_LOC_GNSS_CODE_TYPE_Q_V02 = 7, /**<  GPS L5 Q, GLONASS G3 Q, Galileo E5a Q, Galileo E5b Q, Galileo E5a+b Q,
       SBAS L5 Q, QZSS L5 Q, BDS B1 Q, BDS B2 Q, BDS B3 Q. \n */
  eQMI_LOC_GNSS_CODE_TYPE_S_V02 = 8, /**<  GPS L1C (D), GPS L2C (M), QZSS L1C (D), QZSS L2C (M), LEX(6) S. \n */
  eQMI_LOC_GNSS_CODE_TYPE_W_V02 = 9, /**<  GPS L1 Z-tracking, GPS L2 Z-tracking. \n */
  eQMI_LOC_GNSS_CODE_TYPE_X_V02 = 10, /**<  GPS L1C (D+P), GPS L2C (M+L), GPS L5 (I+Q), GLONASS G3 (I+Q),
       Galileo E1 (B+C), Galileo E5a (I+Q), Galileo E5b (I+Q),
       Galileo E5a+b(I+Q), Galileo E6 (B+C), SBAS L5 (I+Q), QZSS L1C (D+P),
       QZSS L2C (M+L), QZSS L5 (I+Q), LEX(6) (S+L), BDS B1 (I+Q), BDS B2 (I+Q),
       BDS B3 (I+Q), IRNSS L5 (B+C). \n */
  eQMI_LOC_GNSS_CODE_TYPE_Y_V02 = 11, /**<  GPS L1Y, GPS L2Y. \n */
  eQMI_LOC_GNSS_CODE_TYPE_Z_V02 = 12, /**<  Galileo E1 (A+B+C), Galileo E6 (A+B+C), QZSS L1-SAIF. \n */
  eQMI_LOC_GNSS_CODE_TYPE_N_V02 = 13, /**<  GPS L1 codeless, GPS L2 codeless. \n */
  eQMI_LOC_GNSS_CODE_TYPE_OTHER_V02 = 255, /**<   This code is used in case the measurement used a GNSS signal code that is not listed above.  */
  QMILOCMEASUREMENTCODETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocMeasurementCodeTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  float clockDrift;
  /**<   Receiver clock drift. \n
         - Units -- Meters per second
    */

  float clockDriftUnc;
  /**<   Receiver clock drift uncertainty. \n
         - Units -- Meters per second
    */

  qmiLocSourceofFreqEnumT_v02 sourceOfFreq;
  /**<   Source of the clock frequency information.
 Values: \n
      - eQMI_LOC_FREQ_SOURCE_INVALID (0) --  Source of the frequency is invalid \n
      - eQMI_LOC_FREQ_SOURCE_EXTERNAL (1) --  Source of the frequency is from an external injection \n
      - eQMI_LOC_FREQ_SOURCE_PE_CLK_REPORT (2) --  Source of the frequency is from the GNSS navigation engine \n
      - eQMI_LOC_FREQ_SOURCE_UNKNOWN (3) --  Source of the frequency is unknown
 */
}qmiLocRcvrClockFrequencyInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t leapSec;
  /**<   GPS time leap second delta to UTC time.  \n
         For nonzero values of leapSecUnc, leapSec must be treated as unknown. \n
         - Units -- Seconds
    */

  uint8_t leapSecUnc;
  /**<   Uncertainty for the GPS leap second. \n
         - Units -- Seconds
    */
}qmiLocLeapSecondInfoStructT_v02;  /* Type */
/**
    @}
  */

typedef uint8_t qmiLocInterSystemBiasValidMaskT_v02;
#define QMI_LOC_SYS_TIME_BIAS_VALID_V02 ((qmiLocInterSystemBiasValidMaskT_v02)0x01) /**<  System time bias is valid \n  */
#define QMI_LOC_SYS_TIME_BIAS_UNC_VALID_V02 ((qmiLocInterSystemBiasValidMaskT_v02)0x02) /**<  System time bias uncertainty is valid  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocInterSystemBiasValidMaskT_v02 validMask;
  /**<   Values: \n
      - QMI_LOC_SYS_TIME_BIAS_VALID (0x01) --  System time bias is valid \n
      - QMI_LOC_SYS_TIME_BIAS_UNC_VALID (0x02) --  System time bias uncertainty is valid
 */

  float timeBias;
  /**<   System 1 to system 2 time bias.  \n
         - Units -- Milliseconds
    */

  float timeBiasUnc;
  /**<   System 1 to system 2 time bias uncertainty.  \n
         - Units -- Milliseconds
    */
}qmiLocInterSystemBiasStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSvSystemEnumT_v02 system;
  /**<   Specifies the satellite system constellation.
 Values: \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite
 */

  uint16_t systemWeek;
  /**<   Current system week. \n
      - GPS -- Calculated from midnight, Jan. 6, 1980. \n
      - BDS -- Calculated from 00:00:00 on January 1, 2006 of Coordinated Universal Time (UTC). \n
      - Galileo -- Calculated from 00:00 UT on Sunday August 22, 1999 (midnight between August 21 and August 22). \n
      If the week is unknown, set this value to 65535. \n
       - Units -- Weeks */

  uint32_t systemMsec;
  /**<   Amount of time into the current week. \n
         - Units -- Milliseconds */

  float systemClkTimeBias;
  /**<   System clock time bias (submilliseconds). \n
         - Units -- Milliseconds
        (system time = systemMsec - systemClkTimeBias)
    */

  float systemClkTimeUncMs;
  /**<   Single-sided maximum time bias uncertainty. \n
         - Units -- Milliseconds
    */
}qmiLocGnssTimeStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t gloFourYear;
  /**<   GLONASS four year number from 1996; refer to the GLONASS ICD. \n
         Applicable only for GLONASS, ignore for other constellations. \n
         If unknown, set this value to 255.
    */

  uint16_t gloDays;
  /**<   GLONASS day number in four years; refer to the GLONASS ICD. \n
         Applicable only for GLONASS, ignore for other constellations. \n
         If unknown, set this value to 65535.
    */

  uint32_t gloMsec;
  /**<   GLONASS time of day in milliseconds; refer to the GLONASS ICD.
    */

  float gloClkTimeBias;
  /**<   System clock time bias (submillisecond). \n
         - Units -- Milliseconds
        (system time = systemMsec - systemClkTimeBias)
    */

  float gloClkTimeUncMs;
  /**<   Single-sided maximum time bias uncertainty. \n
         - Units -- Milliseconds
    */
}qmiLocGloTimeStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t refFCount;
  /**<   Receiver frame counter value at a reference tick. \n
         - Units -- Milliseconds
    */

  uint8_t systemRtc_valid;
  /**<   Validity indicator for the system RTC. */

  uint64_t systemRtcMs;
  /**<   Platform system RTC value. \n
        - Units -- Milliseconds
    */

  qmiLocTimeSourceEnumT_v02 sourceOfTime;
  /**<   Source of the time information.
 Values: \n
      - eQMI_LOC_TIME_SRC_INVALID (0) --  Invalid time \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TRANSFER (1) --  Time is set by the 1X system \n
      - eQMI_LOC_TIME_SRC_NETWORK_TIME_TAGGING (2) --  Time is set by WCDMA/GSM time tagging (that is,
       associating network time with GPS time) \n
      - eQMI_LOC_TIME_SRC_EXTERNAL_INPUT (3) --  Time is set by an external injection \n
      - eQMI_LOC_TIME_SRC_TOW_DECODE (4) --  Time is set after decoding over-the-air GPS navigation data
       from one GPS satellite \n
      - eQMI_LOC_TIME_SRC_TOW_CONFIRMED (5) --  Time is set after decoding over-the-air GPS navigation data
       from multiple satellites \n
      - eQMI_LOC_TIME_SRC_TOW_AND_WEEK_CONFIRMED (6) --  Both time of the week and the GPS week number are known \n
      - eQMI_LOC_TIME_SRC_NAV_SOLUTION (7) --  Time is set by the position engine after the fix is obtained \n
      - eQMI_LOC_TIME_SRC_SOLVE_FOR_TIME (8) --  Time is set by the position engine after performing SFT;
       this is done when the clock time uncertainty is large \n
      - eQMI_LOC_TIME_SRC_GLO_TOW_DECODE (9) --  Time is set after decoding GLO satellites \n
      - eQMI_LOC_TIME_SRC_TIME_TRANSFORM (10) --  Time is set after transforming the GPS to GLO time \n
      - eQMI_LOC_TIME_SRC_WCDMA_SLEEP_TIME_TAGGING (11) --  Time is set by the sleep time tag provided by the WCDMA network \n
      - eQMI_LOC_TIME_SRC_GSM_SLEEP_TIME_TAGGING (12) --  Time is set by the sleep time tag provided by the GSM network \n
      - eQMI_LOC_TIME_SRC_UNKNOWN (13) --  Source of the time is unknown \n
      - eQMI_LOC_TIME_SRC_SYSTEM_TIMETICK (14) --  Time is derived from the system clock (better known as the slow clock);
       GNSS time is maintained irrespective of the GNSS receiver state \n
      - eQMI_LOC_TIME_SRC_QZSS_TOW_DECODE (15) --  Time is set after decoding QZSS satellites \n
      - eQMI_LOC_TIME_SRC_BDS_TOW_DECODE (16) --  Time is set after decoding BDS satellites \n
      - eQMI_LOC_TIME_SRC_GAL_TOW_DECODE (17) --  Time is set after decoding Galileo satellites \n
      - eQMI_LOC_TIME_SRC_NAVIC_TOW_DECODE (18) --  Time is set after decoding NavIC satellites
 */
}qmiLocGnssTimeExtStructT_v02;  /* Type */
/**
    @}
  */

typedef uint64_t qmiLocSvMeasStatusValidMaskT_v02;
#define QMI_LOC_MASK_MEAS_STATUS_SM_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000001ull) /**<  Satellite time in submilliseconds (code-phase) \n */
#define QMI_LOC_MASK_MEAS_STATUS_SB_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000002ull) /**<  Satellite sub-bit time \n */
#define QMI_LOC_MASK_MEAS_STATUS_MS_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000004ull) /**<  Satellite time in milliseconds \n */
#define QMI_LOC_MASK_MEAS_STATUS_BE_CONFIRM_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000008ull) /**<  Signal bit edge is confirmed \n */
#define QMI_LOC_MASK_MEAS_STATUS_VEL_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000010ull) /**<  Satellite Doppler is measured \n */
#define QMI_LOC_MASK_MEAS_STATUS_VEL_FINE_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000020ull) /**<  Fine/coarse Doppler measurement indicator\n */
#define QMI_LOC_MASK_MEAS_STATUS_LP_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000040ull) /**<  TRUE/FALSE -- Lock point is valid/invalid \n */
#define QMI_LOC_MASK_MEAS_STATUS_LP_POS_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000080ull) /**<  TRUE/FALSE -- Lock point is positive/negative \n  */
#define QMI_LOC_MASK_MEAS_STATUS_FROM_RNG_DIFF_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000200ull) /**<  Range update from satellite differences \n  */
#define QMI_LOC_MASK_MEAS_STATUS_FROM_VE_DIFF_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x00000400ull) /**<  Doppler update from satellite differences \n */
#define QMI_LOC_MASK_MEAS_STATUS_GNSS_FRESH_MEAS_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x08000000ull) /**<  TRUE -- Fresh GNSS measurement observed in the last second \n   */
#define QMI_LOC_MASK_MEAS_STATUS_RESERVED_UNUSED_1_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x10000000ull) /**<  Reserved for future use \n   */
#define QMI_LOC_MASK_MEAS_STATUS_RESERVED_UNUSED_2_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x20000000ull) /**<  Reserved for future use \n   */
#define QMI_LOC_MASK_MEAS_STATUS_100MS_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x40000000ull) /**<  TRUE -- SV time known with 100 ms ambiguity  \n */
#define QMI_LOC_MASK_MEAS_STATUS_2S_STAT_BIT_VALID_V02 ((qmiLocSvMeasStatusValidMaskT_v02)0x80000000ull) /**<  TRUE -- SV time known with 2 seconds ambiguity  */
typedef uint64_t qmiLocSvMeasStatusMaskT_v02;
#define QMI_LOC_MASK_MEAS_STATUS_SM_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000001ull) /**<  Satellite time in submilliseconds (code phase) is known \n */
#define QMI_LOC_MASK_MEAS_STATUS_SB_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000002ull) /**<  Satellite sub-bit time is known \n */
#define QMI_LOC_MASK_MEAS_STATUS_MS_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000004ull) /**<  Satellite time in milliseconds is known \n */
#define QMI_LOC_MASK_MEAS_STATUS_BE_CONFIRM_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000008ull) /**<  Signal bit edge is confirmed \n  */
#define QMI_LOC_MASK_MEAS_STATUS_VELOCITY_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000010ull) /**<  Satellite Doppler is measured \n  */
#define QMI_LOC_MASK_MEAS_STATUS_VELOCITY_FINE_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000020ull) /**<  TRUE -- Fine Doppler is measured \n FALSE -- Coarse Doppler is measured \n */
#define QMI_LOC_MASK_MEAS_STATUS_LP_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000040ull) /**<  TRUE -- Lock point is valid \n FALSE -- Lock point is invalid \n */
#define QMI_LOC_MASK_MEAS_STATUS_LP_POS_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000080ull) /**<  TRUE -- Lock point is positive \n FALSE -- Lock point is negative \n */
#define QMI_LOC_MASK_MEAS_STATUS_FROM_RNG_DIFF_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000200ull) /**<  Range update from satellite differences is measured \n */
#define QMI_LOC_MASK_MEAS_STATUS_FROM_VE_DIFF_V02 ((qmiLocSvMeasStatusMaskT_v02)0x00000400ull) /**<  Doppler update from satellite differences is measured \n */
#define QMI_LOC_MASK_MEAS_STATUS_GNSS_FRESH_MEAS_VALID_V02 ((qmiLocSvMeasStatusMaskT_v02)0x08000000ull) /**<  TRUE -- Fresh GNSS measurement observed in last second    */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint32_t svTimeMs;
  /**<   Satellite time in milliseconds. \n
            - For GPS, BDS, Galileo, and QZSS -- Range is 0 through (604800000-1) \n
            - For GLONASS -- Range is 0 through (86400000-1) \n
            Valid when the QMI_LOC_MEAS_STATUS_MS_VALID bit is set
            in the measurement status. \n
            @note All SV times in the current measurement block are
            already propagated to a common reference time epoch.
    */

  float svTimeSubMs;
  /**<   Satellite time in submilliseconds. \n
         Total SV Time = svMs + svSubMs \n
         - Units -- Milliseconds
    */

  float svTimeUncMs;
  /**<   Satellite time uncertainty. \n
         - Units -- Milliseconds
    */

  float dopplerShift;
  /**<   Satellite Doppler. \n
         - Units -- Meters per second
    */

  float dopplerShiftUnc;
  /**<   Satellite Doppler uncertainty. \n
         - Units -- Meters per second
    */

  uint8_t dopplerAccel_valid;
  /**<   Validity for Doppler acceleration. */

  float dopplerAccel;
  /**<   Satellite Doppler acceleration. \n
             - Units -- Hz per second
    */
}qmiLocSVTimeSpeedStructT_v02;  /* Type */
/**
    @}
  */

typedef uint16_t qmiLocMeasFieldsValidMaskT_v02;
#define QMI_LOC_SV_HEALTH_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x01) /**<  SV health information is valid \n */
#define QMI_LOC_SV_MULTIPATH_EST_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x02) /**<  Multipath estimate for SV is valid \n */
#define QMI_LOC_SV_FINE_SPEED_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x04) /**<  Fine speed for SV is valid \n */
#define QMI_LOC_SV_FINE_SPEED_UNC_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x08) /**<  Fine speed uncertainty for SV is valid \n */
#define QMI_LOC_SV_CARRIER_PHASE_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x10) /**<  Carrier phase for SV is valid \n */
#define QMI_LOC_SV_SV_DIRECTION_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x20) /**<  SV direction information for SV is valid \n */
#define QMI_LOC_SV_CYCLESLIP_COUNT_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x40) /**<  Cycle slip count information is valid \n  */
#define QMI_LOC_SV_LOSSOFLOCK_VALID_V02 ((qmiLocMeasFieldsValidMaskT_v02)0x80) /**<  Loss of lock information is valid  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   GNSS SV ID.\n
         Range:  \n
         - GPS --     1 to 32 \n
         - GLONASS -- 65 to 96. When slot-number to SV ID mapping is unknown, set as 255.\n
         - QZSS --    193 to 197 \n
         - BDS --     201 to 263 \n
         - Galileo -- 301 to 336 \n
         - NavIC -- 401 to 414
      */

  uint8_t gloFrequency;
  /**<   GLONASS frequency number + 8. \n
         Valid only for a GLONASS system, ignore for all other systems. \n
         - Range -- 1 to 14
    */

  qmiLocSvStatusEnumT_v02 svStatus;
  /**<   Satellite search state.
 Values: \n
      - eQMI_LOC_SV_STATUS_IDLE (1) --  SV is not being actively processed \n
      - eQMI_LOC_SV_STATUS_SEARCH (2) --  The system is searching for this SV \n
      - eQMI_LOC_SV_STATUS_TRACK (3) --  SV is being tracked
 */

  qmiLocMeasFieldsValidMaskT_v02 validMask;
  /**<   Validity mask (0 = Not valid; 1 = valid). \n
      - QMI_LOC_SV_HEALTH_VALID (0x01) --  SV health information is valid \n
      - QMI_LOC_SV_MULTIPATH_EST_VALID (0x02) --  Multipath estimate for SV is valid \n
      - QMI_LOC_SV_FINE_SPEED_VALID (0x04) --  Fine speed for SV is valid \n
      - QMI_LOC_SV_FINE_SPEED_UNC_VALID (0x08) --  Fine speed uncertainty for SV is valid \n
      - QMI_LOC_SV_CARRIER_PHASE_VALID (0x10) --  Carrier phase for SV is valid \n
      - QMI_LOC_SV_SV_DIRECTION_VALID (0x20) --  SV direction information for SV is valid \n
      - QMI_LOC_SV_CYCLESLIP_COUNT_VALID (0x40) --  Cycle slip count information is valid \n
      - QMI_LOC_SV_LOSSOFLOCK_VALID (0x80) --  Loss of lock information is valid
 */

  uint8_t healthStatus;
  /**<   Health status.
         Range -- 0 to 1 \n
         - 0 -- Unhealthy \n
         - 1 -- Healthy
    */

  qmiLocSvInfoMaskT_v02 svInfoMask;
  /**<   Indicates whether almanac and ephemeris information is available.
 Values: \n
      - QMI_LOC_SVINFO_MASK_HAS_EPHEMERIS (0x01) --  Ephemeris is available for this SV
      - QMI_LOC_SVINFO_MASK_HAS_ALMANAC (0x02) --  Almanac is available for this SV
 */

  qmiLocSvMeasStatusValidMaskT_v02 validMeasStatusMask;
  /**<   Validity mask for measurement status information. \n
 A set bit in validMeasStatusMask indicates that the corresponding bit
 in measurementStatus has valid status information: \n
 Valid masks: \n
      - QMI_LOC_MASK_MEAS_STATUS_SM_STAT_BIT_VALID (0x00000001) --  Satellite time in submilliseconds (code-phase) \n
      - QMI_LOC_MASK_MEAS_STATUS_SB_STAT_BIT_VALID (0x00000002) --  Satellite sub-bit time \n
      - QMI_LOC_MASK_MEAS_STATUS_MS_STAT_BIT_VALID (0x00000004) --  Satellite time in milliseconds \n
      - QMI_LOC_MASK_MEAS_STATUS_BE_CONFIRM_STAT_BIT_VALID (0x00000008) --  Signal bit edge is confirmed \n
      - QMI_LOC_MASK_MEAS_STATUS_VEL_STAT_BIT_VALID (0x00000010) --  Satellite Doppler is measured \n
      - QMI_LOC_MASK_MEAS_STATUS_VEL_FINE_STAT_BIT_VALID (0x00000020) --  Fine/coarse Doppler measurement indicator\n
      - QMI_LOC_MASK_MEAS_STATUS_LP_STAT_BIT_VALID (0x00000040) --  TRUE/FALSE -- Lock point is valid/invalid \n
      - QMI_LOC_MASK_MEAS_STATUS_LP_POS_STAT_BIT_VALID (0x00000080) --  TRUE/FALSE -- Lock point is positive/negative \n
      - QMI_LOC_MASK_MEAS_STATUS_FROM_RNG_DIFF_STAT_BIT_VALID (0x00000200) --  Range update from satellite differences \n
      - QMI_LOC_MASK_MEAS_STATUS_FROM_VE_DIFF_STAT_BIT_VALID (0x00000400) --  Doppler update from satellite differences \n
      - QMI_LOC_MASK_MEAS_STATUS_GNSS_FRESH_MEAS_STAT_BIT_VALID (0x08000000) --  TRUE -- Fresh GNSS measurement observed in the last second \n
      - QMI_LOC_MASK_MEAS_STATUS_RESERVED_UNUSED_1_BIT_VALID (0x10000000) --  Reserved for future use \n
      - QMI_LOC_MASK_MEAS_STATUS_RESERVED_UNUSED_2_BIT_VALID (0x20000000) --  Reserved for future use \n
      - QMI_LOC_MASK_MEAS_STATUS_100MS_STAT_BIT_VALID (0x40000000) --  TRUE -- SV time known with 100 ms ambiguity  \n
      - QMI_LOC_MASK_MEAS_STATUS_2S_STAT_BIT_VALID (0x80000000) --  TRUE -- SV time known with 2 seconds ambiguity
 \vspace{4pt}
 \n MSB 0xFFC0000000000000 bits indicate the validity of DONT_USE bits.
 */

  qmiLocSvMeasStatusMaskT_v02 measurementStatus;
  /**<   Bitmask indicating the SV measurement status.
 Valid bitmasks: \n
      - QMI_LOC_MASK_MEAS_STATUS_SM_VALID (0x00000001) --  Satellite time in submilliseconds (code phase) is known \n
      - QMI_LOC_MASK_MEAS_STATUS_SB_VALID (0x00000002) --  Satellite sub-bit time is known \n
      - QMI_LOC_MASK_MEAS_STATUS_MS_VALID (0x00000004) --  Satellite time in milliseconds is known \n
      - QMI_LOC_MASK_MEAS_STATUS_BE_CONFIRM (0x00000008) --  Signal bit edge is confirmed \n
      - QMI_LOC_MASK_MEAS_STATUS_VELOCITY_VALID (0x00000010) --  Satellite Doppler is measured \n
      - QMI_LOC_MASK_MEAS_STATUS_VELOCITY_FINE (0x00000020) --  TRUE -- Fine Doppler is measured \n FALSE -- Coarse Doppler is measured \n
      - QMI_LOC_MASK_MEAS_STATUS_LP_VALID (0x00000040) --  TRUE -- Lock point is valid \n FALSE -- Lock point is invalid \n
      - QMI_LOC_MASK_MEAS_STATUS_LP_POS_VALID (0x00000080) --  TRUE -- Lock point is positive \n FALSE -- Lock point is negative \n
      - QMI_LOC_MASK_MEAS_STATUS_FROM_RNG_DIFF (0x00000200) --  Range update from satellite differences is measured \n
      - QMI_LOC_MASK_MEAS_STATUS_FROM_VE_DIFF (0x00000400) --  Doppler update from satellite differences is measured \n
      - QMI_LOC_MASK_MEAS_STATUS_GNSS_FRESH_MEAS_VALID (0x08000000) --  TRUE -- Fresh GNSS measurement observed in last second

 If any MSB bit in 0xFFC0000000000000 DONT_USE is set, the client must not
 use the measurement.
 */

  uint16_t CNo;
  /**<   Carrier to noise ratio at antenna.   \n
         - Units -- dBHz  \n
         - Scale -- 0.1
    */

  uint16_t gloRfLoss;
  /**<   GLONASS RF loss reference to the antenna. \n
         - Units -- dB \n
         - Scale -- 0.1
    */

  int32_t measLatency;
  /**<   Age of the measurement; a positive value means the measurement precedes the reference time. \n
         - Units -- Milliseconds
    */

  qmiLocSVTimeSpeedStructT_v02 svTimeSpeed;
  /**<   SV time and speed information. */

  uint8_t lossOfLock;
  /**<   Loss of signal lock indicator. \n
         - 0 -- Signal is in continuous track \n
         - 1 -- Signal is not in track
    */

  float multipathEstimate;
  /**<   Estimate of multipath in a measurement. \n
         - Units -- Meters
    */

  float fineSpeed;
  /**<   Carrier phase derived speed.\n
         - Units -- Meters per second
    */

  float fineSpeedUnc;
  /**<   Carrier phase derived speed uncertainty. \n
         - Units -- Meters per second
    */

  double carrierPhase;
  /**<   Carrier phase measurement (L1 cycles).
    */

  uint8_t cycleSlipCount;
  /**<   Increments when a cycle slip is detected. */

  float svAzimuth;
  /**<   Satellite azimuth.\n
        - Units -- Radians \n
        - Range -- 0 to 2*pi()
    */

  float svElevation;
  /**<   Satellite elevation. \n
         - Units -- Radians \n
         - Range -- 0 to pi()/2
    */
}qmiLocSVMeasurementStructT_v02;  /* Type */
/**
    @}
  */

typedef uint64_t qmiLocSvDgnssMeasStatusMaskT_v02;
#define QMI_LOC_MASK_DGNSS_EPOCH_TIME_VALID_V02 ((qmiLocSvDgnssMeasStatusMaskT_v02)0x00000001ull) /**<  DGNSS epoch time is valid. \n  */
#define QMI_LOC_MASK_DGNSS_MEAS_STATUS_PR_VALID_V02 ((qmiLocSvDgnssMeasStatusMaskT_v02)0x00000002ull) /**<  Pseudorange correction is valid. \n  */
#define QMI_LOC_MASK_DGNSS_MEAS_STATUS_PRR_VALID_V02 ((qmiLocSvDgnssMeasStatusMaskT_v02)0x00000004ull) /**<  Pseudorange rate correction is valid.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSvDgnssMeasStatusMaskT_v02 dgnssMeasStatus;
  /**<   Bitmask indicating the DGNSS SV measurement status.
 Valid bitmasks: \n
      - QMI_LOC_MASK_DGNSS_EPOCH_TIME_VALID (0x00000001) --  DGNSS epoch time is valid. \n
      - QMI_LOC_MASK_DGNSS_MEAS_STATUS_PR_VALID (0x00000002) --  Pseudorange correction is valid. \n
      - QMI_LOC_MASK_DGNSS_MEAS_STATUS_PRR_VALID (0x00000004) --  Pseudorange rate correction is valid.
 */

  uint32_t diffDataEpochTimeMsec;
  /**<   Age of differential data in milliseconds with respect to the easurement time.
    */

  float prCorrMeters;
  /**<   Pseudorange correction in meters.
    */

  float prrCorrMetersPerSec;
  /**<   Pseudorange rate correction in meters per second.
    */
}qmiLocDgnssSVMeasurementStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a satellite measurement report to the control point. */
typedef struct {

  /* Mandatory */
  /*  Current Message Sequence Number  */
  uint8_t seqNum;
  /**<   Current message number; used for segmentation/assembly of measurement reports. */

  /* Mandatory */
  /*  Maximum Number of Messages to Send for Present Time Epoch */
  uint8_t maxMessageNum;
  /**<   Maximum number of messages to send for the present time epoch. */

  /* Mandatory */
  /*  Specifies Satellite System Constellation of This Report */
  qmiLocSvSystemEnumT_v02 system;
  /**<   Specifies the satellite system constellation of this report.
 Values: \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite
 */

  /* Optional */
  /*  GNSS Receiver Clock Frequency Information */
  uint8_t rcvrClockFrequencyInfo_valid;  /**< Must be set to true if rcvrClockFrequencyInfo is being passed */
  qmiLocRcvrClockFrequencyInfoStructT_v02 rcvrClockFrequencyInfo;

  /* Optional */
  /*  Leap Second Information */
  uint8_t leapSecondInfo_valid;  /**< Must be set to true if leapSecondInfo is being passed */
  qmiLocLeapSecondInfoStructT_v02 leapSecondInfo;

  /* Optional */
  /*  GPS to GLONASS Intersystem Time Bias */
  uint8_t gpsGloInterSystemBias_valid;  /**< Must be set to true if gpsGloInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 gpsGloInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both GPS and GLONASS system
       information reporting are enabled. \n
       - System 1 -- GPS \n
       - System 2 -- GLONASS
  */

  /* Optional */
  /*  GPS to BDS Intersystem Time Bias */
  uint8_t gpsBdsInterSystemBias_valid;  /**< Must be set to true if gpsBdsInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 gpsBdsInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both GPS and BDS system
       information reporting are enabled. \n
       - System 1 -- GPS \n
       - System 2 -- BDS
  */

  /* Optional */
  /*  GPS to Galileo Intersystem Time Bias */
  uint8_t gpsGalInterSystemBias_valid;  /**< Must be set to true if gpsGalInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 gpsGalInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both GPS and Galileo system
       information reporting are enabled. \n
       - System 1 -- GPS \n
       - System 2 -- Galileo
  */

  /* Optional */
  /*  BDS to GLONASS Intersystem Time Bias */
  uint8_t bdsGloInterSystemBias_valid;  /**< Must be set to true if bdsGloInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 bdsGloInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both BDS and GLONASS system
       information reporting are enabled. \n
       - System 1 -- BDS \n
       - System 2 -- GLONASS
  */

  /* Optional */
  /*  Galileo to GLONASS Intersystem Time Bias */
  uint8_t galGloInterSystemBias_valid;  /**< Must be set to true if galGloInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 galGloInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both Galileo and GLONASS system
       information reporting are enabled. \n
       - System 1 -- Galileo \n
       - System 2 -- GLONASS
  */

  /* Optional */
  /*  Galileo to BDS Intersystem Time Bias */
  uint8_t galBdsInterSystemBias_valid;  /**< Must be set to true if galBdsInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 galBdsInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both Galileo and BDS system
       information reporting are enabled. \n
       - System 1 -- Galileo \n
       - System 2 -- BDS
  */

  /* Optional */
  /*  Satellite System Time Information for GPS, BDS, GAL Constellation */
  uint8_t systemTime_valid;  /**< Must be set to true if systemTime is being passed */
  qmiLocGnssTimeStructT_v02 systemTime;

  /* Optional */
  /*  GLONASS System Time Information */
  uint8_t gloTime_valid;  /**< Must be set to true if gloTime is being passed */
  qmiLocGloTimeStructT_v02 gloTime;

  /* Optional */
  /*  Extended Time Information */
  uint8_t systemTimeExt_valid;  /**< Must be set to true if systemTimeExt is being passed */
  qmiLocGnssTimeExtStructT_v02 systemTimeExt;

  /* Optional */
  /*  Satellite System Measurement Report for Enabled Constellation */
  uint8_t svMeasurement_valid;  /**< Must be set to true if svMeasurement is being passed */
  uint32_t svMeasurement_len;  /**< Must be set to # of elements in svMeasurement */
  qmiLocSVMeasurementStructT_v02 svMeasurement[QMI_LOC_SV_MEAS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  Extended Time Information - Cumulative Number of Clock Resets */
  uint8_t numClockResets_valid;  /**< Must be set to true if numClockResets is being passed */
  uint32_t numClockResets;
  /**<   Number of clock resets/discontinuities detected, affecting the local hardware counter value. */

  /* Optional */
  /*  SV Carrier Phase Measurement Uncertainty for Enabled Constellation */
  uint8_t svCarrierPhaseUncertainty_valid;  /**< Must be set to true if svCarrierPhaseUncertainty is being passed */
  uint32_t svCarrierPhaseUncertainty_len;  /**< Must be set to # of elements in svCarrierPhaseUncertainty */
  float svCarrierPhaseUncertainty[QMI_LOC_SV_MEAS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  GNSS Signal Type */
  uint8_t gnssSignalType_valid;  /**< Must be set to true if gnssSignalType is being passed */
  qmiLocGnssSignalTypeMaskT_v02 gnssSignalType;
  /**<   GNSS signal type. \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */

  /* Optional */
  /*  Jammer Indicator */
  uint8_t jammerIndicator_valid;  /**< Must be set to true if jammerIndicator is being passed */
  qmiLocJammerIndicatorStructT_v02 jammerIndicator;

  /* Optional */
  /*  GPS L1 - L2C Intrasystem Time Bias */
  uint8_t GpsL1L2cTimeBias_valid;  /**< Must be set to true if GpsL1L2cTimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 GpsL1L2cTimeBias;
  /**<   GPS L1 to L2C time bias (L2C-L1). */

  /* Optional */
  /*  GPS L1 - L5 Intrasystem Time Bias */
  uint8_t GpsL1L5TimeBias_valid;  /**< Must be set to true if GpsL1L5TimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 GpsL1L5TimeBias;
  /**<   GPS L1 to L5 time bias (L5-L1). */

  /* Optional */
  /*  GLO G1 - G2 Intrasystem Time Bias */
  uint8_t GloG1G2TimeBias_valid;  /**< Must be set to true if GloG1G2TimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 GloG1G2TimeBias;
  /**<   GLONASS G1 to G2 time bias (G2-G1). */

  /* Optional */
  /*  BDS B1I - B2A Intrasystem Time Bias */
  uint8_t BdsB1iB2aTimeBias_valid;  /**< Must be set to true if BdsB1iB2aTimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 BdsB1iB2aTimeBias;
  /**<   BDS B1I to B2A time bias (B2A-B1I). */

  /* Optional */
  /*  BDS B1I - B1C Intrasystem Time Bias */
  uint8_t BdsB1iB1cTimeBias_valid;  /**< Must be set to true if BdsB1iB1cTimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 BdsB1iB1cTimeBias;
  /**<   BDS B1I to B1C time bias (B1C-B1I). */

  /* Optional */
  /*  Galileo E1 - E5A Intrasystem Time Bias */
  uint8_t GalE1E5aTimeBias_valid;  /**< Must be set to true if GalE1E5aTimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 GalE1E5aTimeBias;
  /**<   Galileo E1 to E5a time bias (E5a-E1). */

  /* Optional */
  /*  Galileo E1 - E5B Intrasystem Time Bias */
  uint8_t GalE1E5bTimeBias_valid;  /**< Must be set to true if GalE1E5bTimeBias is being passed */
  qmiLocInterSystemBiasStructT_v02 GalE1E5bTimeBias;
  /**<   Galileo E1 to E5b time bias (E5b-E1). */

  /* Optional */
  /*  NHz Indicator */
  uint8_t nHzMeasurement_valid;  /**< Must be set to true if nHzMeasurement is being passed */
  uint8_t nHzMeasurement;
  /**<   NHz indicator. Values: \n
       - 0 indicates 1Hz measurement report \n
       - 1 indicates NHz measurement report (N > 1) */

  /* Optional */
  /*  GNSS Measurement Code Type */
  uint8_t measurementCodeType_valid;  /**< Must be set to true if measurementCodeType is being passed */
  qmiLocMeasurementCodeTypeEnumT_v02 measurementCodeType;
  /**<   Specifies the GNSS measurement's code type.
      - eQMI_LOC_GNSS_CODE_TYPE_A (0) --  Galileo E1A, Galileo E6A, IRNSS L5A, IRNSS SA. \n
      - eQMI_LOC_GNSS_CODE_TYPE_B (1) --  Galileo E1B, Galileo E6B, IRNSS L5B, IRNSS SB. \n
      - eQMI_LOC_GNSS_CODE_TYPE_C (2) --  GPS L1 C/A,  GPS L2 C/A, GLONASS G1 C/A, GLONASS G2 C/A, Galileo E1C,
       Galileo E6C, SBAS L1 C/A, QZSS L1 C/A, IRNSS L5C. \n
      - eQMI_LOC_GNSS_CODE_TYPE_I (3) --  GPS L5 I, GLONASS G3 I, Galileo E5a I, Galileo E5b I, Galileo E5a+b I,
       SBAS L5 I, QZSS L5 I, BDS B1 I, BDS B2 I, BDS B3 I. \n
      - eQMI_LOC_GNSS_CODE_TYPE_L (4) --  GPS L1C (P), GPS L2C (L), QZSS L1C (P), QZSS L2C (L), LEX(6) L. \n
      - eQMI_LOC_GNSS_CODE_TYPE_M (5) --  GPS L1M, GPS L2M. \n
      - eQMI_LOC_GNSS_CODE_TYPE_P (6) --  GPS L1P, GPS L2P, GLONASS G1P, GLONASS G2P.\n
      - eQMI_LOC_GNSS_CODE_TYPE_Q (7) --  GPS L5 Q, GLONASS G3 Q, Galileo E5a Q, Galileo E5b Q, Galileo E5a+b Q,
       SBAS L5 Q, QZSS L5 Q, BDS B1 Q, BDS B2 Q, BDS B3 Q. \n
      - eQMI_LOC_GNSS_CODE_TYPE_S (8) --  GPS L1C (D), GPS L2C (M), QZSS L1C (D), QZSS L2C (M), LEX(6) S. \n
      - eQMI_LOC_GNSS_CODE_TYPE_W (9) --  GPS L1 Z-tracking, GPS L2 Z-tracking. \n
      - eQMI_LOC_GNSS_CODE_TYPE_X (10) --  GPS L1C (D+P), GPS L2C (M+L), GPS L5 (I+Q), GLONASS G3 (I+Q),
       Galileo E1 (B+C), Galileo E5a (I+Q), Galileo E5b (I+Q),
       Galileo E5a+b(I+Q), Galileo E6 (B+C), SBAS L5 (I+Q), QZSS L1C (D+P),
       QZSS L2C (M+L), QZSS L5 (I+Q), LEX(6) (S+L), BDS B1 (I+Q), BDS B2 (I+Q),
       BDS B3 (I+Q), IRNSS L5 (B+C). \n
      - eQMI_LOC_GNSS_CODE_TYPE_Y (11) --  GPS L1Y, GPS L2Y. \n
      - eQMI_LOC_GNSS_CODE_TYPE_Z (12) --  Galileo E1 (A+B+C), Galileo E6 (A+B+C), QZSS L1-SAIF. \n
      - eQMI_LOC_GNSS_CODE_TYPE_N (13) --  GPS L1 codeless, GPS L2 codeless. \n
      - eQMI_LOC_GNSS_CODE_TYPE_OTHER (255) --   This code is used in case the measurement used a GNSS signal code that is not listed above.
 */

  /* Optional */
  /*  Other Code Type Name (NULL-Terminated) */
  uint8_t otherCodeTypeName_valid;  /**< Must be set to true if otherCodeTypeName is being passed */
  uint32_t otherCodeTypeName_len;  /**< Must be set to # of elements in otherCodeTypeName */
  char otherCodeTypeName[QMI_LOC_SV_MEAS_OTHER_CODE_TYPE_NAME_MAX_LEN_V02];
  /**<   - Type -- character string  \n
         - Maximum length of the array -- 8  \n
         When using the measurement code type eQMI_LOC_GNSS_CODE_TYPE_OTHER,
         the name of the code is specified in the char array above.  */

  /* Optional */
  /*  GPS to NavIC Intersystem Time Bias */
  uint8_t gpsNavicInterSystemBias_valid;  /**< Must be set to true if gpsNavicInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 gpsNavicInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both the GPS and NavIC system
       information reporting are enabled. \n
       - System 1 -- GPS \n
       - System 2 -- NavIC
  */

  /* Optional */
  /*  Galileo to NavIC Intersystem Time Bias */
  uint8_t galNavicInterSystemBias_valid;  /**< Must be set to true if galNavicInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 galNavicInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both the Galileo and NavIC system
       information reporting are enabled. \n
       - System 1 -- Galileo \n
       - System 2 -- NavIC
  */

  /* Optional */
  /*  GLONASS to NavIC Intersystem Time Bias */
  uint8_t gloNavicInterSystemBias_valid;  /**< Must be set to true if gloNavicInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 gloNavicInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both the GLO and NavIC system
       information reporting are enabled. \n
       - System 1 -- GLONASS \n
       - System 2 -- NavIC
  */

  /* Optional */
  /*  BDS to NavIC Intersystem Time Bias */
  uint8_t bdsNavicInterSystemBias_valid;  /**< Must be set to true if bdsNavicInterSystemBias is being passed */
  qmiLocInterSystemBiasStructT_v02 bdsNavicInterSystemBias;
  /**<   \vspace{4pt} \n
       Reported when both the BDS and NavIC system
       information reporting are enabled.  \n
       - System 1 -- BDS \n
       - System 2 -- NavIC
  */

  /* Optional */
  /*  Measurement Report for Extended SVs */
  uint8_t extSvMeasurement_valid;  /**< Must be set to true if extSvMeasurement is being passed */
  uint32_t extSvMeasurement_len;  /**< Must be set to # of elements in extSvMeasurement */
  qmiLocSVMeasurementStructT_v02 extSvMeasurement[QMI_LOC_EXT_SV_MEAS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  Carrier Phase Measurement Uncertainty for Extended SVs */
  uint8_t extSvCarrierPhaseUncertainty_valid;  /**< Must be set to true if extSvCarrierPhaseUncertainty is being passed */
  uint32_t extSvCarrierPhaseUncertainty_len;  /**< Must be set to # of elements in extSvCarrierPhaseUncertainty */
  float extSvCarrierPhaseUncertainty[QMI_LOC_EXT_SV_MEAS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  Receiver Tick at Frame Count */
  uint8_t refCountTicks_valid;  /**< Must be set to true if refCountTicks is being passed */
  uint64_t refCountTicks;
  /**<   Receiver frame counter value in ticks. */

  /* Optional */
  /*  DGNSS Corrections Source Type */
  uint8_t dgnssCorrectionSourceT_valid;  /**< Must be set to true if dgnssCorrectionSourceT is being passed */
  qmiLocDgnssCorrectionSourceTypeEnumT_v02 dgnssCorrectionSourceT;
  /**<   If DGNSS is used, the DGNSS correction source.
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_INVALID (0) --  Invalid DGNSS correction source type \n
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_RTCM (1) --  DGNSS correction source type RTCM \n
      - eQMI_LOC_DGNSS_CORR_SOURCE_TYPE_3GPP (2) --  DGNSS correction source type 3GPP
 */

  /* Optional */
  /*  DGNSS SourceID */
  uint8_t dgnssCorrectionSourceID_valid;  /**< Must be set to true if dgnssCorrectionSourceID is being passed */
  uint32_t dgnssCorrectionSourceID;
  /**<   If using DGNSS, the SourceID is a 32bit number identifying the DGNSS source ID. */

  /* Optional */
  /*  DGNSS Ref Station ID */
  uint8_t dgnssRefStationId_valid;  /**< Must be set to true if dgnssRefStationId is being passed */
  uint16_t dgnssRefStationId;
  /**<   If using DGNSS, reference Station ID 0-4095 used to produce the pos report */

  /* Optional */
  /*  DGNSS Measurements Report for SVs */
  uint8_t dgnssSvMeasurement_valid;  /**< Must be set to true if dgnssSvMeasurement is being passed */
  uint32_t dgnssSvMeasurement_len;  /**< Must be set to # of elements in dgnssSvMeasurement */
  qmiLocDgnssSVMeasurementStructT_v02 dgnssSvMeasurement[QMI_LOC_DGNSS_SV_MEAS_LIST_MAX_SIZE_V02];
  /**<   \n If using DGNSS, the per SV measurement correction data.
       The elements 0 -- (QMI_LOC_SV_MEAS_LIST_MAX_SIZE -- 1) of this array correspond
       to the SV measurements in the TLV svMeasurement.
       The elements QMI_LOC_SV_MEAS_LIST_MAX_SIZE -- (QMI_LOC_DGNSS_SV_MEAS_LIST_MAX_SIZE -- 1) of
       this array correspond to the SV measurements in the TLV extSvMeasurement.
      */

  /* Optional */
  /*  Uncertainty for Receiver Tick at Frame Count */
  uint8_t refCountTicksUnc_valid;  /**< Must be set to true if refCountTicksUnc is being passed */
  float refCountTicksUnc;
  /**<   Uncertainty for receiver frame counter value. \n
       - Units -- milliseconds
  */

  /* Optional */
  /*  Sub-Sequence Number */
  uint8_t subSeqNum_valid;  /**< Must be set to true if subSeqNum is being passed */
  uint8_t subSeqNum;
  /**<   Current sub-sequence number for a specified sequence number (TLV 0x01).
       Used for segmentation/assembly of individual sequence numbers.
       If the number of SV measurements in one sequence number exceeds 24,
       multiple indications are sent with unique subSeqNum and common maxSubSeqNum.
       The control point is responsible for assembling the data for that
       sequence number using these fields. */

  /* Optional */
  /*  Maximum Sub-Sequence Number */
  uint8_t maxSubSeqNum_valid;  /**< Must be set to true if maxSubSeqNum is being passed */
  uint8_t maxSubSeqNum;
  /**<   Maximum number of sub-sequence numbers for a specified sequence number. */
}qmiLocEventGnssSvMeasInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint16_t qmiLocSvPolyStatusMaskT_v02;
#define QMI_LOC_SV_POLY_SRC_ALM_CORR_V02 ((qmiLocSvPolyStatusMaskT_v02)0x01) /**<  Polynomials based on XTRA. \n  */
#define QMI_LOC_SV_POLY_GLO_STR4_V02 ((qmiLocSvPolyStatusMaskT_v02)0x02) /**<  GLONASS string 4 has been received. \n  */
#define QMI_LOC_SV_POLY_DELETE_V02 ((qmiLocSvPolyStatusMaskT_v02)0x04) /**<  Polynomials are invalid and should be deleted. \n */
#define QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV_V02 ((qmiLocSvPolyStatusMaskT_v02)0x08) /**<  Polynomials based on Galileo FNAV if set; INAV otherwise.  */
typedef uint16_t qmiLocSvPolyStatusMaskValidityT_v02;
#define QMI_LOC_SV_POLY_SRC_ALM_CORR_VALID_V02 ((qmiLocSvPolyStatusMaskValidityT_v02)0x01) /**<  Validity status for QMI_LOC_SV_POLY_SRC_ALM_CORR. \n  */
#define QMI_LOC_SV_POLY_GLO_STR4_VALID_V02 ((qmiLocSvPolyStatusMaskValidityT_v02)0x02) /**<  Validity status for QMI_LOC_SV_POLY_GLO_STR4. \n   */
#define QMI_LOC_SV_POLY_DELETE_VALID_V02 ((qmiLocSvPolyStatusMaskValidityT_v02)0x04) /**<  Validity status for QMI_LOC_SV_POLY_DELETE. \n  */
#define QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV_VALID_V02 ((qmiLocSvPolyStatusMaskValidityT_v02)0x08) /**<  Validity status for QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV.  */
typedef uint64_t qmiLocSignalHealthMaskT_v02;
#define QMI_LOC_SIGNAL_HEALTH_MASK_L1_HEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0001ull) /**<  L1 signal is healthy \n  */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L2_HEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0002ull) /**<  L2 signal is healthy \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L5_HEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0004ull) /**<  L5 signal is healthy \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L1_UNKNOWN_V02 ((qmiLocSignalHealthMaskT_v02)0x0008ull) /**<  L1 signal health is unknown \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L2_UNKNOWN_V02 ((qmiLocSignalHealthMaskT_v02)0x0010ull) /**<  L2 signal health is unknown \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L5_UNKNOWN_V02 ((qmiLocSignalHealthMaskT_v02)0x0020ull) /**<  L5 signal health is unknown\n  */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L1_UNHEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0040ull) /**<  L1 signal is unhealthy \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L2_UNHEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0080ull) /**<  L2 signal is unhealthy \n */
#define QMI_LOC_SIGNAL_HEALTH_MASK_L5_UNHEALTHY_V02 ((qmiLocSignalHealthMaskT_v02)0x0100ull) /**<  L5 signal is unhealthy  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a satellite polynomial report to the control point. */
typedef struct {

  /* Mandatory */
  /*  GNSS SV Polynomial Report */
  uint16_t gnssSvId;
  /**<   GNSS SV ID. Range:   \n
         - GPS --  1 to 32 \n
         - GLONASS -- 65 to 96 \n
         - SBAS --    120 to 158 and 183 to 191 \n
         - QZSS --    193 to 197 \n
         - BDS --     201 to 263 \n
         - Galileo -- 301 to 336 \n
         - NavIC --   401 to 414
     */

  /* Mandatory */
  /*  Reference Time for Polynomial Calculations */
  double T0;
  /**<    Reference time for polynomial calculations. \n
          - GPS, QZSS -- Seconds in the week \n
          - GLONASS -- Full seconds since Jan. 1, 1996 \n
          - BDS -- Full seconds since Jan. 1, 2006 \n
          - Galileo -- Calculated from 00:00 UT on Sunday, August 22, 1999 (midnight between August 21 and August 22)
    */

  /* Mandatory */
  /*  SV Polynomial Validity Status */
  qmiLocSvPolyStatusMaskValidityT_v02 svPolyFlagValid;
  /**<   Validity mask for bits in svPolyFlags. A set bit in svPolyFlagValid indicates that a
 corresponding bit in svPolyFlags has valid status information.
 Valid bitmasks: \n
      - QMI_LOC_SV_POLY_SRC_ALM_CORR_VALID (0x01) --  Validity status for QMI_LOC_SV_POLY_SRC_ALM_CORR. \n
      - QMI_LOC_SV_POLY_GLO_STR4_VALID (0x02) --  Validity status for QMI_LOC_SV_POLY_GLO_STR4. \n
      - QMI_LOC_SV_POLY_DELETE_VALID (0x04) --  Validity status for QMI_LOC_SV_POLY_DELETE. \n
      - QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV_VALID (0x08) --  Validity status for QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV.  */

  /* Mandatory */
  /*  SV Polynomial Report Status */
  qmiLocSvPolyStatusMaskT_v02 svPolyFlags;
  /**<   Flags indicating the status of a polynomial report.
 Valid bitmasks: \n
      - QMI_LOC_SV_POLY_SRC_ALM_CORR (0x01) --  Polynomials based on XTRA. \n
      - QMI_LOC_SV_POLY_GLO_STR4 (0x02) --  GLONASS string 4 has been received. \n
      - QMI_LOC_SV_POLY_DELETE (0x04) --  Polynomials are invalid and should be deleted. \n
      - QMI_LOC_SV_POLY_SRC_GAL_FNAV_OR_INAV (0x08) --  Polynomials based on Galileo FNAV if set; INAV otherwise.  */

  /* Optional */
  /*  Polynomial Coefficient's 0th Term for X, Y, and Z Coordinates */
  uint8_t polyCoeffXYZ0_valid;  /**< Must be set to true if polyCoeffXYZ0 is being passed */
  double polyCoeffXYZ0[QMI_LOC_SV_POLY_XYZ_0_TH_ORDER_COEFF_SIZE_V02];
  /**<   0th term of the polynomial coefficient for X, Y, and Z coordinates (C0X, C0Y, C0Z). \n
         - Units -- Meters
    */

  /* Optional */
  /*  Polynomial Coefficient's 1st, 2nd, and 3rd Terms for X, Y, and Z Coordinates */
  uint8_t polyCoefXYZN_valid;  /**< Must be set to true if polyCoefXYZN is being passed */
  double polyCoefXYZN[QMI_LOC_SV_POLY_XYZ_N_TH_ORDER_COEFF_SIZE_V02];
  /**<   First, second, and third terms of the Polynomial coefficient for X, Y, and Z coordinates (C1X, C2X,... C2Z, C3Z).\n
          Units: \n
          - 1st term -- Meters per second \n
          - 2nd term -- Meters per second^2 \n
          - 3rd term -- Meters per seconds^3
    */

  /* Optional */
  /*  Polynomial Coefficients for Satellite Clock Bias Correction */
  uint8_t polyCoefClockBias_valid;  /**< Must be set to true if polyCoefClockBias is being passed */
  float polyCoefClockBias[QMI_LOC_SV_POLY_SV_CLKBIAS_COEFF_SIZE_V02];
  /**<    Polynomial coefficients for satellite clock bias correction (C0T, C1T, C2T, C3T). \n
          Units: \n
          - 0th term -- Milliseconds per second \n
          - First term -- Milliseconds per second^2 \n
          - Second term -- Milliseconds per second^3 \n
          - Third term -- Milliseconds per second^4
    */

  /* Optional */
  /*  GLONASS Frequency Number */
  uint8_t gloFrequency_valid;  /**< Must be set to true if gloFrequency is being passed */
  uint8_t gloFrequency;
  /**<   GLONASS frequency number + 8.
         Valid only for GLONASS systems, ignore for all other systems. \n
         - Range -- 1 to 14
    */

  /* Optional */
  /*  Ephemeris Reference Time */
  uint8_t IODE_valid;  /**< Must be set to true if IODE is being passed */
  uint16_t IODE;
  /**<   Ephemeris reference time. \n
         - GPS -- Issue of data ephemeris used (unitless) \n
         - GLONASS -- Tb 7-bit \n
         - Galileo -- 10-bit
    */

  /* Optional */
  /*  Enhanced Reference Time */
  uint8_t enhancedIOD_valid;  /**< Must be set to true if enhancedIOD is being passed */
  uint32_t enhancedIOD;
  /**<   For BDS ephemeris, this is TOE.
    */

  /* Optional */
  /*  SV Position Uncertainty */
  uint8_t svPosUnc_valid;  /**< Must be set to true if svPosUnc is being passed */
  float svPosUnc;
  /**<    SV position uncertainty. \n
          - Units -- Meters
    */

  /* Optional */
  /*  Iono Delay */
  uint8_t ionoDelay_valid;  /**< Must be set to true if ionoDelay is being passed */
  float ionoDelay;
  /**<   Ionospheric delay at T0. \n
         - Units -- Meters
    */

  /* Optional */
  /*  Iono Delay Rate */
  uint8_t ionoDot_valid;  /**< Must be set to true if ionoDot is being passed */
  float ionoDot;
  /**<   Ionospheric delay rate. \n
         - Units -- Meters per second
    */

  /* Optional */
  /*  SBAS Iono Delay */
  uint8_t sbasIonoDelay_valid;  /**< Must be set to true if sbasIonoDelay is being passed */
  float sbasIonoDelay;
  /**<   SBAS ionospheric delay at T0. \n
         - Units -- Meters
    */

  /* Optional */
  /*  SBAS Iono Delay Rate */
  uint8_t sbasIonoDot_valid;  /**< Must be set to true if sbasIonoDot is being passed */
  float sbasIonoDot;
  /**<   SBAS ionospheric delay rate. \n
         - Units -- Meters per second
    */

  /* Optional */
  /*  Tropospheric Delay */
  uint8_t tropoDelay_valid;  /**< Must be set to true if tropoDelay is being passed */
  float tropoDelay;
  /**<   Tropospheric delay. \n
         - Units -- Meters
    */

  /* Optional */
  /*  Satellite Elevation */
  uint8_t elevation_valid;  /**< Must be set to true if elevation is being passed */
  float elevation;
  /**<   Satellite elevation at T0. \n
         - Units -- Radians
    */

  /* Optional */
  /*  Satellite Elevation Rate */
  uint8_t elevationDot_valid;  /**< Must be set to true if elevationDot is being passed */
  float elevationDot;
  /**<   Satellite elevation rate. \n
         - Units -- Radians per second
    */

  /* Optional */
  /*  Satellite Elevation Uncertainty */
  uint8_t elenationUnc_valid;  /**< Must be set to true if elenationUnc is being passed */
  float elenationUnc;
  /**<   SV elevation uncertainty. \n
         - Units -- Radians
    */

  /* Optional */
  /*  Polynomial Coefficients for SV Velocity */
  uint8_t velCoef_valid;  /**< Must be set to true if velCoef is being passed */
  double velCoef[QMI_LOC_SV_POLY_VELOCITY_COEF_SIZE_V02];
  /**<   Polynomial coefficients for SV velocity (C0X, C1X, C2X, C3X,... C2Z, C3Z). \n
         Units: \n
          - 0th term -- Meters per second \n
          - 1st term -- Meters per second^2 \n
          - 2nd term -- Meters per second^3 \n
          - 3rd term -- Meters per second^4
    */

  /* Optional */
  /*  Intersignal Correction - GPS/QZSS L1C/A */
  uint8_t gpsIscL1ca_valid;  /**< Must be set to true if gpsIscL1ca is being passed */
  float gpsIscL1ca;
  /**<   Intersignal correction - GPS/QZSS L1C/A. \n
        - Units -- Milliseconds
    */

  /* Optional */
  /*  Intersignal Correction - GPS/QZSS L2C */
  uint8_t gpsIscL2c_valid;  /**< Must be set to true if gpsIscL2c is being passed */
  float gpsIscL2c;
  /**<   Intersignal correction - GPS/QZSS L2C. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Intersignal Correction - GPS/QZSS L5I5 */
  uint8_t gpsIscL5I5_valid;  /**< Must be set to true if gpsIscL5I5 is being passed */
  float gpsIscL5I5;
  /**<   Intersignal correction - GPS/QZSS L5I5. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Intersignal Correction - GPS/QZSS L5Q5 */
  uint8_t gpsIscL5Q5_valid;  /**< Must be set to true if gpsIscL5Q5 is being passed */
  float gpsIscL5Q5;
  /**<   Intersignal correction - GPS/QZSS L5Q5. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - GPS/QZSS */
  uint8_t gpsTgd_valid;  /**< Must be set to true if gpsTgd is being passed */
  float gpsTgd;
  /**<   Time of group delay -- GPS/QZSS.
         13 bits from CNAV, 8 bits from LNAV. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - GLONASS G1-G2 */
  uint8_t gloTgdG1G2_valid;  /**< Must be set to true if gloTgdG1G2 is being passed */
  float gloTgdG1G2;
  /**<   Time of group delay - GLONASS G1-G2. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - BDS B1 */
  uint8_t bdsTgdB1_valid;  /**< Must be set to true if bdsTgdB1 is being passed */
  float bdsTgdB1;
  /**<   Time of group delay -- BDS B1. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - BDS B2 */
  uint8_t bdsTgdB2_valid;  /**< Must be set to true if bdsTgdB2 is being passed */
  float bdsTgdB2;
  /**<   Time of group delay -- BDS B2. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - BDS B2A */
  uint8_t bdsTgdB2a_valid;  /**< Must be set to true if bdsTgdB2a is being passed */
  float bdsTgdB2a;
  /**<   Time of group delay -- BDS B2A. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Inter-Signal Correction - BDS B2A */
  uint8_t bdsIscB2a_valid;  /**< Must be set to true if bdsIscB2a is being passed */
  float bdsIscB2a;
  /**<   Inter-signal correction -- BDS B2A. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Broadcast Group Delay - Galielo E1-E5a */
  uint8_t galBgdE1E5a_valid;  /**< Must be set to true if galBgdE1E5a is being passed */
  float galBgdE1E5a;
  /**<   Broadcast group delay -- Galileo E1-E5a. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Broadcast Group Delay - Galileo E1-E5b */
  uint8_t galBgdE1E5b_valid;  /**< Must be set to true if galBgdE1E5b is being passed */
  float galBgdE1E5b;
  /**<   Broadcast group delay -- Galileo E1-E5b. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - NavIC L5 */
  uint8_t navicTgdL5_valid;  /**< Must be set to true if navicTgdL5 is being passed */
  float navicTgdL5;
  /**<   Time of group delay -- NavIC L5. \n
        - Units -- Milliseconds
    */

  /* Optional */
  /*  Time of Group Delay - BDS B1C (Pilot) */
  uint8_t bdsTgdB1c_valid;  /**< Must be set to true if bdsTgdB1c is being passed */
  float bdsTgdB1c;
  /**<   Time of group delay -- BDS B1C. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Intersignal Correction - BDS B1C */
  uint8_t bdsIscB1c_valid;  /**< Must be set to true if bdsIscB1c is being passed */
  float bdsIscB1c;
  /**<   Intersignal correction between BDS B1C data and pilot channels. \n
         - Units -- Milliseconds
    */

  /* Optional */
  /*  Multiband Health Information */
  uint8_t multibandHealth_valid;  /**< Must be set to true if multibandHealth is being passed */
  qmiLocSignalHealthMaskT_v02 multibandHealth;
  /**<   Multiband health information. GNSS signals under L1/L2/L5 are:\n
 - L1 -- GPS L1, QZSS L1, BDS B1, GLO G1, GAL E1 \n
 - L2 -- BDS B1C, GPS L2C, QZSS L2C \n
 - L5 -- GPS L5, QZSS L5, BDS B2A, GAL E5a, NAVIC L5 \n
 Valid bitmasks \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L1_HEALTHY (0x0001) --  L1 signal is healthy \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L2_HEALTHY (0x0002) --  L2 signal is healthy \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L5_HEALTHY (0x0004) --  L5 signal is healthy \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L1_UNKNOWN (0x0008) --  L1 signal health is unknown \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L2_UNKNOWN (0x0010) --  L2 signal health is unknown \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L5_UNKNOWN (0x0020) --  L5 signal health is unknown\n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L1_UNHEALTHY (0x0040) --  L1 signal is unhealthy \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L2_UNHEALTHY (0x0080) --  L2 signal is unhealthy \n
      - QMI_LOC_SIGNAL_HEALTH_MASK_L5_UNHEALTHY (0x0100) --  L5 signal is unhealthy
 */
}qmiLocEventGnssSvPolyIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t wifiApMacAddress[QMI_LOC_WIFI_MAC_ADDR_LENGTH_V02];
  /**<   MAC address of the Wi-Fi AP. */
}qmiLocWifiApMacAddressStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  char uuid[QMI_LOC_MAX_IBEACON_UUID_STR_LENGTH_V02 + 1];
  /**<   NULL-terminated IBeacon identifier string; a 128-bit value. */

  uint32_t majorNumber;
  /**<   IBeacon major number.*/

  uint32_t minorNumber;
  /**<   IBeacon minor number.*/
}qmiLocIBeaconIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject the Geofence context. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The
       QMI_LOC_ADD_GEOFENCE_CONTEXT_IND indication returns the transaction ID. */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Geofence identifier allocated by the engine.
       If the Geofence ID is not provided, a Geofence is created with an Area ID
       list only (for example, Wi-Fi only list Geofence). \n
       If the Geofence ID is provided, the added list is used as assistance data
       to the existing Geofence. */

  /* Optional */
  /*  Wi-Fi AP SSID String */
  uint8_t wifiApSsidInfo_valid;  /**< Must be set to true if wifiApSsidInfo is being passed */
  uint32_t wifiApSsidInfo_len;  /**< Must be set to # of elements in wifiApSsidInfo */
  qmiLocWifiApSsidStructT_v02 wifiApSsidInfo[QMI_LOC_WIFI_AREA_ID_LIST_LENGTH_V02];
  /**<   \vspace{4pt} \n The ordering of the Wi-Fi AP SSID list must match the Wi-Fi AP MAC address
       list when both are provided, that is, the first element of the Wi-Fi AP SSID list must be
       the SSID of the AP whose MAC address is in the first element in the Wi-Fi AP MAC address, and so on.
       */

  /* Optional */
  /*  Wi-Fi AP MAC Address List for the Geofence */
  uint8_t wifiApMacAddressList_valid;  /**< Must be set to true if wifiApMacAddressList is being passed */
  uint32_t wifiApMacAddressList_len;  /**< Must be set to # of elements in wifiApMacAddressList */
  qmiLocWifiApMacAddressStructT_v02 wifiApMacAddressList[QMI_LOC_WIFI_AREA_ID_LIST_LENGTH_V02];
  /**<   \n The ordering of the Wi-Fi AP SSID list must match the Wi-Fi AP MAC address
       list when both are provided, that is, the first element of the Wi-Fi AP SSID list must be the
       SSID of the AP whose MAC address is in the first element in the Wi-Fi AP MAC address, and so on.
   */

  /* Optional */
  /*  TDSCDMA Cell ID List for the Geofence */
  uint8_t tdsCdmaCellIDList_valid;  /**< Must be set to true if tdsCdmaCellIDList is being passed */
  qmiLocTDSCDMACellIdStructT_v02 tdsCdmaCellIDList[QMI_LOC_CELL_ID_LIST_LENGTH_V02];
  /**<   \n Identifies the TDSCDMA cell on which the device is camped. */

  /* Optional */
  /*  WCDMA Cell ID List for the Geofence */
  uint8_t wcdmaCellIDList_valid;  /**< Must be set to true if wcdmaCellIDList is being passed */
  uint32_t wcdmaCellIDList_len;  /**< Must be set to # of elements in wcdmaCellIDList */
  qmiLocWCDMACellIdStructT_v02 wcdmaCellIDList[QMI_LOC_CELL_ID_LIST_LENGTH_V02];
  /**<   \vspace{4pt} \n Identifies the WCDMA cell on which the device is camped. */

  /* Optional */
  /*  GSM Cell ID List for the Geofence */
  uint8_t gsmCellIDList_valid;  /**< Must be set to true if gsmCellIDList is being passed */
  uint32_t gsmCellIDList_len;  /**< Must be set to # of elements in gsmCellIDList */
  qmiLocGSMCellIdStructT_v02 gsmCellIDList[QMI_LOC_CELL_ID_LIST_LENGTH_V02];
  /**<   \n Identifies the GSM cell on which the device is camped. */

  /* Optional */
  /*  IBeacon List of the Geofence */
  uint8_t iBeaconList_valid;  /**< Must be set to true if iBeaconList is being passed */
  uint32_t iBeaconList_len;  /**< Must be set to # of elements in iBeaconList */
  qmiLocIBeaconIdStructT_v02 iBeaconList[QMI_LOC_IBEACON_LIST_LENGTH_V02];
}qmiLocAddGeofenceContextReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject the Geofence context. */
typedef struct {

  /* Mandatory */
  /*  Status of the Add Geofence Context Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_ADD_GEOFENCE_CONTEXT_REQ request.
 Valid values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_ADD_GEOFENCE_CONTEXT_REQ
       request. This parameter is always present
       if the status field is set to SUCCESS. */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Geofence identifier allocated by the engine.    \n
       If the client specifies the Geofence ID during the QMI_LOC_ADD_GEOFENCE_CONTEXT_REQ request,
       the same ID is returned.    \n
       If the client does not specify the Geofence ID during the QMI_LOC_ADD_GEOFENCE_CONTEXT_REQ request,
       a new Geofence ID is created by the Geofence engine and returned. */

  /* Optional */
  /*  Context ID */
  uint8_t contextId_valid;  /**< Must be set to true if contextId is being passed */
  uint32_t contextId;
  /**<   Geofence context ID allocated by the engine.
       The Geofence engine generates the context ID to identify the context
       for a particular Geofence ID.
       The same Geofence ID can be associated with multiple contexts.  */
}qmiLocAddGeofenceContextIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject the Geofence engine context. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_IND
       indication returns the transaction ID . */

  /* Optional */
  /*  UTC Timestamp of the Day */
  uint8_t utcTimeOfDay_valid;  /**< Must be set to true if utcTimeOfDay is being passed */
  uint64_t utcTimeOfDay;
  /**<   The UTC time of the day.  */

  /* Optional */
  /*  Temperature of the Day in Fahrenheit */
  uint8_t temperature_valid;  /**< Must be set to true if temperature is being passed */
  int32_t temperature;
  /**<   The temperature of the day in degrees Fahrenheit.  */
}qmiLocSetGeofenceEngineContextReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject the Geofence engine context. */
typedef struct {

  /* Mandatory */
  /*  Status of the Set Geofence Engine Context Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Set Geofence Engine Context request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID that was specified in the QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_REQ
       request. This parameter is always present
       when the status field is set to SUCCESS. */
}qmiLocSetGeofenceEngineContextIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to delete the Geofence context. */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The QMI_LOC_DELETE_GEOFENCE_CONTEXT_IND
       indication retruns the transaction ID. */

  /* Mandatory */
  /*  Geofence ID */
  uint32_t geofenceId;
  /**<   Identifies the Geofence whose context to delete.  */

  /* Optional */
  /*  Context ID */
  uint8_t contextId_valid;  /**< Must be set to true if contextId is being passed */
  uint32_t contextId;
  /**<   Identifies the context associated with the Geofence to delete.
       If not specified, all contexts associated with this Geofence are deleted. */
}qmiLocDeleteGeofenceContextReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to delete the Geofence context. */
typedef struct {

  /* Mandatory */
  /*  Status of the Delete Geofence Context Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_DELETE_GEOFENCE_CONTEXT_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Transaction ID specified in the QMI_LOC_DELETE_GEOFENCE_CONTEXT_REQ request.
       This parameter is always present
       when the status field is set to SUCCESS. */

  /* Optional */
  /*  Geofence ID */
  uint8_t geofenceId_valid;  /**< Must be set to true if geofenceId is being passed */
  uint32_t geofenceId;
  /**<   Identifier for the Geofence whose context was deleted. */

  /* Optional */
  /*  Context ID */
  uint8_t contextId_valid;  /**< Must be set to true if contextId is being passed */
  uint32_t contextId;
  /**<   Identifier for the context of the Geofence that was deleted. */
}qmiLocDeleteGeofenceContextIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects Global Terrestrial Positioning (GTP) WWAN client downloaded data. */
typedef struct {

  /* Mandatory */
  /*  Data */
  uint32_t ClientDownloadedData_len;  /**< Must be set to # of elements in ClientDownloadedData */
  char ClientDownloadedData[QMI_LOC_MAX_GTP_WWAN_CLIENT_DOWNLOADED_DATA_LEN_V02];
  /**<   WWAN client downloaded data. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 512
    */
}qmiLocInjectGtpClientDownloadedDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects Global Terrestrial Positioning (GTP) WWAN client downloaded data. */
typedef struct {

  /* Mandatory */
  /*  GTP Client Downloaded Data Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GTP client downloaded data injection.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectGtpClientDownloadedDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends a GDT upload begin response to GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  Access Status to GDT */
  qmiLocGdtAccessStatusEnumT_v02 gdtAccessStatus;
  /**<   GDT status information for this service ID.
 Values: \n
      - eQMI_LOC_GDT_ACCESS_ALLOWED (1) --  GDT access to the service is allowed \n
      - eQMI_LOC_GDT_ACCESS_FAILED (2) --  Any type of GDT access error \n
      - eQMI_LOC_GDT_ACCESS_NOT_ALLOWED (3) --  GDT access to the service is not allowed
 */
}qmiLocGdtUploadBeginStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a GDT upload begin response to GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Upload Begin Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GDT begin request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtUploadBeginStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGDTENDACKENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GDT_ACK_SUCCESS_V02 = 1, /**<  The sent data is accepted \n   */
  eQMI_LOC_GDT_ACK_FAILED_V02 = 2, /**<  The sent data was not accepted \n  */
  eQMI_LOC_GDT_ACK_INVALID_V02 = 3, /**<  General error in the received data  */
  QMILOCGDTENDACKENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGdtEndAckEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends a GDT upload end response to GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  Access Status to GDT */
  qmiLocGdtEndAckEnumT_v02 gdtEndStatus;
  /**<   GDT end status information for this service ID.
 Values: \n
      - eQMI_LOC_GDT_ACK_SUCCESS (1) --  The sent data is accepted \n
      - eQMI_LOC_GDT_ACK_FAILED (2) --  The sent data was not accepted \n
      - eQMI_LOC_GDT_ACK_INVALID (3) --  General error in the received data
 */
}qmiLocGdtUploadEndReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a GDT upload end response to GDT MP. */
typedef struct {

  /* Mandatory */
  /*  UTC GDT Upload End Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GDT upload end request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtUploadEndIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGTPAPSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GTP_AP_STATUS_DB_READY_V02 = 1, /**<  Indicates that the AP is initialized and ready to process MP download requests   */
  eQMI_LOC_GTP_AP_STATUS_DB_REFRESHED_V02 = 2, /**<  Indicates that the AP has successfully refreshed partitions \n  */
  eQMI_LOC_GTP_AP_STATUS_DB_DELETED_V02 = 3, /**<  Indicates that the AP has removed local partitions   */
  QMILOCGTPAPSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGtpApStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends a Global Terrestrial Position (GTP) message to the MP
                    notifying the GTP MP of AP DB readiness. */
typedef struct {

  /* Mandatory */
  /*  AP DB Status */
  qmiLocGtpApStatusEnumT_v02 gtpApDbStatus;
  /**<   GTP AP DB status information.
 Values: \n
      - eQMI_LOC_GTP_AP_STATUS_DB_READY (1) --  Indicates that the AP is initialized and ready to process MP download requests
      - eQMI_LOC_GTP_AP_STATUS_DB_REFRESHED (2) --  Indicates that the AP has successfully refreshed partitions \n
      - eQMI_LOC_GTP_AP_STATUS_DB_DELETED (3) --  Indicates that the AP has removed local partitions
 */

  /* Optional */
  /*  AP PCID (8 byte) */
  uint8_t gtpApPcid64_valid;  /**< Must be set to true if gtpApPcid64 is being passed */
  uint64_t gtpApPcid64;
  /**<   AP pseudoclient ID. */

  /* Optional */
  /*  OEM ID (Non-NULL Terminated) */
  uint8_t oemId_valid;  /**< Must be set to true if oemId is being passed */
  uint32_t oemId_len;  /**< Must be set to # of elements in oemId */
  char oemId[QMI_LOC_MAX_OEM_ID_LEN_V02];
  /**<   OEM ID. \n
         - Type -- character string \n
         - Maximum length of the array -- 256
    */

  /* Optional */
  /*  Model ID (Non-NULL Terminated) */
  uint8_t modelId_valid;  /**< Must be set to true if modelId is being passed */
  uint32_t modelId_len;  /**< Must be set to # of elements in modelId */
  char modelId[QMI_LOC_MAX_MODEL_ID_LEN_V02];
  /**<   Model ID. \n
         - Type -- character string \n
         - Maximum length of the array -- 256
    */
}qmiLocGtpApStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t asnMajorVersion;
  /**<   ASN major version. */

  uint8_t asnMinorVersion;
  /**<   ASN minor version. */

  uint8_t asnPointVersion;
  /**<   ASN point version. */
}qmiLocGtpAsnVerStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a Global Terrestrial Position (GTP) message to the MP
                    notifying the GTP MP of AP DB readiness. */
typedef struct {

  /* Mandatory */
  /*  GTP MP Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GTP handshake.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  MP Client Software Version */
  uint16_t clientSoftwareVersion;
  /**<   MP client software version. */

  /* Mandatory */
  /*  MP ASN Version */
  qmiLocGtpAsnVerStructT_v02 asnVersion;
}qmiLocGtpApStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGTPPROCESSSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GTP_PROCESS_SUCCESS_FROM_LOCAL_V02 = 1, /**<  DL processing was processed successfully locally \n  */
  eQMI_LOC_GTP_PROCESS_SUCCESS_FROM_SERVER_V02 = 2, /**<  DL processing was processed successfully via server access \n  */
  eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_AP_NOT_READY_V02 = 3, /**<  DL processing is not allowed because the AP is not ready \n  */
  eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_AP_TIMEOUT_V02 = 4, /**<  DL processing is not allowed because the AP cannot process within the specified interval \n  */
  eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_NO_CONNECTIVITY_V02 = 5, /**<  DL processing via server is not allowed because the AP has no connectivity, but
       it is processed locally \n  */
  eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_THROTTLED_V02 = 6, /**<  DL processing via server is not allowed due to throttling, but it is
       processed locally \n  */
  eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_OTHER_V02 = 7, /**<  DL processing via server is not allowed for another reason, but it is
       processed locally \n    */
  eQMI_LOC_GTP_PROCESS_FAILED_UNSPECIFIED_V02 = 8, /**<  DL processing failed for any other reason   */
  QMILOCGTPPROCESSSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGtpProcessStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends a GTP message to the MP notifying it of an AP download response. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  AP Process Status */
  qmiLocGtpProcessStatusEnumT_v02 processingStatus;
  /**<   AP processing status information for this service ID.
 Values: \n
      - eQMI_LOC_GTP_PROCESS_SUCCESS_FROM_LOCAL (1) --  DL processing was processed successfully locally \n
      - eQMI_LOC_GTP_PROCESS_SUCCESS_FROM_SERVER (2) --  DL processing was processed successfully via server access \n
      - eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_AP_NOT_READY (3) --  DL processing is not allowed because the AP is not ready \n
      - eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_AP_TIMEOUT (4) --  DL processing is not allowed because the AP cannot process within the specified interval \n
      - eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_NO_CONNECTIVITY (5) --  DL processing via server is not allowed because the AP has no connectivity, but
       it is processed locally \n
      - eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_THROTTLED (6) --  DL processing via server is not allowed due to throttling, but it is
       processed locally \n
      - eQMI_LOC_GTP_PROCESS_NOT_ALLOWED_OTHER (7) --  DL processing via server is not allowed for another reason, but it is
       processed locally \n
      - eQMI_LOC_GTP_PROCESS_FAILED_UNSPECIFIED (8) --  DL processing failed for any other reason
 */

  /* Optional */
  /*  WWAN Download Flag */
  uint8_t wwanDownloadFlag_valid;  /**< Must be set to true if wwanDownloadFlag is being passed */
  uint16_t wwanDownloadFlag;
  /**<   WWAN download flag. */

  /* Optional */
  /*  Encoded Response Location Information */
  uint8_t respLocInfo_valid;  /**< Must be set to true if respLocInfo is being passed */
  uint32_t respLocInfo_len;  /**< Must be set to # of elements in respLocInfo */
  uint8_t respLocInfo[QMI_LOC_MAX_GTP_RLI_LEN_V02];
  /**<   Response location information encoded in asn.1 format. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 256
    */

  /* Optional */
  /*  AP Remaining Throttle Time */
  uint8_t apRemainingThrottleTime_valid;  /**< Must be set to true if apRemainingThrottleTime is being passed */
  uint32_t apRemainingThrottleTime;
  /**<   Remaining time in seconds during which the AP remains throttled for server access. */
}qmiLocGdtDownloadBeginStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a GTP message to the MP notifying it of an AP download response. */
typedef struct {

  /* Mandatory */
  /*  GDT Download Begin Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GDT begin request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtDownloadBeginStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Sends a GTP message to the MP notifying it of data readiness. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  Processing Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the AP processing request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Data File Path (NULL Terminated) */
  uint32_t filePath_len;  /**< Must be set to # of elements in filePath */
  char filePath[QMI_LOC_MAX_GDT_PATH_LEN_V02];
  /**<   File path to the data. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 255
    */
}qmiLocGdtDownloadReadyStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a GTP message to the MP notifying it of data readiness. */
typedef struct {

  /* Mandatory */
  /*  GDT Ready Begin Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GDT ready request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtDownloadReadyStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Acknowledges receipt of Receive Done to the GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  QMI LOC Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocGdtReceiveDoneStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Acknowledges receipt of Receive Done to the GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Receive Done Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Receive Done request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtReceiveDoneStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Acknowledges the receipt of download completion to the GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Service ID */
  qmiLocGdtServiceIdEnumT_v02 serviceId;
  /**<   Values: \n
      - eQMI_LOC_GDT_SERVICE_WWAN (1) --  GDT service for WWAN UL \n
      - eQMI_LOC_GDT_SERVICE_WWAN_DL (2) --  GDT service for WWAN DL \n
      - eQMI_LOC_GDT_SERVICE_CSM_UL (3) --  GDT service for Crowdsource Manager UL  */

  /* Mandatory */
  /*  Session ID */
  uint32_t sessionId;
  /**<   Session ID. */

  /* Mandatory */
  /*  QMI LOC Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocGdtDownloadEndStatusReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Acknowledges the receipt of download completion to the GDT MP. */
typedef struct {

  /* Mandatory */
  /*  GDT Download End Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the GDT download end request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocGdtDownloadEndStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDBTUSAGEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_DBT_USAGE_NAVIGATION_V02 = 1, /**<  Navigation usage type.  */
  QMILOCDBTUSAGEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDbtUsageEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDBDISTANCETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_DBT_DISTANCE_TYPE_STRAIGHT_LINE_V02 = 1, /**<  Straight line distance between
       location updates.   */
  QMILOCDBDISTANCETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDbDistanceTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to initiate a Distance Based Tracking (DBT) session. */
typedef struct {

  /* Mandatory */
  /*  Request ID */
  uint8_t reqId;
  /**<   ID of the request as identified by the control point. The request ID
       is reported back in the position reports. The control point must
       specify the same request ID in the QMI_LOC_STOP_DBT_REQ message. \n
       - Range -- 0 to 255
  */

  /* Mandatory */
  /*  Minimum Distance Between Position Reports */
  uint32_t minDistance;
  /**<   Minimum distance, specified by the control point,
       that must be traversed between position reports. \n
       - Units -- Meters
  */

  /* Mandatory */
  /*  Type of Distance to Track */
  qmiLocDbDistanceTypeEnumT_v02 distanceType;
  /**<   Straight line distance or accumulated distance. \n
 Values: \n
      - eQMI_LOC_DBT_DISTANCE_TYPE_STRAIGHT_LINE (1) --  Straight line distance between
       location updates.
 */

  /* Mandatory */
  /*  Need Origin Location */
  uint8_t needOriginLocation;
  /**<   Indicates whether the control point wants the position
       corresponding to the origin. \n
       - 0x01 (TRUE)  -- Control point is requesting origin
                                location \n
       - 0x00 (FALSE) -- Control point is not requesting origin
                                location
  */

  /* Optional */
  /*  Maximum Latency Threshold for Position Reports */
  uint8_t maxLatency_valid;  /**< Must be set to true if maxLatency is being passed */
  uint32_t maxLatency;
  /**<   Maximum time period, specified by the control point, after the minimum
       distance criteria has been met within which a location update must
       be provided. If not specified, an ideal value is assumed by the
       engine.  \n
       - Units -- seconds
  */

  /* Optional */
  /*  Usage Type */
  uint8_t usageType_valid;  /**< Must be set to true if usageType is being passed */
  qmiLocDbtUsageEnumT_v02 usageType;
  /**<   Specifies the type of usage by the control point, referring specifically
 to the use case category of the client. For example, a navigation client can
 set this to QMI_LOC_USAGE_NAVIGATION for better performance in difficult
 signal conditions, such as tunnels.
 If not specified, the service uses default algorithms to provide an ideal
 performance.
 Values: \n
      - eQMI_LOC_DBT_USAGE_NAVIGATION (1) --  Navigation usage type.
 */
}qmiLocStartDbtReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to initiate a Distance Based Tracking (DBT) session. */
typedef struct {

  /* Mandatory */
  /*  Start DBT Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Start DBT request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Request ID */
  uint8_t reqId_valid;  /**< Must be set to true if reqId is being passed */
  uint8_t reqId;
  /**<   ID of the DBT start request for which this
       indication was generated. */
}qmiLocStartDbtIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to stop a DBT session. */
typedef struct {

  /* Mandatory */
  /*  Request ID */
  uint8_t reqId;
  /**<   ID of the request specified in the Start DBT
        request (QMI_LOC_START_DBT_REQ).\n
       - Range -- 0 to 255 */
}qmiLocStopDbtReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to stop a DBT session. */
typedef struct {

  /* Mandatory */
  /*  Stop DBT Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Stop DBT request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Request ID */
  uint8_t reqId_valid;  /**< Must be set to true if reqId is being passed */
  uint8_t reqId;
  /**<   ID of the DBT stop request for which this
       indication was generated. */
}qmiLocStopDbtIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDBTPOSITIONTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_DBT_POSITION_TYPE_ORIGIN_V02 = 1, /**<  Position reported is at the origin \n */
  eQMI_LOC_DBT_POSITION_TYPE_TRACKING_V02 = 2, /**<  Position reported is a tracking type
       where the origin location has already
       been reported  */
  QMILOCDBTPOSITIONTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDbtPositionTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  /*  UTC Timestamp */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds since Jan. 1, 1970
  */

  /*  Latitude */
  double latitude;
  /**<   Latitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0    \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
      */

  /*   Longitude */
  double longitude;
  /**<   Longitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0  \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
    */

  /*  Horizontal elliptical uncertainty (semi-minor axis) */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /*  Horizontal elliptical uncertainty (wemi-major axis) */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty.\n
       - Units -- Meters */

  /*  Elliptical horizontal uncertainty azimuth */
  float horUncEllipseOrientAzimuth;
  /**<   Elliptical horizontal uncertainty azimuth of orientation.\n
       - Units -- Decimal degrees \n
       - Range -- 0 to 180 */

  /*  Horizontal Speed Validity Bit */
  uint8_t speedHorizontal_valid;
  /**<   Indicates whether the horizontal speed field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
  */

  /*  Horizontal Speed */
  float speedHorizontal;
  /**<   Horizontal speed.\n
       - Units -- Meters per second */

  /*  Altitude Validity Bit */
  uint8_t altitudeWrtEllipsoid_valid;
  /**<   Indicates whether the altitude field contains valid
       information.    \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
       */

  /*  Altitude With Respect to Ellipsoid */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  /*  Vertical Uncertainty Validity Bit */
  uint8_t vertUnc_valid;
  /**<   Indicates whether the vertical uncertainty field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
  */

  /*  Vertical Uncertainty */
  float vertUnc;
  /**<   Units -- Meters */

  /*  Vertical Speed Validity Bit */
  uint8_t speedVertical_valid;
  /**<   Indicates whether the vertical speed field contains valid
       information. \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
  */

  /*  Vertical Speed */
  float speedVertical;
  /**<   Units -- Meters per second */

  /*  Heading Validity Bit */
  uint8_t heading_valid;
  /**<   Indicates whether the heading field contains valid
       information.  \n
       - 0x01 (TRUE)  -- Valid \n
       - 0x00 (FALSE) -- Invalid and must be ignored
  */

  /*  Heading */
  float heading;
  /**<   - Units -- Degrees \n
        - Range -- 0 to 359.999  */
}qmiLocDbtPositionStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of
                    a DBT position report. */
typedef struct {

  /* Mandatory */
  /*  Request ID */
  uint8_t reqId;
  /**<   ID of the DBT request for which this
       report was generated. */

  /* Mandatory */
  /*  DBT Position */
  qmiLocDbtPositionStructT_v02 dbtPosition;
  /**<   \n Position of the client when it has traversed the
       specified distance.
       */

  /* Mandatory */
  /*  DBT Position Type */
  qmiLocDbtPositionTypeEnumT_v02 positionType;
  /**<   Specifies whether the position reported is at the
 origin of the DBT session or during the tracking
 duration of the session. Values: \n
      - eQMI_LOC_DBT_POSITION_TYPE_ORIGIN (1) --  Position reported is at the origin \n
      - eQMI_LOC_DBT_POSITION_TYPE_TRACKING (2) --  Position reported is a tracking type
       where the origin location has already
       been reported  */

  /* Optional */
  /*  Heading Uncertainty */
  uint8_t headingUnc_valid;  /**< Must be set to true if headingUnc is being passed */
  float headingUnc;
  /**<   Heading uncertainty.\n
       - Units -- Degrees \n
       - Range -- 0 to 359.999 */

  /* Optional */
  /*  Speed Uncertainty */
  uint8_t speedUnc_valid;  /**< Must be set to true if speedUnc is being passed */
  float speedUnc;
  /**<   3D speed uncertainty.\n
       - Units -- Meters per second */

  /* Optional */
  /*  Horizontal Confidence */
  uint8_t horConfidence_valid;  /**< Must be set to true if horConfidence is being passed */
  uint8_t horConfidence;
  /**<   Horizontal uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence.\n
       - Units -- Percent \n
       - Range -- 0 to 99 */

  /* Optional */
  /*  Dilution of Precision */
  uint8_t DOP_valid;  /**< Must be set to true if DOP is being passed */
  qmiLocDOPStructT_v02 DOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  SVs Used to Calculate the Fix */
  uint8_t gnssSvUsedList_valid;  /**< Must be set to true if gnssSvUsedList is being passed */
  uint32_t gnssSvUsedList_len;  /**< Must be set to # of elements in gnssSvUsedList */
  uint16_t gnssSvUsedList[QMI_LOC_MAX_SV_USED_LIST_LENGTH_V02];
  /**<   Each entry in the list contains the SV ID of a satellite
       used for calculating this position report. The following
       information is associated with each SV ID:
       Range:    \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96 \n
      - SBAS --    120 to 158 and 183 to 191 \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414
  */

  /* Optional */
  /*  Position Source */
  uint8_t positionSrc_valid;  /**< Must be set to true if positionSrc is being passed */
  qmiLocPositionSrcEnumT_v02 positionSrc;
  /**<   Source from which this position was obtained.
 Values: \n
      - eQMI_LOC_POSITION_SRC_GNSS (0) --  Position source is GNSS \n
      - eQMI_LOC_POSITION_SRC_CELLID (1) --  Position source is Cell ID \n
      - eQMI_LOC_POSITION_SRC_ENH_CELLID (2) --  Position source is Enhanced Cell ID \n
      - eQMI_LOC_POSITION_SRC_WIFI (3) --  Position source is Wi-Fi \n
      - eQMI_LOC_POSITION_SRC_TERRESTRIAL (4) --  Position source is Terrestrial \n
      - eQMI_LOC_POSITION_SRC_GNSS_TERRESTRIAL_HYBRID (5) --  Position source is GNSS Terrestrial Hybrid \n
      - eQMI_LOC_POSITION_SRC_OTHER (6) --  Other sources \n
      - eQMI_LOC_POSITION_SRC_DRE (7) --  Position source is the dead reckoning engine
 */

  /* Optional */
  /*  Extended Dilution of Precision */
  uint8_t extDOP_valid;  /**< Must be set to true if extDOP is being passed */
  qmiLocExtDOPStructT_v02 extDOP;
  /**<   \vspace{0.06in} \n Dilution of precision associated with this position. */

  /* Optional */
  /*  Expanded SVs Used to Calculate the Fix */
  uint8_t expandedGnssSvUsedList_valid;  /**< Must be set to true if expandedGnssSvUsedList is being passed */
  uint32_t expandedGnssSvUsedList_len;  /**< Must be set to # of elements in expandedGnssSvUsedList */
  uint16_t expandedGnssSvUsedList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   If the service reports expandedGnssSvUsedList, gnssSvUsedList is
      not reported. Each entry in the list contains the SV ID of a satellite
      used to calculate this position report. The following
      information is associated with each SV ID. \n
      Range: \n
      - GPS --     1 to 32 \n
      - GLONASS -- 65 to 96  \n
      - QZSS --    193 to 197 \n
      - BDS --     201 to 263 \n
      - Galileo -- 301 to 336 \n
      - NavIC --   401 to 414\n
      */

  /* Optional */
  /*  Satellite Signal Types in the SVs Used List */
  uint8_t gnssSvUsedSignalTypeList_valid;  /**< Must be set to true if gnssSvUsedSignalTypeList is being passed */
  uint32_t gnssSvUsedSignalTypeList_len;  /**< Must be set to # of elements in gnssSvUsedSignalTypeList */
  qmiLocGnssSignalTypeMaskT_v02 gnssSvUsedSignalTypeList[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the signal type of each satellite in expandedGnssSvUsedList. The
 signal type list aligns with the SVs in expandedGnssSvUsedList. Value 0
 means invalid.\n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */
}qmiLocEventDbtPositionReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDBTSESSIONSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_DBT_UNABLE_TO_TRACK_V02 = 1, /**<  Distance based tracking is unavailable and DBT fixes
       cannot be obtained \n */
  eQMI_LOC_DBT_ABLE_TO_TRACK_V02 = 2, /**<  Distance based tracking is available and DBT fixes
       can be obtained  */
  QMILOCDBTSESSIONSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDbtSessionStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of the DBT session status. */
typedef struct {

  /* Mandatory */
  /*  DBT Session Status */
  qmiLocDbtSessionStatusEnumT_v02 dbtSessionStatus;
  /**<   Specifies the DBT session status type.
 Values: \n
      - eQMI_LOC_DBT_UNABLE_TO_TRACK (1) --  Distance based tracking is unavailable and DBT fixes
       cannot be obtained \n
      - eQMI_LOC_DBT_ABLE_TO_TRACK (2) --  Distance based tracking is available and DBT fixes
       can be obtained
 */

  /* Optional */
  /*  Request ID */
  uint8_t reqId_valid;  /**< Must be set to true if reqId is being passed */
  uint8_t reqId;
  /**<   ID of the DBT request for which this
       status was generated. */
}qmiLocEventDbtSessionStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPOSITIONSOURCEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POS_SRC_GNSS_V02 = 1, /**<  Source of the position is GNSS  */
  QMILOCPOSITIONSOURCEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPositionSourceEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPOSITIONRPTPROPAGATIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POS_REPORT_PROPAGATED_TO_CURRENT_UTC_V02 = 1, /**<  Reported position is propagated to the current UTC  */
  QMILOCPOSITIONRPTPROPAGATIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPositionRptPropagationEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSECURELOCDATAMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SECURE_LOC_DATA_ENCRYPTED_V02 = 1, /**<  Encrypt data in the indication \n */
  eQMI_LOC_SECURE_LOC_DATA_UNENCRYPTED_V02 = 2, /**<  Unencrypt data in the indication  */
  QMILOCSECURELOCDATAMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSecureLocDataModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSECUREGETAVAILABLEPOSPARAMETERIDENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_PARAM_TRANSACTION_ID_V02 = 1, /**<  Parameter ID for the Transaction ID field. Mandatory field.
       Identifies the transaction. The QMI_LOC_SECURE_GET_AVAILABLE_POSITION_IND
       indication returns the transaction ID. \n
       - Parameter type -- uint32 \n
   */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_PARAM_NONCE_V02 = 2, /**<  Parameter ID for the Nonce field. Optional field. \n
       - Parameter type -- uint64 \n
   */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_PARAM_SOURCE_V02 = 3, /**<  Parameter ID for the Position Source field. Optional field.
       Specifies the source of the position in which the control point is interest.
       If not included, the value defaults to GNSS.        \n
       - Parameter type -- int32 \n
       Parameter values: \n
       - eQMI_LOC_POS_SRC_GNSS (1) --  Source of the position is GNSS \n
   */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_PARAM_REPORT_DATA_SECURITY_MODE_V02 = 4, /**<  Secured position report data security mode. Optional field.
       If this TLV is not sent, the position report is encrypted by default. \n
       - Parameter type -- int32 \n
       Parameter values: \n
       - eQMI_LOC_SECURE_LOC_DATA_ENCRYPTED (1)   --  Position reports are encrypted \n
       - eQMI_LOC_SECURE_LOC_DATA_UNENCRYPTED (2) --  Position reports are not encrypted \n
    */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_PARAM_REPORT_DATA_TIME_PROPAGATION_V02 = 5, /**<  Secured position report data propagation.  Optional field.
       If this TLV is not sent, the position report is propagated to the current UTC time by default. \n
       - Parameter type -- int32 \n
       Parameter values: \n
       - eQMI_LOC_POS_REPORT_PROPAGATED_TO_CURRENT_UTC (1) -- Position reports are propagated to the current UTC. \n
    */
  QMILOCSECUREGETAVAILABLEPOSPARAMETERIDENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSecureGetAvailablePosParameterIDEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSECUREMESSAGEDATATYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SECURE_DATA_TYPE_BYTE_8_V02 = 1, /**<  Data type -- Byte (8 bits) \n  */
  eQMI_LOC_SECURE_DATA_TYPE_CHAR_8_V02 = 2, /**<  Data type -- Char (8 bits) \n  */
  eQMI_LOC_SECURE_DATA_TYPE_UNSIGNED_CHAR_8_V02 = 3, /**<  Data type -- Unsigned char (8 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_INT_8_V02 = 4, /**<  Data type -- Int (8 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_UNSIGNED_INT_8_V02 = 5, /**<  Data type -- Unsigned int (8 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_INT_16_V02 = 6, /**<  Data type -- Int (16 bits) \n  */
  eQMI_LOC_SECURE_DATA_TYPE_UNSIGNED_INT_16_V02 = 7, /**<  Data type -- Unsigned int (16 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_INT_32_V02 = 8, /**<  Data type -- Int (32 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_UNSIGNED_INT_32_V02 = 9, /**<  Data type -- Unsigned int (32 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_INT_64_V02 = 10, /**<  Data type -- Int (64 bits) \n  */
  eQMI_LOC_SECURE_DATA_TYPE_UNSIGNED_INT_64_V02 = 11, /**<  Data type -- Unsigned int (64 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_BOOL_8_V02 = 12, /**<  Data type -- Boolean (8 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_DOUBLE_64_V02 = 13, /**<  Data type -- Double (64 bits) \n */
  eQMI_LOC_SECURE_DATA_TYPE_FLOAT_32_V02 = 14, /**<  Data type -- Float (32 bits)  */
  QMILOCSECUREMESSAGEDATATYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSecureMessageDataTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to get the available
                    position estimate from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Data Security Mode for Encoded Data Buffer */
  qmiLocSecureLocDataModeEnumT_v02 secureLocDataMode;
  /**<   Data security mode for the encoded data buffer.
 Values: \n
      - eQMI_LOC_SECURE_LOC_DATA_ENCRYPTED (1) --  Encrypt data in the indication \n
      - eQMI_LOC_SECURE_LOC_DATA_UNENCRYPTED (2) --  Unencrypt data in the indication
 */

  /* Mandatory */
  /*  Encoded Data Buffer Containing Secure Get Available Position Request Parameters */
  uint32_t qmilocSecureGetAvailablePositionRequestData_len;  /**< Must be set to # of elements in qmilocSecureGetAvailablePositionRequestData */
  uint8_t qmilocSecureGetAvailablePositionRequestData[QMI_LOC_SECURE_GET_AVAILABLE_POS_REQUEST_ENCRYPTED_MAX_V02];
  /**<   Encoded data buffer containing the secure Get Available Position Request parameters. */
}qmiLocSecureGetAvailablePositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSECUREGETAVAILABLEPOSITIONINDPARAMIDENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TRANSACTION_ID_V02 = 1, /**<  Parameter ID for the Transaction ID field; mandatory field.
             Transaction ID specified in the QMI_LOC_SECURE_GET_AVAILABLE_POSITION_REQ request.
             This parameter is present when the status field is set to SUCCESS. \n
             - Parameter type -- uint32
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_NONCE_V02 = 2, /**<  Parameter ID for the secure session nonce; echos back the nonce received from
             the QMI_LOC_SECURE_GET_AVAILABLE_POSITION_REQ request; optional field. \n
             - Parameter type -- uint64
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_LATITUDE_V02 = 3, /**<   Parameter ID for latitude (specified in WGS84 datum); optional field.\n
             - Parameter type -- Floating point\n
             - Parameter units -- Degrees\n
             - Parameter range -- -90.0 to 90.0    \n
                - Positive values indicate northern latitude\n
                - Negative values indicate southern latitude
          */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_LONGITUDE_V02 = 4, /**<   Parameter ID for longitude (specified in WGS84 datum); optional field. \n
              - Parameter type -- Floating point \n
              - Parameter units -- Degrees \n
              - Parameter range -- -180.0 to 180.0     \n
                - Positive values indicate eastern longitude \n
                - Negative values indicate western longitude
           */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_UNC_CIRCULAR_V02 = 5, /**<   Parameter ID for circular horizontal uncertainty; optional field. \n
              - Parameter tnits -- Meters \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_ALTITUDE_WRT_ELP_V02 = 6, /**<   Parameter ID for altitude with respect to the WGS84 ellipsoid; optional field. \n
              - Parameter units -- Meters \n
              - Parameter range -- -500 to 15883 \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_VERTICAL_UNC_V02 = 7, /**<   Parameter ID for vertical uncertainty; optional field.\n
              - Parameter units -- Meters \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TIME_STAMP_UTC_V02 = 8, /**<   Parameter ID for the UTC timestamp; optional field.\n
              - Parameter type -- uint64 \n
              - Parameter units -- Milliseconds since Jan. 1, 1970
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TIME_UNC_V02 = 9, /**<   Parameter ID for time uncertainty; optional field.\n
              - Parameter type -- Float \n
              - Parameter units -- Milliseconds  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_UNC_ELP_SEMIMINOR_V02 = 10, /**<   Parameter ID for the semi-minor axis of horizontal elliptical uncertainty; optional field.\n
              - Parameter mnits -- Meters \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_UNC_ELP_SEMIMAJOR_V02 = 11, /**<   Parameter ID for the semi-major axis of horizontal elliptical uncertainty; optional field.\n
              - Parameter units -- Meters \n
              - Parameter type -- Float */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_UNC_ELP_ORIENT_AZIMUTH_V02 = 12, /**<   Parameter ID for the elliptical horizontal uncertainty azimuth of orientation; optional field. \n
              - Parameter units -- Decimal degrees \n
              - Parameter range -- 0 to 180 \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_CONFIDENCE_V02 = 13, /**<   Parameter ID for Horizontal uncertainty confidence; optional field.\n
              If both elliptical and horizontal uncertainties are specified in this message,
              the confidence corresponds to the elliptical uncertainty. \n
              - Parameter units -- Percent \n
              - Parameter range -- 0 to 99 \n
              - Parameter type -- uint8  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_ELLIP_CONFIDENCE_V02 = 14, /**<   Parameter ID for Horizontal Elliptical Uncertainty Confidence; optional field.
              If both elliptical and horizontal uncertainties are specified in this message,
              the confidence corresponds to the elliptical uncertainty.\n
             - Parameter units -- Percent \n
             - Parameter range -- 0 to 99 \n
             - Parameter type -- uint8  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HORIZ_RELIABILITY_V02 = 15, /**<   Parameter ID specifying the reliability of the horizontal position; optional field.\n
             - Parameter type -- int32 \n
             Parameter values: \n
             - RELIABILITY_NOT_SET   = 0 \n
             - RELIABILITY_VERY_LOW  = 1 \n
             - RELIABILITY_LOW       = 2 \n
             - RELIABILITY_MEDIUM    = 3 \n
             - RELIABILITY_HIGH      = 4
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_SPEED_HORIZ_V02 = 16, /**<   Parameter ID for horizontal speed; optional field.\n
              - Parameter units -- Meters per second \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_SPEED_HORIZ_UNC_V02 = 17, /**<   Parameter ID for horizontal speed uncertainty; optional field.\n
              - Parameter units -- Meters per second \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_ALTITUDE_WRT_MSA_V02 = 18, /**<   Parameter ID for altitude with respect to mean sea level; optional field.\n
              - Parameter units -- Meters \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_VERTICAL_CONF_V02 = 19, /**<   Parameter ID for vertical uncertainty confidence; optional field.\n
              - Parameter units -- Percent \n
              - Parameter range -- 0 to 99 \n
              - Parameter type -- uint8 */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_VERT_RELIABILITY_V02 = 20, /**<   Parameter ID for specifies the reliability of the vertical position; optional field.
              - Parameter type -- int32 \n
              Parameter values: \n
              - RELIABILITY_NOT_SET   = 0 \n
              - RELIABILITY_VERY_LOW  = 1 \n
              - RELIABILITY_LOW       = 2 \n
              - RELIABILITY_MEDIUM    = 3 \n
              - RELIABILITY_HIGH      = 4
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_SPEED_VERTICAL_V02 = 21, /**<   Parameter ID for vertical speed; optional field. \n
              - Parameter units -- Meters per second \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_SPEED_VERTICAL_UNC_V02 = 22, /**<   Parameter ID for vertical speed uncertainty; optional field.\n
              - Parameter units -- Meters per second \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HEADING_V02 = 23, /**<   Parameter ID for heading; optional field. \n
              - Parameter units -- Degrees \n
              - Parameter range -- 0 to 359.999 \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HEADING_UNC_V02 = 24, /**<   Parameter ID for heading uncertaint; optional field.\n
              - Parameter units -- Degrees \n
              - Parameter range -- 0 to 359.999  \n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_MAGNETIC_DEVIATION_V02 = 25, /**<   Parameter ID for magnetic deviation. Optional field.
              Difference between the bearing to true north and the bearing shown
              a magnetic compass. The deviation is positive when the magnetic
              north is east of true north.\n
              - Parameter type -- Float  */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TECH_MASK_V02 = 26, /**<  Parameter ID for technology Used in computing this fix. Optional field.\n
             - Parameter type -- uint32        \n
            Parameter bitmasks: \n
            - QMI_LOC_POS_TECH_MASK_SATELLITE                = 0x00000001,\n
            - QMI_LOC_POS_TECH_MASK_CELLID                   = 0x00000002,\n
            - QMI_LOC_POS_TECH_MASK_WIFI                     = 0x00000004,\n
            - QMI_LOC_POS_TECH_MASK_SENSORS                  = 0x00000008,\n
            - QMI_LOC_POS_TECH_MASK_REFERENCE_LOCATION       = 0x00000010,\n
            - QMI_LOC_POS_TECH_MASK_INJECTED_COARSE_POSITION = 0x00000020,\n
            - QMI_LOC_POS_TECH_MASK_AFLT                     = 0x00000040,\n
            - QMI_LOC_POS_TECH_MASK_HYBRID                   = 0x00000080
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_PDOP_V02 = 27, /**<  Parameter ID for position dilution of precision associated with this position. Optional field.\n
             - Parameter type -- Float \n
             - Parameter range -- 0 (highest accuracy) to 50 (lowest accuracy) \n
             - PDOP = square root of (HDOP^2 + VDOP^2)
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_HDOP_V02 = 28, /**<  Parameter ID for Horizontal Dilution of Precision associated with this position; optional field.\n
           - Parameter type -- Float \n
           - Parameter range -- 0 (highest accuracy) to 50 (lowest accuracy)
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_VDOP_V02 = 29, /**<  Parameter ID for vertical dilution of precision associated with this position; optional field.\n
             - Parameter type -- Float \n
             - Parameter range -- 0 (highest accuracy) to 50 (lowest accuracy)
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_GPS_WEEK_V02 = 30, /**<  Parameter ID for the current GPS Week, as calculated from midnight, Jan. 6, 1980; optional field.\n
             - Parameter type -- uint16 \n
             - Parameter units -- Weeks
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_GPS_TIMEOFWEEKMS_V02 = 31, /**<  Parameter ID for amount of time into the current GPS Week; optional field.\n
             - Parameter type -- uint32 \n
             - Parameter units -- Milliseconds
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TIME_SRC_V02 = 32, /**<  Parameter ID for time source. Optional field.\n
             - Parameter type -- uint32 (enum qmiLocTimeSourceEnumT)
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_SENSOR_USAGE_MASK_V02 = 33, /**<  Parameter ID that specifies which sensors were used in calculating the position in the
             position report. Optional field.\n
            - Parameter type -- uint32 \n
            Parameter bitmasks: \n
            - 0x00000001 -- SENSOR_USED_ACCEL \n
            - 0x00000002 -- SENSOR_USED_GYRO
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_AIDING_IND_MASK_V02 = 34, /**<  Parameter ID that specifies which results were aided by sensors. Optional field.\n
             - Parameter type -- uint32 \n
             Parameter bitmasks: \n
             - 0x00000001 -- AIDED_HEADING \n
             - 0x00000002 -- AIDED_SPEED \n
             - 0x00000004 -- AIDED_POSITION \n
             - 0x00000008 -- AIDED_VELOCITY
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_SV_USED_V02 = 35, /**<  Each entry in the list contains the SV ID of a satellite
             used for calculating this position report. The following
             information is associated with each SV ID; optional field. \n
             - Parameter type -- uint16   \n
             Parameter range: \n
             - GPS --     1 to 32  \n
             - SBAS --    33 to 64 \n
             - GLONASS -- 65 to 96 \n
             - QZSS --    193 to 197 \n
             - BDS --     201 to 263
     */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_TDOP_V02 = 36, /**<  Parameter ID for time dilution of precision associated with this position; optional field.\n
           - Parameter type -- Float \n
           - Parameter range -- 0 (highest accuracy) to 50 (lowest accuracy)
         */
  eQMI_LOC_SECURE_GET_AVAILABLE_POS_REP_PARAM_GDOP_V02 = 37, /**<  Parameter ID for geometrical dilution of precision associated with this position; optional field.\n
             - Parameter type -- Float \n
             - Parameter range -- 0 (highest accuracy) to 50 (lowest accuracy)
         */
  QMILOCSECUREGETAVAILABLEPOSITIONINDPARAMIDENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSecureGetAvailablePositionIndParamIDEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to get the available
                    position estimate from the location engine. */
typedef struct {

  /* Mandatory */
  /*  Session Status */
  qmiLocSessionStatusEnumT_v02 sessionStatus;
  /**<   Session status.
 Values: \n
      - eQMI_LOC_SESS_STATUS_SUCCESS (0) --  Session was successful \n
      - eQMI_LOC_SESS_STATUS_IN_PROGRESS (1) --  Session is still in progress; further position reports are generated
       until either the fix criteria specified by the client are met or the
       client response timeout occurs \n
      - eQMI_LOC_SESS_STATUS_GENERAL_FAILURE (2) --  Session failed \n
      - eQMI_LOC_SESS_STATUS_TIMEOUT (3) --  Fix request failed because the session timed out \n
      - eQMI_LOC_SESS_STATUS_USER_END (4) --  Fix request failed because the session was ended by the user \n
      - eQMI_LOC_SESS_STATUS_BAD_PARAMETER (5) --  Fix request failed due to bad parameters in the request \n
      - eQMI_LOC_SESS_STATUS_PHONE_OFFLINE (6) --  Fix request failed because the phone is offline \n
      - eQMI_LOC_SESS_STATUS_ENGINE_LOCKED (7) --  Fix request failed because the engine is locked
 */

  /* Mandatory */
  /*  Data Security Mode for Encoded Data Buffer. */
  qmiLocSecureLocDataModeEnumT_v02 secureLocDataMode;
  /**<   Data security mode for encoded data buffer.
 Values: \n
      - eQMI_LOC_SECURE_LOC_DATA_ENCRYPTED (1) --  Encrypt data in the indication \n
      - eQMI_LOC_SECURE_LOC_DATA_UNENCRYPTED (2) --  Unencrypt data in the indication
 */

  /* Optional */
  /*  Encoded Data Buffer Containing Secured Get Available Position Report Indication  */
  uint8_t qmilocSecureGetAvailablePositionInd_valid;  /**< Must be set to true if qmilocSecureGetAvailablePositionInd is being passed */
  uint32_t qmilocSecureGetAvailablePositionInd_len;  /**< Must be set to # of elements in qmilocSecureGetAvailablePositionInd */
  uint8_t qmilocSecureGetAvailablePositionInd[QMI_LOC_SECURE_GET_AVAILABLE_POSITION_IND_ENCRYPTED_MAX_V02];
  /**<   Encoded data buffer containing the QMI_LOC_SECURE_GET_AVAILABLE_POSITION_IND indication.*/
}qmiLocSecureGetAvailablePositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCAPRELIABILITYENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_AP_RELIABILITY_NOT_SET_V02 = 0, /**<  AP location reliability is not set \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_1_V02 = 1, /**<  AP location reliability level 1 \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_2_V02 = 2, /**<  AP location reliability level 2 \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_3_V02 = 3, /**<  AP location reliability level 3 \n  */
  eQMI_LOC_AP_RELIABILITY_LEVEL_4_V02 = 4, /**<  AP location reliability level 4 \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_5_V02 = 5, /**<  AP location reliability level 5 \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_6_V02 = 6, /**<  AP location reliability level 6 \n */
  eQMI_LOC_AP_RELIABILITY_LEVEL_7_V02 = 7, /**<  AP location reliability level 7  */
  QMILOCAPRELIABILITYENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocApReliabilityEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint64_t macAddress;
  /**<   AP MAC address. */

  float xLat;
  /**<   AP latitude. \n
       - Units -- degrees */

  float yLon;
  /**<   AP longitude sensor y-axis sample. \n
       - Units -- degrees */

  float mar;
  /**<   Maximum antenna range. \n
       - Units -- Meters */
}qmiLocApCacheStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t hepeValid;
  /**<   Indicates whether HEPE data is available. Values: \n
       - 0x00 (FALSE) -- Ignore the HEPE data of this AP \n
       - 0x01 (TRUE) -- HEPE data of this AP is available */

  uint16_t hepe;
  /**<   Horizontal estimated position error. \n
       - Units -- Meters */

  qmiLocApReliabilityEnumT_v02 apReliability;
  /**<   Specifies the reliability of the AP position.
 The lowest is eQMI_LOC_AP_RELIABILITY_LEVEL_1 and the highest is eQMI_LOC_AP_RELIABILITY_LEVEL_7.
 The AP reliability increases as the level increases.
 Values: \n
      - eQMI_LOC_AP_RELIABILITY_NOT_SET (0) --  AP location reliability is not set \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_1 (1) --  AP location reliability level 1 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_2 (2) --  AP location reliability level 2 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_3 (3) --  AP location reliability level 3 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_4 (4) --  AP location reliability level 4 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_5 (5) --  AP location reliability level 5 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_6 (6) --  AP location reliability level 6 \n
      - eQMI_LOC_AP_RELIABILITY_LEVEL_7 (7) --  AP location reliability level 7
 */
}qmiLocApCacheHepeRelStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject APs into the cache of
                    the low power Wi-Fi engine for fix computation. */
typedef struct {

  /* Mandatory */
  /*  Version Number */
  uint8_t versionNumber;
  /**<   AP cache protocol version number. */

  /* Mandatory */
  /*  Part Number */
  uint8_t partNumber;
  /**<   Multiple message part number; used for ordering AP information. */

  /* Mandatory */
  /*  Total Parts */
  uint8_t totalParts;
  /**<   Total number of parts or messages for a complete cache update. */

  /* Mandatory */
  /*  AP Cache Data */
  uint32_t apCacheData_len;  /**< Must be set to # of elements in apCacheData */
  qmiLocApCacheStructT_v02 apCacheData[QMI_LOC_APCACHE_DATA_MAX_SAMPLES_V02];
  /**<   \vspace{4pt} \n AP cache information. */

  /* Optional */
  /*  AP Cache HEPE Data */
  uint8_t apCacheHepeRelData_valid;  /**< Must be set to true if apCacheHepeRelData is being passed */
  uint32_t apCacheHepeRelData_len;  /**< Must be set to # of elements in apCacheHepeRelData */
  qmiLocApCacheHepeRelStructT_v02 apCacheHepeRelData[QMI_LOC_APCACHE_DATA_MAX_SAMPLES_V02];
  /**<   \vspace{4pt} \n
       The ordering of the apCacheHepeRelData list must match the apCacheData list.
       That is, the first element of the apCacheHepeRelData must be the cache HEPE data of the AP
       whose cache data is the first element in the apCacheData, and so on. */
}qmiLocInjectApCacheDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject APs into the cache of
                    the low power Wi-Fi engine for fix computation. */
typedef struct {

  /* Mandatory */
  /*  Set Inject APCACHE Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject AP Cache Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  AP Cache Size */
  uint8_t apCacheSize_valid;  /**< Must be set to true if apCacheSize is being passed */
  uint32_t apCacheSize;
  /**<   Key performance indicator (KPI) for apCacheSize that measures the size
       of the last AP cache used. This parameter is always present. */

  /* Optional */
  /*  AP Do Not Cache Size */
  uint8_t apDoNotCacheSize_valid;  /**< Must be set to true if apDoNotCacheSize is being passed */
  uint32_t apDoNotCacheSize;
  /**<   KPI for apDoNotCacheSize that measures the size of the last AP cache used.
       This parameter is always present. */

  /* Optional */
  /*  AP Cache Hits */
  uint8_t apCacheHits_valid;  /**< Must be set to true if apCacheHits is being passed */
  uint32_t apCacheHits;
  /**<   KPI for apCacheHits that measures the number of hits to the
       AP cache of the last cache content. */

  /* Optional */
  /*  AP Do Not Cache Hits */
  uint8_t apDoNotCacheHits_valid;  /**< Must be set to true if apDoNotCacheHits is being passed */
  uint32_t apDoNotCacheHits;
  /**<   KPI for apDoNotCacheHits that measures the number of hits to
       apDoNotCache of the last cache content. */

  /* Optional */
  /*  Unknown APs */
  uint8_t unknownAps_valid;  /**< Must be set to true if unknownAps is being passed */
  uint32_t unknownAps;
  /**<   KPI for unknownAps that measures the number of unknown APs, those that are
       not found in any cache content. */

  /* Optional */
  /*  Async Scans */
  uint8_t asyncScans_valid;  /**< Must be set to true if asyncScans is being passed */
  uint32_t asyncScans;
  /**<   KPI for asyncScans that measures the number of async scans
       perceived since the last modem boot. */

  /* Optional */
  /*  Async Fixes */
  uint8_t asyncFixes_valid;  /**< Must be set to true if asyncFixes is being passed */
  uint32_t asyncFixes;
  /**<   KPI for asyncFixes that measures the number of async fixes
       generated since the last modem boot. */

  /* Optional */
  /*  Sync Scans */
  uint8_t syncScans_valid;  /**< Must be set to true if syncScans is being passed */
  uint32_t syncScans;
  /**<   KPI for syncScans that measures the number of sync scans
       perceived since the last modem boot. */

  /* Optional */
  /*  Sync Fixes */
  uint8_t syncFixes_valid;  /**< Must be set to true if syncFixes is being passed */
  uint32_t syncFixes;
  /**<   KPI for asyncFixes that measures the number of sync fixes
       generated since the last modem boot. */
}qmiLocInjectApCacheDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint64_t macAddress;
  /**<   AP's MAC address. */
}qmiLocApDoNotCacheStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject blacked out APs into
                    the low power location engine. */
typedef struct {

  /* Mandatory */
  /*  Version Number */
  uint8_t versionNumber;
  /**<   AP cache protocol version number. */

  /* Mandatory */
  /*  Part Number */
  uint8_t partNumber;
  /**<   Multiple message part number, used to order AP information. */

  /* Mandatory */
  /*  Total Parts */
  uint8_t totalParts;
  /**<   Total number of parts or messages for a complete cache update. */

  /* Mandatory */
  /*  No AP Cache Data */
  uint32_t apDoNotCacheData_len;  /**< Must be set to # of elements in apDoNotCacheData */
  qmiLocApDoNotCacheStructT_v02 apDoNotCacheData[QMI_LOC_APCACHE_DATA_MAX_SAMPLES_V02];
  /**<   \n APDoNotCache information. */
}qmiLocInjectApDoNotCacheDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject blacked out APs into
                    the low power location engine. */
typedef struct {

  /* Mandatory */
  /*  Set Inject APDONOTCACHE Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject APDONOTCACHE Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectApDoNotCacheDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCBATCHINGSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_BATCH_POS_UNAVAILABLE_V02 = 1, /**<  Service is unable to compute the positions for batching \n */
  eQMI_LOC_BATCH_POS_AVAILABLE_V02 = 2, /**<  Service is able to compute the positions for batching  */
  QMILOCBATCHINGSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocBatchingStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the control point of the
                    batching status. */
typedef struct {

  /* Mandatory */
  /*  Batching Status */
  qmiLocBatchingStatusEnumT_v02 batchingStatus;
  /**<   Specifies the batching status.
 Values: \n
      - eQMI_LOC_BATCH_POS_UNAVAILABLE (1) --  Service is unable to compute the positions for batching \n
      - eQMI_LOC_BATCH_POS_AVAILABLE (2) --  Service is able to compute the positions for batching
 */
}qmiLocEventBatchingStatusIndMsgT_v02;  /* Message */
/**
    @}
  */

/**  Identifies the always-on service capabilities.  */
typedef uint32_t qmiLocAonCapabilityMaskT_v02;
#define QMI_LOC_MASK_AON_AUTO_BATCHING_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000001) /**<  The service supports auto batching; the client can enable auto
       batching by setting the distance parameter to 0 in the START_BATCHING request  */
#define QMI_LOC_MASK_AON_DISTANCE_BASED_BATCHING_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000002) /**<  The service supports distance-based batching  */
#define QMI_LOC_MASK_AON_TIME_BASED_BATCHING_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000004) /**<  The service supports time-based batching */
#define QMI_LOC_MASK_AON_DISTANCE_BASED_TRACKING_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000008) /**<  The service supports distance-based tracking  */
#define QMI_LOC_MASK_AON_UPDATE_TBF_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000010) /**<  The service supports changing TBF dynamically  */
#define QMI_LOC_MASK_AON_OUTDOOR_TRIP_BATCHING_SUPPORTED_V02 ((qmiLocAonCapabilityMaskT_v02)0x00000020) /**<  The service supports outdoor trip batching  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the clients to get always-on (AON) service settings.
                      */
typedef struct {

  /* Mandatory */
  /*  Transaction ID */
  uint32_t transactionId;
  /**<   Identifies the transaction. The same transaction ID
       is returned in the QUERY_AON_CONFIG indication. */
}qmiLocQueryAonConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the clients to get always-on (AON) service settings.
                      */
typedef struct {

  /* Mandatory */
  /*  Always-On Config Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the QMI_LOC_QUERY_AON_CONFIG_REQ request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Transaction ID */
  uint8_t transactionId_valid;  /**< Must be set to true if transactionId is being passed */
  uint32_t transactionId;
  /**<   Identifies the transaction. It is the same transaction
       ID that was passed in the QUERY_AON_CONFIG request. */

  /* Optional */
  /*  Always-On Capability  */
  uint8_t aonCapability_valid;  /**< Must be set to true if aonCapability is being passed */
  qmiLocAonCapabilityMaskT_v02 aonCapability;
  /**<   Always-on capabilities supported by the service. \n
 Values: \n
      - QMI_LOC_MASK_AON_AUTO_BATCHING_SUPPORTED (0x00000001) --  The service supports auto batching; the client can enable auto
       batching by setting the distance parameter to 0 in the START_BATCHING request
      - QMI_LOC_MASK_AON_DISTANCE_BASED_BATCHING_SUPPORTED (0x00000002) --  The service supports distance-based batching
      - QMI_LOC_MASK_AON_TIME_BASED_BATCHING_SUPPORTED (0x00000004) --  The service supports time-based batching
      - QMI_LOC_MASK_AON_DISTANCE_BASED_TRACKING_SUPPORTED (0x00000008) --  The service supports distance-based tracking
      - QMI_LOC_MASK_AON_UPDATE_TBF_SUPPORTED (0x00000010) --  The service supports changing TBF dynamically
      - QMI_LOC_MASK_AON_OUTDOOR_TRIP_BATCHING_SUPPORTED (0x00000020) --  The service supports outdoor trip batching */
}qmiLocQueryAonConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocDeleteCommonDataMaskT_v02;
#define QMI_LOC_DELETE_COMMON_MASK_POS_V02 ((qmiLocDeleteCommonDataMaskT_v02)0x00000001) /**<  Position estimate; common for all GNSS types  */
#define QMI_LOC_DELETE_COMMON_MASK_TIME_V02 ((qmiLocDeleteCommonDataMaskT_v02)0x00000002) /**<  Reset all CLOCK_INFO mask  */
#define QMI_LOC_DELETE_COMMON_MASK_UTC_V02 ((qmiLocDeleteCommonDataMaskT_v02)0x00000004) /**<  UTC estimate  */
#define QMI_LOC_DELETE_COMMON_MASK_RTI_V02 ((qmiLocDeleteCommonDataMaskT_v02)0x00000008) /**<  RTI  */
#define QMI_LOC_DELETE_COMMON_MASK_FREQ_BIAS_EST_V02 ((qmiLocDeleteCommonDataMaskT_v02)0x00000010) /**<  Frequency bias estimate; common for all GNSS types  */
typedef uint32_t qmiLocDeleteSatelliteDataMaskT_v02;
#define QMI_LOC_DELETE_DATA_MASK_EPHEMERIS_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000001) /**<  Ephemeris \n */
#define QMI_LOC_DELETE_DATA_MASK_ALMANAC_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000002) /**<  Almanac \n */
#define QMI_LOC_DELETE_DATA_MASK_SVHEALTH_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000004) /**<  SV health \n */
#define QMI_LOC_DELETE_DATA_MASK_SVDIR_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000008) /**<  SV direction \n  */
#define QMI_LOC_DELETE_DATA_MASK_SVSTEER_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000010) /**<  SV steer \n */
#define QMI_LOC_DELETE_DATA_MASK_ALM_CORR_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000020) /**<  Almanac correction \n */
#define QMI_LOC_DELETE_DATA_MASK_BLACKLIST_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000040) /**<  Blacklist SVs \n */
#define QMI_LOC_DELETE_DATA_MASK_SA_DATA_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000080) /**<  Sensitivity assistance data \n */
#define QMI_LOC_DELETE_DATA_MASK_SV_NO_EXIST_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000100) /**<  SV does not exist \n */
#define QMI_LOC_DELETE_DATA_MASK_IONO_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000200) /**<  Ionosphere correction \n */
#define QMI_LOC_DELETE_DATA_MASK_TIME_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000400) /**<  Reset satellite time \n  */
#define QMI_LOC_DELETE_DATA_MASK_MB_DATA_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00000800) /**<  Delete multiband data \n */
#define QMI_LOC_DELETE_DATA_MASK_TGD_DATA_V02 ((qmiLocDeleteSatelliteDataMaskT_v02)0x00001000) /**<  Reset TGD (group delay) data  */
typedef uint32_t qmiLocGNSSConstellMaskT_v02;
#define QMI_LOC_SYSTEM_GPS_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000001) /**<  System GPS data \n */
#define QMI_LOC_SYSTEM_GLO_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000002) /**<  System GLONASS data \n  */
#define QMI_LOC_SYSTEM_BDS_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000004) /**<  System BDS data \n */
#define QMI_LOC_SYSTEM_GAL_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000008) /**<  System Galileo data \n */
#define QMI_LOC_SYSTEM_QZSS_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000010) /**<  System QZSS data \n */
#define QMI_LOC_SYSTEM_NAVIC_V02 ((qmiLocGNSSConstellMaskT_v02)0x00000020) /**<  System NavIC data  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocGNSSConstellMaskT_v02 system;
  /**<   Indicates which satellite system's data is to delete.
 The control point can delete multiple systems at a time.
 Values: \n
      - QMI_LOC_SYSTEM_GPS (0x00000001) --  System GPS data \n
      - QMI_LOC_SYSTEM_GLO (0x00000002) --  System GLONASS data \n
      - QMI_LOC_SYSTEM_BDS (0x00000004) --  System BDS data \n
      - QMI_LOC_SYSTEM_GAL (0x00000008) --  System Galileo data \n
      - QMI_LOC_SYSTEM_QZSS (0x00000010) --  System QZSS data \n
      - QMI_LOC_SYSTEM_NAVIC (0x00000020) --  System NavIC data
 */

  qmiLocDeleteSatelliteDataMaskT_v02 deleteSatelliteDataMask;
  /**<   Requested bitmask of data to delete for the specified satellite system. \n
 Values: \n
      - QMI_LOC_DELETE_DATA_MASK_EPHEMERIS (0x00000001) --  Ephemeris \n
      - QMI_LOC_DELETE_DATA_MASK_ALMANAC (0x00000002) --  Almanac \n
      - QMI_LOC_DELETE_DATA_MASK_SVHEALTH (0x00000004) --  SV health \n
      - QMI_LOC_DELETE_DATA_MASK_SVDIR (0x00000008) --  SV direction \n
      - QMI_LOC_DELETE_DATA_MASK_SVSTEER (0x00000010) --  SV steer \n
      - QMI_LOC_DELETE_DATA_MASK_ALM_CORR (0x00000020) --  Almanac correction \n
      - QMI_LOC_DELETE_DATA_MASK_BLACKLIST (0x00000040) --  Blacklist SVs \n
      - QMI_LOC_DELETE_DATA_MASK_SA_DATA (0x00000080) --  Sensitivity assistance data \n
      - QMI_LOC_DELETE_DATA_MASK_SV_NO_EXIST (0x00000100) --  SV does not exist \n
      - QMI_LOC_DELETE_DATA_MASK_IONO (0x00000200) --  Ionosphere correction \n
      - QMI_LOC_DELETE_DATA_MASK_TIME (0x00000400) --  Reset satellite time \n
      - QMI_LOC_DELETE_DATA_MASK_MB_DATA (0x00000800) --  Delete multiband data \n
      - QMI_LOC_DELETE_DATA_MASK_TGD_DATA (0x00001000) --  Reset TGD (group delay) data
 */
}qmiLocDeleteSatelliteDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Deletes the location engine
                    service data from memory. */
typedef struct {

  /* Mandatory */
  /*  Reset All */
  uint8_t deleteAllFlag;
  /**<   Indicates whether to delete all GNSS service data.\n
       Values: \n
       - OxO1 (TRUE)  -- Reset all constellation service data;
                    when this flag is set, ignore all the other information
                    contained in the optional fields for this
                    message  \n
       - 0x00 (FALSE) -- Use the optional fields in the message
                         to determine which data to delete
  */

  /* Optional */
  /*  Requested Bitmask of Clock Info Data to Delete */
  uint8_t deleteClockInfoMask_valid;  /**< Must be set to true if deleteClockInfoMask is being passed */
  qmiLocDeleteClockInfoMaskT_v02 deleteClockInfoMask;
  /**<   Mask for the clock information service data to delete.
 If QMI_LOC_DELETE_DATA_MASK_TIME is set in deleteServiceDataMask,
 deleteClockInfoMask is ignored.
 Values: \n
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_EST (0x00000001) --  Delete time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_FREQ_EST (0x00000002) --  Delete frequency estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_WEEK_NUMBER (0x00000004) --  Delete week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_RTC_TIME (0x00000008) --  Delete RTC time
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_TIME_TRANSFER (0x00000010) --  Delete time transfer
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GPSTIME_EST (0x00000020) --  Delete GPS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLOTIME_EST (0x00000040) --  Delete GLONASS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLODAY_NUMBER (0x00000080) --  Delete GLONASS day number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO4YEAR_NUMBER (0x00000100) --  Delete GLONASS four year number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GLO_RF_GRP_DELAY (0x00000200) --  Delete GLONASS RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_DISABLE_TT (0x00000400) --  Delete disable TT
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_LEAPSEC (0x00000800) --  Delete GG leap second
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GG_GGTB (0x00001000) --  Delete GG GGTB
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSTIME_EST (0x00002000) --  Delete a BDS time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GB_GBTB (0x00004000) --  Delete GLONASS-to-BDS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BG_BGTB (0x00008000) --  Delete BDS-to-GLONASS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDSWEEK_NUMBER (0x00010000) --  Delete the BDS week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_BDS_RF_GRP_DELAY (0x00020000) --  Delete the BDS RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTIME_EST (0x00040000) --  Delete a Galileo time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGPS_TB (0x00080000) --  Delete Galileo-to-GPS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOGLO_TB (0x00100000) --  Delete Galileo-to-GLO time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALTOBDS_TB (0x00200000) --  Delete Galileo-to-BDS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GALWEEK_NUMBER (0x00800000) --  Delete the Galileo week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_GAL_RF_GRP_DELAY (0x01000000) --  Delete the Galileo RF GRP delay
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TIME_EST (0x02000000) --  Delete a NavIC time estimate
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_WEEK_NUMBER (0x04000000) --  Delete the NavIC week number
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_RF_GRP_DELAY (0x08000000) --  Delete the NavIC RF GRP delay
 */

  /* Optional */
  /*  Requested Bitmask of Cell DB Data to Delete */
  uint8_t deleteCellDbDataMask_valid;  /**< Must be set to true if deleteCellDbDataMask is being passed */
  qmiLocDeleteCelldbDataMaskT_v02 deleteCellDbDataMask;
  /**<   Mask for the cell database service data to delete;
 common for all GNSS types.
 Values: \n
      - QMI_LOC_MASK_DELETE_CELLDB_POS (0x00000001) --  Delete cell database position
      - QMI_LOC_MASK_DELETE_CELLDB_LATEST_GPS_POS (0x00000002) --  Delete cell database latest GPS position
      - QMI_LOC_MASK_DELETE_CELLDB_OTA_POS (0x00000004) --  Delete cell database OTA position
      - QMI_LOC_MASK_DELETE_CELLDB_EXT_REF_POS (0x00000008) --  Delete cell database external reference position
      - QMI_LOC_MASK_DELETE_CELLDB_TIMETAG (0x00000010) --  Delete cell database time tag
      - QMI_LOC_MASK_DELETE_CELLDB_CELLID (0x00000020) --  Delete cell database cell ID
      - QMI_LOC_MASK_DELETE_CELLDB_CACHED_CELLID (0x00000040) --  Delete cell database cached cell ID
      - QMI_LOC_MASK_DELETE_CELLDB_LAST_SRV_CELL (0x00000080) --  Delete cell database last service cell
      - QMI_LOC_MASK_DELETE_CELLDB_CUR_SRV_CELL (0x00000100) --  Delete cell database current service cell
      - QMI_LOC_MASK_DELETE_CELLDB_NEIGHBOR_INFO (0x00000200) --  Delete cell database neighbor information
 */

  /* Optional */
  /*  Requested Bitmask of Common Data to Delete */
  uint8_t deleteCommonDataMask_valid;  /**< Must be set to true if deleteCommonDataMask is being passed */
  qmiLocDeleteCommonDataMaskT_v02 deleteCommonDataMask;
  /**<   Mask for the common service data to delete.
 Values: \n
      - QMI_LOC_DELETE_COMMON_MASK_POS (0x00000001) --  Position estimate; common for all GNSS types
      - QMI_LOC_DELETE_COMMON_MASK_TIME (0x00000002) --  Reset all CLOCK_INFO mask
      - QMI_LOC_DELETE_COMMON_MASK_UTC (0x00000004) --  UTC estimate
      - QMI_LOC_DELETE_COMMON_MASK_RTI (0x00000008) --  RTI
      - QMI_LOC_DELETE_COMMON_MASK_FREQ_BIAS_EST (0x00000010) --  Frequency bias estimate; common for all GNSS types
 */

  /* Optional */
  /*  GNSS Service Data to Delete */
  uint8_t deleteSatelliteData_valid;  /**< Must be set to true if deleteSatelliteData is being passed */
  qmiLocDeleteSatelliteDataStructT_v02 deleteSatelliteData;
  /**<   Request to delete the GNSS service data.*/

  /* Optional */
  /*  Requested Extended Bitmask of Clock Info Data to Delete */
  uint8_t deleteExtClockInfoMask_valid;  /**< Must be set to true if deleteExtClockInfoMask is being passed */
  qmiLocExtDeleteClockInfoMaskT_v02 deleteExtClockInfoMask;
  /**<   Extended mask for the clock information service data to delete.
 If QMI_LOC_DELETE_DATA_MASK_TIME is set in deleteServiceDataMask,
 deleteExtClockInfoMask is ignored.
 Values: \n
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GPS_TB (0x000001) --  Delete NavIC-to-GPS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GLO_TB (0x000002) --  Delete NavIC-to-GLO time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_BDS_TB (0x000004) --  Delete NavIC-to-BDS time bias-related information
      - QMI_LOC_MASK_DELETE_CLOCK_INFO_NAVIC_TO_GAL_TB (0x000008) --  Delete NavIC-to-GAL time bias-related information
 */
}qmiLocDeleteGNSSServiceDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Deletes the location engine
                    service data from memory. */
typedef struct {

  /* Mandatory */
  /*  Delete GNSS Service Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Delete Assist Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocDeleteGNSSServiceDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCXTRADATAFORMATENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_XTRA_DATA_V02 = 0, /**<  Default is XTRA format.  */
  QMILOCXTRADATAFORMATENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocXtraDataFormatEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects XTRA data. */
typedef struct {

  /* Mandatory */
  /*  Total Size */
  uint32_t totalSize;
  /**<   Total size of the XTRA data to inject. \n
        - Units -- Bytes */

  /* Mandatory */
  /*  Total Parts */
  uint16_t totalParts;
  /**<   Total number of parts to divide the XTRA data into. */

  /* Mandatory */
  /*  Part Number */
  uint16_t partNum;
  /**<   Number of the current XTRA data part; starts at 1. */

  /* Mandatory */
  /*  Data */
  uint32_t partData_len;  /**< Must be set to # of elements in partData */
  uint8_t partData[QMI_LOC_MAX_XTRA_PART_LEN_V02];
  /**<   XTRA data. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 1024
    */

  /* Optional */
  /*  Format Type */
  uint8_t formatType_valid;  /**< Must be set to true if formatType is being passed */
  qmiLocXtraDataFormatEnumT_v02 formatType;
  /**<   XTRA data format. \n
 Values: \n
      - eQMI_LOC_XTRA_DATA (0) --  Default is XTRA format.
 */
}qmiLocInjectXtraDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects XTRA data. */
typedef struct {

  /* Mandatory */
  /*  Data Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the data injection request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Part Number */
  uint8_t partNum_valid;  /**< Must be set to true if partNum is being passed */
  uint16_t partNum;
  /**<   Number of the XTRA data part for which this indication
      is sent; starts at 1. */

  /* Optional */
  /*  Success Constellation Mask */
  uint8_t ConstellationMask_valid;  /**< Must be set to true if ConstellationMask is being passed */
  qmiLocGNSSConstellEnumT_v02 ConstellationMask;
  /**<   Constellation mask set when the XTRA data is accepted by the modem GNSS engine.
 This optional TLV is only available when at least one constellation injection is successful,
 and it is only available in the last XTRA injection indication.
      - eQMI_SYSTEM_GPS (0x01) --  Enable GPS \n
      - eQMI_SYSTEM_GLO (0x02) --  Enable GLONASS \n
      - eQMI_SYSTEM_BDS (0x04) --  Enable BDS \n
      - eQMI_SYSTEM_GAL (0x08) --  Enable Galileo \n
      - eQMI_SYSTEM_QZSS (0x10) --  Enable QZSS \n
      - eQMI_SYSTEM_NAVIC (0x20) --  Enable NavIC  */
}qmiLocInjectXtraDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject PCID, which the XTRA service uses. */
typedef struct {

  /* Mandatory */
  /*  XTRA PCID */
  uint64_t xtraPcid;
  /**<   XTRA PCID data. \n
      - Type -- uint64 */
}qmiLocInjectXtraPcidReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject PCID, which the XTRA service uses. */
typedef struct {

  /* Mandatory */
  /*  Inject XTRA PCID Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the inject XTRA PCID command.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectXtraPcidIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query the QMI_LOC service supported features. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocGetSupportedFeatureReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSUPPORTEDFEATUREENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SUPPORTED_FEATURE_ODCPI_2_V02 = 0, /**<  Support the ODCPI version 2 feature \n  */
  eQMI_LOC_SUPPORTED_FEATURE_WIFI_AP_DATA_INJECT_2_V02 = 1, /**<  Support the Wi-Fi AP data inject version 2 feature \n  */
  eQMI_LOC_SUPPORTED_FEATURE_DEBUG_NMEA_V02 = 2, /**<  Support the debug NMEA feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_GNSS_ONLY_POSITION_REPORT_V02 = 3, /**<  Support the GNSS only position report feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_FDCL_V02 = 4, /**<  Support the FDCL feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_CONSTELLATION_ENABLEMENT_V02 = 5, /**<  Support the GNSS constellation enablement feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_AGPM_V02 = 6, /**<  Support the advanced GNSS power management feature\n  */
  eQMI_LOC_SUPPORTED_FEATURE_XTRA_INTEGRITY_V02 = 7, /**<  Support the XTRA integrity feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_FDCL_2_V02 = 8, /**<  Support the FDCL version 2 feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_LOCATION_PRIVACY_V02 = 9, /**<  Support the location privacy feature \n */
  eQMI_LOC_SUPPORTED_FEATURE_NAVIC_V02 = 10, /**<  Support the NavIC constellation \n */
  eQMI_LOC_SUPPORTED_FEATURE_ENV_AIDING_V02 = 11, /**<  Support environment aiding \n */
  eQMI_LOC_SUPPORTED_FEATURE_ROBUST_LOCATION_V02 = 12, /**<  Support Robust Location feature  */
  eQMI_LOC_SUPPORTED_FEATURE_EDGNSS_V02 = 13, /**<  Support enhanced DGNSS  */
  eQMI_LOC_SUPPORTED_FEATURE_MULTIBAND_CONFIG_V02 = 14, /**<  Support the multiband GNSS configuration feature  */
  QMILOCSUPPORTEDFEATUREENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSupportedFeatureEnumT_v02;
/**
    @}
  */

typedef uint64_t qmiLocFeaturesStatusMaskT_v02;
#define QMI_LOC_FEATURE_STATUS_CARRIER_PHASE_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000001ull) /**<  Carrier Phase feature status. \n */
#define QMI_LOC_FEATURE_STATUS_SV_POLYNOMIALS_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000002ull) /**<  SV Polynomial reporting status.\n  */
#define QMI_LOC_FEATURE_STATUS_SV_EPHEMERIS_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000004ull) /**<  SV Ephemeris reporting status.\n  */
#define QMI_LOC_FEATURE_STATUS_SINGLE_FREQUENCY_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000008ull) /**<  GNSS Single Frequency status.\n  */
#define QMI_LOC_FEATURE_STATUS_MULTI_FREQUENCY_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000010ull) /**<  GNSS Multi Frequency status. \n */
#define QMI_LOC_FEATURE_STATUS_TIME_FREQUENCY_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000020ull) /**<  Time and Frequency status.\n  */
#define QMI_LOC_FEATURE_STATUS_TIME_UNCERTAINTY_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000040ull) /**<  Time Uncertainty  status. \n */
#define QMI_LOC_FEATURE_STATUS_CLOCK_ESTIMATE_V02 ((qmiLocFeaturesStatusMaskT_v02)0x00000080ull) /**<  Clock Estimate status. \n */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the QMI_LOC service supported features. */
typedef struct {

  /* Mandatory */
  /*  Supported Feature Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Query Supported Feature request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Supported Features */
  uint32_t feature_len;  /**< Must be set to # of elements in feature */
  uint8_t feature[QMI_LOC_SUPPORTED_FEATURE_LENGTH_V02];
  /**<   Describes which features are supported in the running
       QMI_LOC service. The array of unit8 is the bitmask where each bit
       represents a feature enum. Bit 0 represents feature enum ID 0,
       bit 1 represents feature enum ID 1, etc.
       For example, if QMI_LOC supports feature enum 0,1,2,8,
       feature_len is 2, and
       feature array is [7,1]. \n
       - Type -- Array of uint8 \n
       - Maximum array length -- 100
  */

  /* Optional */
  /*  Features Mask */
  uint8_t featureStatusReport_valid;  /**< Must be set to true if featureStatusReport is being passed */
  qmiLocFeaturesStatusMaskT_v02 featureStatusReport;
  /**<   Bitmask indicating the modem feature status for
 features controlled with licenses.
 Valid bitmasks: \n
      - QMI_LOC_FEATURE_STATUS_CARRIER_PHASE (0x00000001) --  Carrier Phase feature status. \n
      - QMI_LOC_FEATURE_STATUS_SV_POLYNOMIALS (0x00000002) --  SV Polynomial reporting status.\n
      - QMI_LOC_FEATURE_STATUS_SV_EPHEMERIS (0x00000004) --  SV Ephemeris reporting status.\n
      - QMI_LOC_FEATURE_STATUS_SINGLE_FREQUENCY (0x00000008) --  GNSS Single Frequency status.\n
      - QMI_LOC_FEATURE_STATUS_MULTI_FREQUENCY (0x00000010) --  GNSS Multi Frequency status. \n
      - QMI_LOC_FEATURE_STATUS_TIME_FREQUENCY (0x00000020) --  Time and Frequency status.\n
      - QMI_LOC_FEATURE_STATUS_TIME_UNCERTAINTY (0x00000040) --  Time Uncertainty  status. \n
      - QMI_LOC_FEATURE_STATUS_CLOCK_ESTIMATE (0x00000080) --  Clock Estimate status. \n
 */
}qmiLocGetSupportedFeatureIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Location service internal status configuration message. */
typedef struct {

  /* Mandatory */
  /*  Location Service Internal Status Configuration */
  uint8_t config;
  /**<   Request to turn on/off the location service internal status report.\n
       - 0x01 (TRUE) -- Turn the report on \n
       - 0x00 (FALSE) -- Turn the report off
    */
}qmiLocSetInternalStatusConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Location service internal status configuration message. */
typedef struct {

  /* Mandatory */
  /*  Set Location Service Internal Status Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the set location service internal status configuration request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetInternalStatusConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t data[QMI_LOC_INTERNAL_STATUS_REPORT_DATA_LENGTH_V02];
  /**<   The data of the reported GPS message. */
}qmiLocInternalStatusReportDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the location service internal status report to the control point. */
typedef struct {

  /* Mandatory */
  /*  Internal Status Report Data */
  uint32_t reportData_len;  /**< Must be set to # of elements in reportData */
  qmiLocInternalStatusReportDataStructT_v02 reportData[QMI_LOC_INTERNAL_STATUS_MAX_LIST_SIZE_V02];
}qmiLocEventInternalStatusReportIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocSrnApDataDeviceTypeMaskT_v02;
#define QMI_LOC_SRN_AP_DATA_TECH_TYPE_BT_V02 ((qmiLocSrnApDataDeviceTypeMaskT_v02)0x00000001) /**<  SRN AP technology Bluetooth  */
#define QMI_LOC_SRN_AP_DATA_TECH_TYPE_BTLE_V02 ((qmiLocSrnApDataDeviceTypeMaskT_v02)0x00000002) /**<  SRN AP technology Bluetooth low energy  */
#define QMI_LOC_SRN_AP_DATA_TECH_TYPE_NFC_V02 ((qmiLocSrnApDataDeviceTypeMaskT_v02)0x00000004) /**<  SRN AP technology NFC  */
#define QMI_LOC_SRN_AP_DATA_TECH_TYPE_MOBILE_CODE_V02 ((qmiLocSrnApDataDeviceTypeMaskT_v02)0x00000008) /**<  SRN AP technology mobile code  */
#define QMI_LOC_SRN_AP_DATA_TECH_TYPE_OTHER_V02 ((qmiLocSrnApDataDeviceTypeMaskT_v02)0x00000010) /**<  SRN AP technology other */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSRNAPDATAMACADDRTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SRN_AP_DATA_PUBLIC_MAC_ADDR_V02 = 0, /**<  SRN AP MAC address type PUBLIC \n  */
  eQMI_LOC_SRN_AP_DATA_PRIVATE_MAC_ADDR_V02 = 1, /**<  SRN AP MAC address type PRIVATE \n  */
  eQMI_LOC_SRN_AP_DATA_OTHER_MAC_ADDR_V02 = 2, /**<  SRN AP MAC address type OTHER */
  QMILOCSRNAPDATAMACADDRTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSrnApDataMacAddrTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to inject SRN (BT, BLE, NFC, etc.) AP data. */
typedef struct {

  /* Mandatory */
  /*  SRN Request Tech Mask */
  qmiLocSrnApDataDeviceTypeMaskT_v02 srnTechMask;
  /**<   Specifies which SRN technologies AP measurement data
 is being requested by the client.
 Values: \n
      - QMI_LOC_SRN_AP_DATA_TECH_TYPE_BT (0x00000001) --  SRN AP technology Bluetooth
      - QMI_LOC_SRN_AP_DATA_TECH_TYPE_BTLE (0x00000002) --  SRN AP technology Bluetooth low energy
      - QMI_LOC_SRN_AP_DATA_TECH_TYPE_NFC (0x00000004) --  SRN AP technology NFC
      - QMI_LOC_SRN_AP_DATA_TECH_TYPE_MOBILE_CODE (0x00000008) --  SRN AP technology mobile code
      - QMI_LOC_SRN_AP_DATA_TECH_TYPE_OTHER (0x00000010) --  SRN AP technology other */

  /* Mandatory */
  /*  SRN Request  */
  uint8_t srnRequest;
  /**<   Specifies whether the GPS engine is requesting a start or stop
       for an SRN measurement.
       Values: \n
       - 0x01 (TRUE) -- Start \n
       - 0x00 (FALSE) -- Stop

  */

  /* Optional */
  /*  E911 Mode  */
  uint8_t e911Mode_valid;  /**< Must be set to true if e911Mode is being passed */
  uint8_t e911Mode;
  /**<   Indicates to the client whether the GPS engine
       is in E911 mode.
       Values: \n
       - 0x01 (TRUE) -- GPS engine is in E911 mode \n
       - 0x00 (FALSE) -- GPS engine is not in E911 mode
    */

  /* Optional */
  /*  SRN MAC Address Type  */
  uint8_t srnApMacAddrType_valid;  /**< Must be set to true if srnApMacAddrType is being passed */
  qmiLocSrnApDataMacAddrTypeEnumT_v02 srnApMacAddrType;
  /**<   Specifies the MAC address type requested.
 Values: \n
      - eQMI_LOC_SRN_AP_DATA_PUBLIC_MAC_ADDR (0) --  SRN AP MAC address type PUBLIC \n
      - eQMI_LOC_SRN_AP_DATA_PRIVATE_MAC_ADDR (1) --  SRN AP MAC address type PRIVATE \n
      - eQMI_LOC_SRN_AP_DATA_OTHER_MAC_ADDR (2) --  SRN AP MAC address type OTHER */
}qmiLocEventInjectSrnApDataReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSRNAPDATATECHTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SRN_AP_DATA_TECH_TYPE_BT_V02 = 0, /**<  SRN AP technology Bluetooth \n */
  eQMI_LOC_SRN_AP_DATA_TECH_TYPE_BTLE_V02 = 1, /**<  SRN AP technology Bluetooth low energy \n */
  eQMI_LOC_SRN_AP_DATA_TECH_TYPE_NFC_V02 = 2, /**<  SRN AP technology NFC \n */
  eQMI_LOC_SRN_AP_DATA_TECH_TYPE_MOBILE_CODE_V02 = 3, /**<  SRN AP technology mobile code \n */
  eQMI_LOC_SRN_AP_DATA_TECH_TYPE_OTHER_V02 = 4, /**<  SRN AP technology other */
  QMILOCSRNAPDATATECHTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSrnApDataTechTypeEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocSrnApDataMaskT_v02;
#define QMI_LOC_SRN_APDATA_MASK_AP_MAC_V02 ((qmiLocSrnApDataMaskT_v02)0x00000001) /**<  SRN AP MAC address is valid \n */
#define QMI_LOC_SRN_APDATA_MASK_AP_RSSI_V02 ((qmiLocSrnApDataMaskT_v02)0x00000002) /**<  SRN AP RSSI is valid \n */
#define QMI_LOC_SRN_APDATA_MASK_RSSI_TIMESTAMP_V02 ((qmiLocSrnApDataMaskT_v02)0x00000004) /**<  SRN AP RSSI timestamp is valid  */
/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSRNAPERRENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_SRN_AP_ERR_UNKNOWN_V02 = 0, /**<  Error is unknown \n */
  eQMI_LOC_SRN_AP_ERR_NO_REQ_MEAS_AVAILABLE_V02 = 1, /**<  None of the requested measurements could be provided \n */
  eQMI_LOC_SRN_AP_ERR_SENSOR_OFF_V02 = 2, /**<  Sensor is off  */
  QMILOCSRNAPERRENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSrnApErrEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSrnApDataMaskT_v02 srnApDataMask;
  /**<   Specifies which SRN AP information types are used.
 Values:
      - QMI_LOC_SRN_APDATA_MASK_AP_MAC (0x00000001) --  SRN AP MAC address is valid \n
      - QMI_LOC_SRN_APDATA_MASK_AP_RSSI (0x00000002) --  SRN AP RSSI is valid \n
      - QMI_LOC_SRN_APDATA_MASK_RSSI_TIMESTAMP (0x00000004) --  SRN AP RSSI timestamp is valid  */

  uint8_t macAddress[QMI_LOC_SRN_MAC_ADDR_LENGTH_V02];
  /**<   MAC address.
       Each address is of length QMI_LOC_SRN_MAC_ADDR_LENGTH. */

  int32_t apSrnRssi;
  /**<   AP signal strength indicator in dBm. */

  int64_t apSrnTimestamp;
  /**<   UTC timestamp at which the scan was requested. \n
       Units -- Milliseconds \n
       Type -- int64 */
}qmiLocSrnBtleApDeviceDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Injects BT, BLE, NFC AP data. */
typedef struct {

  /* Mandatory */
  /*  Scan Receive Timestamp */
  qmiLocSrnApDataTechTypeEnumT_v02 apDeviceTechType;
  /**<   List of AP device types.
 Values: \n
      - eQMI_LOC_SRN_AP_DATA_TECH_TYPE_BT (0) --  SRN AP technology Bluetooth \n
      - eQMI_LOC_SRN_AP_DATA_TECH_TYPE_BTLE (1) --  SRN AP technology Bluetooth low energy \n
      - eQMI_LOC_SRN_AP_DATA_TECH_TYPE_NFC (2) --  SRN AP technology NFC \n
      - eQMI_LOC_SRN_AP_DATA_TECH_TYPE_MOBILE_CODE (3) --  SRN AP technology mobile code \n
      - eQMI_LOC_SRN_AP_DATA_TECH_TYPE_OTHER (4) --  SRN AP technology other */

  /* Optional */
  /*  SRN AP Scan Data */
  uint8_t srnBtleApInfo_valid;  /**< Must be set to true if srnBtleApInfo is being passed */
  uint32_t srnBtleApInfo_len;  /**< Must be set to # of elements in srnBtleApInfo */
  qmiLocSrnBtleApDeviceDataStructT_v02 srnBtleApInfo[QMI_LOC_SRN_MAX_REPORTED_APS_PER_MSG_V02];
  /**<   List of Wi-Fi AP scan information entered by the control point. */

  /* Optional */
  /*  Scan Request Timestamp */
  uint8_t requestTimestamp_valid;  /**< Must be set to true if requestTimestamp is being passed */
  int64_t requestTimestamp;
  /**<   UTC timestamp at which the scan was started. \n
       Units -- Milliseconds \n
     */

  /* Optional */
  /*  Scan Receive Timestamp */
  uint8_t receiveTimestamp_valid;  /**< Must be set to true if receiveTimestamp is being passed */
  int64_t receiveTimestamp;
  /**<   UTC timestamp at which the scan was received. \n
       Units -- Milliseconds \n
     */

  /* Optional */
  /*  Failure Reason for SRN Measurements Not Available  */
  uint8_t errorCause_valid;  /**< Must be set to true if errorCause is being passed */
  qmiLocSrnApErrEnumT_v02 errorCause;
  /**<   If SRN measurements are not available,
 indicate the reason for the error/failure.
 This field is not present when SRN measurements are available.
 Values:
      - eQMI_LOC_SRN_AP_ERR_UNKNOWN (0) --  Error is unknown \n
      - eQMI_LOC_SRN_AP_ERR_NO_REQ_MEAS_AVAILABLE (1) --  None of the requested measurements could be provided \n
      - eQMI_LOC_SRN_AP_ERR_SENSOR_OFF (2) --  Sensor is off  */
}qmiLocInjectSrnApDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Injects BT, BLE, NFC AP data. */
typedef struct {

  /* Mandatory */
  /*  Bluetooth, Bluetooth LE, NFC AP Scan Information Injection Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject Bluetooth AP Scan Information request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled   */
}qmiLocInjectSrnApDataIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocCrowdSourcingTechnologyMaskT_v02;
#define QMI_LOC_CROWDSOURCING_MASK_WIFI_V02 ((qmiLocCrowdSourcingTechnologyMaskT_v02)0x00000001) /**<  Wi-Fi crowdsourcing  */
typedef uint32_t qmiLocCrowdSourcingSourceMaskT_v02;
#define QMI_LOC_CROWDSOURCING_SOURCE_MASK_BARO_V02 ((qmiLocCrowdSourcingSourceMaskT_v02)0x00000001) /**<  Baro crowdsourcing  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t enableCrowdSourcingOnDemand;
  /**<   Indicates whether on-demand crowdsourcing is enabled by the OEM.
       If enabled, GNSS, sensors, and Wi-Fi measurements are requested
       on demand. This directly affects the power consumption. \n
       When enabled by the OEM, the location engine performs on-demand crowdsourcing
       only when enabled by the server via the server configuration.
       When disabled by the OEM, the location engine does not perform on-demand crowdsourcing. \n
       Values: \n
       - 0x01 (TRUE)  -- Enable on-demand crowdsourcing (default) \n
       - 0x00 (FALSE) -- Disable on-demand crowdsourcing
  */

  uint8_t enableCrowdSourcingOnUnsolicitedGnss;
  /**<   Indicates whether crowdsourcing on unsolicited GNSS fixes is enabled by the OEM.
       If enabled, Wi-Fi crowdsourcing might be done upon receipt of a GNSS fix.
       No power is spent requesting the GNSS fix, but power can be spent
       requesting a Wi-Fi scan or any other measurement sources. \n
       When enabled by the OEM, the location engine performs crowdsourcing of unsolicited GNSS fixes
       only when enabled by the server via the server configuration.
       When disabled by the OEM, the location engine does not perform crowdsourcing of unsolicited GNSS fixes. \n
       Values: \n
       - 0x01 (TRUE)  -- Enable crowdsourcing of unsolicited GNSS fixes (default) \n
       - 0x00 (FALSE) -- Disable crowdsourcing of unsolicited GNSS fixes
  */

  uint8_t enableBatteryLevelBasedThrottling;
  /**<   Indicates whether to throttle crowdsourcing based on the battery level.
       If enabled, no power is spent on crowdsourcing if the battery runs below
       25% charge unless a charger is connected. \n
       Values: \n
       - 0x01 (TRUE)  -- Enable throttling on the battery level (default) \n
       - 0x00 (FALSE) -- Disable throttling on the battery level
  */

  uint8_t enableRttCrowdSourcing;
  /**<   Enable round-trip time (RTT) for crowdsourcing. \n
       Values: \n
       - 0x01 (TRUE)  -- Enable RTT for crowdsourcing (default) \n
       - 0x00 (FALSE) -- Disable RTT for crowdsourcing
    */

  uint8_t enableRtt3CrowdSourcing;
  /**<   Enable 2-sided RTT (RTT3) for crowdsourcing. \n
       Values: \n
       - 0x01 (TRUE)  -- Enable RTT3 for crowdsourcing (default)\n
       - 0x00 (FALSE) -- Disable RTT3 for crowdsourcing
  */

  int32_t rttSignalDbmThresh;
  /**<   Indicates the signal strength threshold in dbM below which
       AP measurements are filtered out. \n
       - Default -- -90 \n
       - Units -- dbM
     */

  uint16_t maxDataTransferFormatVersionSupported;
  /**<   Maximum version of the format in which data can be transferred.
       This version is the maximum data format version in which the control point can read/write data
       while sending/receiving the crowdsourced data to the location engine. \n
       - Format -- The data format version is an integer that is incremented every time
       the data format changes. \n
       - Version negotiation -- The location engine also sends the maximum version of the data format
       it supports in QMI_LOC_CROWDSOURCE_MANAGER_IND. The control point uses
       the minimum of the data format version it supports and the data format version the location engine
       supports. It calls this minimum version the negotiation data format version. The control point
       then reads or writes the data in the negotiated version format. \n
       - Units -- N/A
   */
}qmiLocWifiCrowdSourcingLocalConfigStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to send crowdsource manager controls to the location engine. */
typedef struct {

  /* Optional */
  /*  Crowdsourcing Technology Mask */
  uint8_t enableCrowdSourcingMask_valid;  /**< Must be set to true if enableCrowdSourcingMask is being passed */
  qmiLocCrowdSourcingTechnologyMaskT_v02 enableCrowdSourcingMask;
  /**<   Bitmask of technologies to enable for crowdsourcing.
 Values: \n
      - QMI_LOC_CROWDSOURCING_MASK_WIFI (0x00000001) --  Wi-Fi crowdsourcing
 */

  /* Optional */
  /*  Wi-Fi Crowdsourcing Local Configuration */
  uint8_t wifiCrowdSourcingLocalConfig_valid;  /**< Must be set to true if wifiCrowdSourcingLocalConfig is being passed */
  qmiLocWifiCrowdSourcingLocalConfigStructT_v02 wifiCrowdSourcingLocalConfig;
  /**<   \n Local configuration for Wi-Fi crowdsourcing.
    */

  /* Optional */
  /*  Wi-Fi Crowdsourcing Server Configuration */
  uint8_t wifiCrowdSourcingServerConfig_valid;  /**< Must be set to true if wifiCrowdSourcingServerConfig is being passed */
  uint32_t wifiCrowdSourcingServerConfig_len;  /**< Must be set to # of elements in wifiCrowdSourcingServerConfig */
  char wifiCrowdSourcingServerConfig[QMI_LOC_MAX_WIFI_CROWDSOURCING_SERVER_CONFIG_LEN_V02];
  /**<   Most recent ASN.1 encoded Wi-Fi crowdsourcing server configuration control received.
  */

  /* Optional */
  /*  Crowdsourcing Source Mask */
  uint8_t enableSourceMask_valid;  /**< Must be set to true if enableSourceMask is being passed */
  qmiLocCrowdSourcingSourceMaskT_v02 enableSourceMask;
  /**<   Bitmask of sources to enable for crowdsourcing.
 Values: \n
      - QMI_LOC_CROWDSOURCING_SOURCE_MASK_BARO (0x00000001) --  Baro crowdsourcing
 */
}qmiLocCrowdSourceManagerControlReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t onDemandCrowdSourcingSupported;
  /**<   Indicates whether on-demand crowdsourcing is supported.
       If supported, GNSS, sensors, and Wi-Fi measurements are requested
       on demand. This directly affects power consumption. \n
       Values: \n
       - 0x01 (TRUE)  -- On-demand crowdsourcing is supported \n
       - 0x00 (FALSE) -- On-demand crowdsourcing is not supported (default)
  */

  uint8_t UnsolicitedGnssCrowdSourcingSupported;
  /**<   Indicates whether crowdsourcing of unsolicited GNSS fixes is supported.
       If supported, Wi-Fi crowdsourcing might be done upon receipt of a GNSS fix.
       No power is spent requesting a GNSS fix, but power might be spent
       requesting a Wi-Fi scan. \n
       Values: \n
       - 0x01 (TRUE)  -- Crowdsourcing of unsolicited GNSS fixes is supported \n
       - 0x00 (FALSE) -- Crowdsourcing of unsolicited GNSS fixes is not supported (default)
  */

  uint8_t majorVersionSupported;
  /**<   Major version of crowdsourcing supported.
   */

  uint8_t minorVersionSupported;
  /**<   Minor version of crowdsourcing supported.
   */

  uint16_t maxDataTransferFormatVersionSupported;
  /**<   Maximum version of the format in which data can be transferred.
       This version is the maximum data format version in which the location engine can read/write data
       while sending/receiving the crowdsourced data to the control point. \n
       - Format -- Data format version is an integer that is incremented every time
       the data format changes. \n
       - Version negotiation -- The control point also sends the maximum version of the data format
       it supports in QMI_LOC_CROWDSOURCE_MANAGER_REQ. The location engine uses
       the minimum of the data format version it supports and the data format version the control point
       supports. It calls this minimum version the negotiation data format version. The location engine
       then reads or writes the data in the negotiated version format. \n
       - Units -- N/A
   */
}qmiLocWifiCrowdSourcingCapabilityStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to send crowdsource manager controls to the location engine. */
typedef struct {

  /* Mandatory */
  /*  Crowdsource Control Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the crowdsource control request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 \n The status eQMI_LOC_GENERAL_FAILURE indicates that the
 control point does not support fusion crowdsourcing.
 */

  /* Optional */
  /*  Crowdsource Technologies Supported Mask. */
  uint8_t supportedCrowdSourcingMask_valid;  /**< Must be set to true if supportedCrowdSourcingMask is being passed */
  qmiLocCrowdSourcingTechnologyMaskT_v02 supportedCrowdSourcingMask;
  /**<   Bitmask of technologies supported for crowdsourcing. \n
 Values: \n
      - QMI_LOC_CROWDSOURCING_MASK_WIFI (0x00000001) --  Wi-Fi crowdsourcing
 */

  /* Optional */
  /*  Wi-Fi Crowd Sourcing Capability */
  uint8_t wifiCrowdSourcingCapabaility_valid;  /**< Must be set to true if wifiCrowdSourcingCapabaility is being passed */
  qmiLocWifiCrowdSourcingCapabilityStructT_v02 wifiCrowdSourcingCapabaility;
  /**<   \n Supported capabilities for Wi-Fi crowdsourcing.
    */

  /* Optional */
  /*  Encoded Client Information */
  uint8_t modemClientInfo_valid;  /**< Must be set to true if modemClientInfo is being passed */
  uint32_t modemClientInfo_len;  /**< Must be set to # of elements in modemClientInfo */
  uint8_t modemClientInfo[QMI_LOC_MAX_CROWDSOURCING_MODEM_CLIENT_INFO_LEN_V02];
  /**<   Modem client information from the control point encoded in ASN.1 format.\n
         -- Type -- Array of bytes \n
         -- Maximum length of the array -- 256
    */
}qmiLocCrowdSourceManagerControlIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Requests the location engine to send crowdsourced data
                      to the control point. */
typedef struct {

  /* Optional */
  /*  Crowd Sourcing Technology Mask */
  uint8_t crowdSourcingTechMask_valid;  /**< Must be set to true if crowdSourcingTechMask is being passed */
  qmiLocCrowdSourcingTechnologyMaskT_v02 crowdSourcingTechMask;
  /**<   Bitmask of crowdsourcing technologies for which the crowdsource data is being requested. \n
 Values: \n
      - QMI_LOC_CROWDSOURCING_MASK_WIFI (0x00000001) --  Wi-Fi crowdsourcing
 */
}qmiLocCrowdSourceManagerReadDataReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocXtraConfigMaskT_v02;
#define QMI_LOC_XTRA_CONFIG_DISABLE_AUTO_DOWNLOAD_TIMER_V02 ((qmiLocXtraConfigMaskT_v02)0x00000001) /**<  Ask the engine to disable the XTRA auto download timer \n */
#define QMI_LOC_XTRA_CONFIG_NAVIC_EPH_ASSIST_V02 ((qmiLocXtraConfigMaskT_v02)0x00000002) /**<  Inform the engine of NAVIC ephemeris assist support  */
typedef uint32_t qmiLocXtraInfoMaskT_v02;
#define QMI_LOC_XTRA_INFO_MASK_ABS_AGE_V02 ((qmiLocXtraInfoMaskT_v02)0x00000001) /**<  Number of hours for which the current XTRA information is valid \n */
#define QMI_LOC_XTRA_INFO_MASK_REL_AGE_V02 ((qmiLocXtraInfoMaskT_v02)0x00000002) /**<  Last XTRA data download time \n */
#define QMI_LOC_XTRA_INFO_MASK_XTRA_SERVER_V02 ((qmiLocXtraInfoMaskT_v02)0x00000004) /**<  XTRA server URLs n */
#define QMI_LOC_XTRA_INFO_MASK_NTP_SERVER_V02 ((qmiLocXtraInfoMaskT_v02)0x00000008) /**<  Network Time Protocol (NTP) server URLs \n */
#define QMI_LOC_XTRA_INFO_MASK_TIME_REQUEST_V02 ((qmiLocXtraInfoMaskT_v02)0x00000010) /**<  Requests the control point to send QMI_LOC_INJECT_UTC_TIME_REQ
       to the engine \n */
#define QMI_LOC_XTRA_INFO_MASK_PREF_VALID_AGE_V02 ((qmiLocXtraInfoMaskT_v02)0x00000020) /**<  Preferred valid age \n */
#define QMI_LOC_XTRA_INFO_MASK_NAVIC_EPH_ASSIST_V02 ((qmiLocXtraInfoMaskT_v02)0x00000040) /**<  Support for Navic ephemeris assistance data  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocXtraInfoMaskT_v02 reportMask;
  /**<   Bitmask indicating which of the fields in this TLV are reported. \n
 Values: \n
      - QMI_LOC_XTRA_INFO_MASK_ABS_AGE (0x00000001) --  Number of hours for which the current XTRA information is valid \n
      - QMI_LOC_XTRA_INFO_MASK_REL_AGE (0x00000002) --  Last XTRA data download time \n
      - QMI_LOC_XTRA_INFO_MASK_XTRA_SERVER (0x00000004) --  XTRA server URLs n
      - QMI_LOC_XTRA_INFO_MASK_NTP_SERVER (0x00000008) --  Network Time Protocol (NTP) server URLs \n
      - QMI_LOC_XTRA_INFO_MASK_TIME_REQUEST (0x00000010) --  Requests the control point to send QMI_LOC_INJECT_UTC_TIME_REQ
       to the engine \n
      - QMI_LOC_XTRA_INFO_MASK_PREF_VALID_AGE (0x00000020) --  Preferred valid age \n
      - QMI_LOC_XTRA_INFO_MASK_NAVIC_EPH_ASSIST (0x00000040) --  Support for Navic ephemeris assistance data  */

  uint16_t absAgeHrs;
  /**<   Number of hours for which the current XTRA information is valid \n
       - Units -- Hours */

  uint64_t relAgeInUTC;
  /**<   Last XTRA data download time in UTC. \n
       - Units -- Milliseconds */

  qmiLocPredictedOrbitsServerListStructT_v02 xtraServerInfo;
  /**<   Contains information about the XTRA servers that can be used by the control
       point to download XTRA data. */

  qmiLocTimeServerListStructT_v02 ntpServerInfo;
  /**<   Contains information about the time servers recommended by the
       location service for the UTC time. */

  uint8_t timeRequest;
  /**<    Requests the control point to send QMI_LOC_INJECT_UTC_TIME_REQ
        to the engine. \n
       - 0x00 (FALSE) -- The engine has the UTC time \n
       - 0x01 (TRUE) -- Requests the control point to inject the UTC time to the engine */

  uint16_t preferedValidAgeHrs;
  /**<   Preferred valid age. \n
       - Units -- Hours */
}qmiLocXtraInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t majorVersion;
  /**<   Major version number. */

  uint8_t minorVersion;
  /**<   Minor version number. */
}qmiLocVersionStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query the XTRA information. */
typedef struct {

  /* Mandatory */
  /*  XTRA Configure */
  qmiLocXtraConfigMaskT_v02 xtraConfig;
  /**<   XTRA configuration.
 Values: \n
      - QMI_LOC_XTRA_CONFIG_DISABLE_AUTO_DOWNLOAD_TIMER (0x00000001) --  Ask the engine to disable the XTRA auto download timer \n
      - QMI_LOC_XTRA_CONFIG_NAVIC_EPH_ASSIST (0x00000002) --  Inform the engine of NAVIC ephemeris assist support
 */

  /* Optional */
  /*  XTRA Client Version */
  uint8_t xcVersion_valid;  /**< Must be set to true if xcVersion is being passed */
  qmiLocVersionStructT_v02 xcVersion;
}qmiLocQueryXtraInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the XTRA information. */
typedef struct {

  /* Mandatory */
  /*  Query XTRA Info Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the query XTRA information.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  XTRA Info */
  qmiLocXtraInfoStructT_v02 xtraInfo;
  /**<   \n The XTRA information returned from the engine. */

  /* Optional */
  /*  MP XTRA Version */
  uint8_t mpVersion_valid;  /**< Must be set to true if mpVersion is being passed */
  qmiLocVersionStructT_v02 mpVersion;
}qmiLocQueryXtraInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to initiate an outdoor trip batching session. */
typedef struct {

  /* Mandatory */
  /*  Batch Distance */
  uint32_t batchDistance;
  /**<   The trip distance from the start of outdoor trip batching,
       which triggers the QMI_LOC_EVENT_BATCH_FULL_NOTIFICATION_IND indication
       to report to the control point. \n
       - Units -- Meters
  */

  /* Mandatory */
  /*  Minimum Interval Between Position Reports */
  uint32_t minTimeInterval;
  /**<   Minimum time interval, specified by the control point, that must elapse between
       position reports. \n
       - Units -- Milliseconds
  */

  /* Optional */
  /*  Fix Session Timeout Period */
  uint8_t fixSessionTimeout_valid;  /**< Must be set to true if fixSessionTimeout is being passed */
  uint32_t fixSessionTimeout;
  /**<   Configures the fix session timeout duration. \n
       - Units -- Milliseconds \n
       - Default -- 20,000 milliseconds
  */

  /* Optional */
  /*  Batch All Positions */
  uint8_t batchAllPos_valid;  /**< Must be set to true if batchAllPos is being passed */
  uint8_t batchAllPos;
  /**<   Values: \n
       - TRUE -- All positions that are available must be batched. For example,
              if any other type of positioning is active (such as 1 Hz tracking), all
              positions computed for that use case are also batched. This can
              result in the BATCH_FULL indication being generated earlier. \n
       - FALSE -- Only positions that meet the time and/or distance criteria are batched
                  (default).
  */
}qmiLocStartOutdoorTripBatchingReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to initiate an outdoor trip batching session. */
typedef struct {

  /* Mandatory */
  /*  Start Distance-Based Batching Session Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the outdoor distance batching session start request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocStartOutdoorTripBatchingIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query the accumulated distance
                    of an outdoor trip batching session. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocQueryOTBAccumulatedDistanceReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the accumulated distance
                    of an outdoor trip batching session. */
typedef struct {

  /* Mandatory */
  /*  Query Outdoor Trip Batching Session Accumulated Distance Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the OTB session accumulated distance request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Accumulated OTB Distance */
  uint32_t accumulatedDistance;
  /**<   The accumulated distance from the last QMI_LOC_START_OUTDOOR_TRIP_BATCHING_REQ. \n
       - Units -- Meters
  */

  /* Mandatory */
  /*  Number of Batched Position Reports */
  uint32_t batchedPosition;
  /**<   The number of the position reports that have been batched from the last
       QMI_LOC_START_OUTDOOR_TRIP_BATCHING_REQ.
  */
}qmiLocQueryOTBAccumulatedDistanceIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t gtpClientSwMajorVersion;
  /**<   Major version number from 0 to 255. */

  uint8_t gtpClientSwMinorVersion;
  /**<   Minor version number from 0 to 255. */
}qmiLocGtpClientSwVerStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t homeMncValid;
  /**<   Boolean indicating if homeMnc is valid. */

  uint32_t homeMcc;
  /**<   MCC of home carrier. */

  uint32_t homeMnc;
  /**<   MNC of home carrier. */
}qmiLocHomeCarrierIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t unspecifiedInternal;
  /**<   Unspecified internal contribution. \n
       - Range -- 0 to 100 percent */

  uint8_t unspecifiedExternal;
  /**<   Unspecified external contribution. \n
       - Range -- 0 to 100 percent */

  uint8_t gnss;
  /**<   GNSS contribution. \n
       - Range -- 0 to 100 percent */

  uint8_t sensors;
  /**<   Sensors contribution. \n
       - Range - 0 to 100 percent */

  uint8_t wifi;
  /**<   Wifi contribution. \n
       - Range -- 0 to 100 percent */

  uint8_t wwan;
  /**<   WWAN contribution. \n
       - Range -- 0 to 100 percent */
}qmiLocPositionSourceStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
        - Type -- Floating point \n
        - Units -- Degrees \n
        - Range -- -90.0 to 90.0   \n
            - Positive values indicate northern latitude\n
            - Negative values indicate southern latitude
        */

  double longitude;
  /**<   Longitude (specified in WGS84 datum).\n
       - Type -- Floating point \n
       - Units -- Degrees \n
         - Range -- -180.0 to 180.0   \n
         - Positive values indicate eastern longitude \n
         - Negative values indicate western longitude
    */

  float horizontalUnc;
  /**<   Horizontal circular uncertainty. \n
       - Unit -- Meters */

  float altitude;
  /**<   Altitude with respect to mean sea level. \n
       - Units -- Meters */

  float altitudeUnc;
  /**<   Vertical uncertainty. \n
       - Units -- Meters */

  qmiLocPositionSourceStructT_v02 latestPositionSources;
  /**<   Percentage contributions from all sources for position fix (sum must be ~100%). */
}qmiLocBsBestPositionStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCFDCLAIRINTERFACETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_CDMA_V02 = 0, /**<  FDCL CDMA cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_GSM_V02 = 1, /**<  FDCL GSM cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_WCDMA_V02 = 2, /**<  FDCL WCDMA cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_V02 = 3, /**<  FDCL LTE cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_M1_V02 = 4, /**<  FDCL LTE-M1 cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_NB1_V02 = 5, /**<  FDCL LTE-NB1 cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_M1_MODE_A_V02 = 6, /**<  FDCL LTE-M1 ModeA cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_M1_MODE_B_V02 = 7, /**<  FDCL LTE-M1 ModeB cell \n */
  eQMI_LOC_FDCL_AIR_INTERFACE_TYPE_LTE_UNKNOWN_V02 = 8, /**<  FDCL LTE-Unknown cell  */
  QMILOCFDCLAIRINTERFACETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocFdclAirInterfaceTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocFdclAirInterfaceTypeEnumT_v02 airInterfaceType;
  /**<   The cell type for this record. */

  uint32_t id1;
  /**<   ID1. \n
       - For all air interface -- MCC
   */

  uint32_t id2;
  /**<   ID2. \n
       - For GSM, WCDMA \n
       - For LTE -- MNC
   */

  uint32_t id3;
  /**<   ID3. \n
       - For CDMA -- NID \n
       - For GSM and WCDMA -- LAC \n
       - For LTE -- TAC
   */

  uint32_t id4;
  /**<   ID4. \n
       - For CDMA -- BSID \n
       - For GSM -- CI \n
       - For WCDMA -- U_CI \n
       - For LTE -- G_CI
   */
}qmiLocFdclCellIdStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point for making a FDCL request. */
typedef struct {

  /* Optional */
  /*  GTP client software version */
  uint8_t gtpClientSwVer_valid;  /**< Must be set to true if gtpClientSwVer is being passed */
  qmiLocGtpClientSwVerStructT_v02 gtpClientSwVer;
  /**<   GTP client software version. */

  /* Optional */
  /*  Modem Build String (non-NULL Terminated) */
  uint8_t modemSwVersion_valid;  /**< Must be set to true if modemSwVersion is being passed */
  char modemSwVersion[QMI_LOC_GNSS_SW_VERSION_STRING_MAX_LENGTH_V02 + 1];
  /**<   First 255 characters of the modem build string. \n
         - Type -- character string \n
         - Maximum length of the array -- 255
    */

  /* Optional */
  /*  Home carrier ID */
  uint8_t homeCarrierId_valid;  /**< Must be set to true if homeCarrierId is being passed */
  qmiLocHomeCarrierIdStructT_v02 homeCarrierId;
  /**<   Home carrier ID (only for GSM, WCDMA, or LTE carrier). */

  /* Optional */
  /*  CDMA Realm (non-NULL Terminated) */
  uint8_t cdmaRealm_valid;  /**< Must be set to true if cdmaRealm is being passed */
  char cdmaRealm[QMI_LOC_GNSS_SW_VERSION_STRING_MAX_LENGTH_V02 + 1];
  /**<   CDMA Realm (for home network on CDMA only). \n
         First 255 characters of the CDMA Realm. \n
         - Type -- character string \n
         - Maximum length of the array -- 255
    */

  /* Optional */
  /*  Maximum number of records that can be accepted */
  uint8_t gtpMaxNumRecordsAccepted_valid;  /**< Must be set to true if gtpMaxNumRecordsAccepted is being passed */
  uint16_t gtpMaxNumRecordsAccepted;
  /**<   Range -- 1 to 65,535 (defaults to 650) */

  /* Optional */
  /*  GPS Week */
  uint8_t gpsWeek_valid;  /**< Must be set to true if gpsWeek is being passed */
  uint16_t gpsWeek;
  /**<   Units -- Week number (since Jan. 1, 1970) */

  /* Optional */
  /*  GPS Milliseconds */
  uint8_t gpsMilliseconds_valid;  /**< Must be set to true if gpsMilliseconds is being passed */
  uint32_t gpsMilliseconds;
  /**<   Units -- Milliseconds (since Jan. 1, 1970) */

  /* Optional */
  /*  Base Station Best Position */
  uint8_t bsBestPosition_valid;  /**< Must be set to true if bsBestPosition is being passed */
  qmiLocBsBestPositionStructT_v02 bsBestPosition;

  /* Optional */
  /*  Current Cell ID */
  uint8_t currentCellId_valid;  /**< Must be set to true if currentCellId is being passed */
  qmiLocFdclCellIdStructT_v02 currentCellId;
  /**<   Current cell Id. */

  /* Optional */
  /*  Requested Data Types */
  uint8_t requestedDataTypes_valid;  /**< Must be set to true if requestedDataTypes is being passed */
  uint8_t requestedDataTypes;
  /**<   Requested data types. */

  /* Optional */
  /*  Restricted Region Version */
  uint8_t restrictedRegionVersion_valid;  /**< Must be set to true if restrictedRegionVersion is being passed */
  uint8_t restrictedRegionVersion;
  /**<   Restricted region version. */
}qmiLocEventFdclServiceReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to request the FDCL BS (Base Station)
                   list from TLE. */
typedef struct {

  /* Optional */
  /*  Expire In Days */
  uint8_t expireInDays_valid;  /**< Must be set to true if expireInDays is being passed */
  uint32_t expireInDays;
  /**<   Get the base station list that expire in less than or equal to
       expireInDays.
   */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds (since Jan. 1, 1970) */

  /* Optional */
  /*  Maximum Number of BS to Send */
  uint8_t maxNumBs_valid;  /**< Must be set to true if maxNumBs is being passed */
  uint16_t maxNumBs;
  /**<   Specifies the maximum number of BS to send by the TLE. All the available BS are sent if this optional field is not included. \n
        - Range -- 1 to 65,535 */
}qmiLocGetFdclBsListReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCELLRECORDTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_CELL_RECORD_TYPE_INVALID_V02 = 0, /**<  Invalid value \n */
  eQMI_LOC_CELL_RECORD_TYPE_L1_REGION_WITH_POSITION_V02 = 1, /**<  L1 region with position \n  */
  eQMI_LOC_CELL_RECORD_TYPE_L2_REGION_WITH_POSITION_V02 = 2, /**<  L2 region with position \n */
  eQMI_LOC_CELL_RECORD_TYPE_L3_REGION_WITH_POSITION_V02 = 3, /**<  L3 region with position \n */
  eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_WITH_POSITION_V02 = 4, /**<  L4 cell record with position \n */
  eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_NOT_RESOLVED_V02 = 5, /**<  L4 cell record not resolved \n  */
  eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_NO_INFO_V02 = 6, /**<  L4 cell record no information  */
  QMILOCCELLRECORDTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocCellRecordTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request the FDCL BS (Base Station)
                   list from TLE. */
typedef struct {

  /* Mandatory */
  /*  Get FDCL BS List request Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Get FDCL BS List request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Base station list */
  uint32_t BsList_len;  /**< Must be set to # of elements in BsList */
  qmiLocFdclCellIdStructT_v02 BsList[QMI_LOC_FDCL_BS_LIST_MAX_SIZE_V02];
  /**<   \vspace{4pt} \n A list of base station IDs for FDCL request. */

  /* Optional */
  /*  More BS lists are available */
  uint8_t moreBsAvailable_valid;  /**< Must be set to true if moreBsAvailable is being passed */
  uint8_t moreBsAvailable;
  /**<   Indicates whether more base station lists are available. \n
       - 0x00 (FALSE) -- No more base station lists are available\n
       - 0x01 (TRUE) -- More base station lists are available \n
       If not specified, moreBsAvailable defaults to FALSE.
  */

  /* Optional */
  /*  Base Station Local Timestamp List */
  uint8_t bsLocalTimestampList_valid;  /**< Must be set to true if bsLocalTimestampList is being passed */
  uint32_t bsLocalTimestampList_len;  /**< Must be set to # of elements in bsLocalTimestampList */
  uint32_t bsLocalTimestampList[QMI_LOC_FDCL_BS_LIST_MAX_SIZE_V02];
  /**<   A list of last observed local timestamps for each cell in BsList. \n
       The list is aligned with the base stations in the BsList. */

  /* Optional */
  /*  Base Station Best Position */
  uint8_t bsBestPosition_valid;  /**< Must be set to true if bsBestPosition is being passed */
  qmiLocBsBestPositionStructT_v02 bsBestPosition;
}qmiLocGetFdclBsListIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint32_t qmiLocFdclCellPosValidMaskT_v02;
#define QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALTITUDE_V02 ((qmiLocFdclCellPosValidMaskT_v02)0x00000001) /**<  Altitude field is valid in cell position  */
#define QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_UNC_V02 ((qmiLocFdclCellPosValidMaskT_v02)0x00000002) /**<  Altitude uncertainty field is valid in cell position  */
#define QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_CONFIDENCE_V02 ((qmiLocFdclCellPosValidMaskT_v02)0x00000004) /**<  Altitude confidence is valid in cell position  */
#define QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_RELIABILITY_V02 ((qmiLocFdclCellPosValidMaskT_v02)0x00000008) /**<  Altitude reliability field is valid in cell position  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocFdclCellPosValidMaskT_v02 validMask;
  /**<   Bitmask indicating which of the fields in this TLV are valid.
 Bitmasks: \n
      - QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALTITUDE (0x00000001) --  Altitude field is valid in cell position
      - QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_UNC (0x00000002) --  Altitude uncertainty field is valid in cell position
      - QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_CONFIDENCE (0x00000004) --  Altitude confidence is valid in cell position
      - QMI_LOC_FDCL_CELL_POS_MASK_VALID_ALT_RELIABILITY (0x00000008) --  Altitude reliability field is valid in cell position
 */

  qmiLocFdclCellIdStructT_v02 cellId;
  /**<    \n The cell ID for this record. */

  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0   \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
    */

  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0   \n
        - Positive values indicate eastern longitude \n
        - Negative values indicate western longitude
   */

  float horCoverageRadius;
  /**<   Horizontal coverage radius (circular).\n
        - Units -- Meters */

  uint8_t horConfidence;
  /**<   Horizontal confidence, as defined by ETSI TS 101 109 (3GPP \hyperref[TS 03.32]{TS 03.32}).\n
        - Units -- Percent (1 to 99)\n
        - 0, 101 to 255 -- invalid value \n
        - If 100 is received, reinterpret to 99
     */

  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  float altitude;
  /**<   Altitude with respect to mean sea level.\n
       - Units -- Meters */

  float altUnc;
  /**<   Vertical uncertainty; mandatory if either altitudeWrtEllipsoid
        or altitudeWrtMeanSeaLevel is specified.\n
        - Units -- Meters */

  uint8_t altConfidence;
  /**<   Vertical confidence, as defined by ETSI TS 101 109 (3GPP \hyperref[TS 03.32]{TS 03.32}).\n
        - Units -- Percent (0-99) \n
        - 0 -- invalid value \n
        - 100 to 256 -- not used \n
        - If 100 is received, reinterpret to 99
    */

  qmiLocReliabilityEnumT_v02 altReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */
}qmiLocFdclCellPosStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject FDCL data to TLE. */
typedef struct {

  /* Mandatory */
  /*  FDCL Cell Position List */
  uint32_t cellPosList_len;  /**< Must be set to # of elements in cellPosList */
  qmiLocFdclCellPosStructT_v02 cellPosList[QMI_LOC_FDCL_CELL_POS_LIST_LENGTH_V02];

  /* Mandatory */
  /*  Number of Days this FDCL Data is Valid For */
  uint32_t daysValid;
  /**<   Days valid. */

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   Units -- Milliseconds (since Jan. 1, 1970)
    */

  /* Optional */
  /*  Cell Record Type List */
  uint8_t cellRecordTypeList_valid;  /**< Must be set to true if cellRecordTypeList is being passed */
  uint32_t cellRecordTypeList_len;  /**< Must be set to # of elements in cellRecordTypeList */
  qmiLocCellRecordTypeEnumT_v02 cellRecordTypeList[QMI_LOC_FDCL_CELL_POS_LIST_LENGTH_V02];
  /**<   A list of cell record types for FDCL request. \n
 The cell record type list is aligned with the records in cellPosList. \n
 Values: \n
      - eQMI_LOC_CELL_RECORD_TYPE_INVALID (0) --  Invalid value \n
      - eQMI_LOC_CELL_RECORD_TYPE_L1_REGION_WITH_POSITION (1) --  L1 region with position \n
      - eQMI_LOC_CELL_RECORD_TYPE_L2_REGION_WITH_POSITION (2) --  L2 region with position \n
      - eQMI_LOC_CELL_RECORD_TYPE_L3_REGION_WITH_POSITION (3) --  L3 region with position \n
      - eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_WITH_POSITION (4) --  L4 cell record with position \n
      - eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_NOT_RESOLVED (5) --  L4 cell record not resolved \n
      - eQMI_LOC_CELL_RECORD_TYPE_L4_CELL_RECORD_NO_INFO (6) --  L4 cell record no information
 */

  /* Optional */
  /*  More FDCL Data Available */
  uint8_t moreBsAvailable_valid;  /**< Must be set to true if moreBsAvailable is being passed */
  uint8_t moreBsAvailable;
  /**<   Indicates whether more FDCL data is available. \n
       - 0x00 (FALSE) -- No more FDCL data is available. \n
       - 0x01 (TRUE)  -- More FDCL data is available. \n
       If not specified, moreBsAvailable defaults to FALSE.
  */

  /* Optional */
  /*  Client Controls */
  uint8_t clientControls_valid;  /**< Must be set to true if clientControls is being passed */
  uint16_t clientControls;
  /**<   Client controls. */

  /* Optional */
  /*  Maximum Number of Cells to Upload */
  uint8_t maxNumCellsToUpload_valid;  /**< Must be set to true if maxNumCellsToUpload is being passed */
  uint16_t maxNumCellsToUpload;
  /**<   Maximum number of cells to upload. */

  /* Optional */
  /*  Minimum Seconds Between Requests */
  uint8_t minSecsBtwRequests_valid;  /**< Must be set to true if minSecsBtwRequests is being passed */
  uint16_t minSecsBtwRequests;
  /**<   Minimum seconds between requests. */

  /* Optional */
  /*  Restricted Region Version */
  uint8_t restrictedRegionVersion_valid;  /**< Must be set to true if restrictedRegionVersion is being passed */
  uint8_t restrictedRegionVersion;
  /**<   Restricted region version. */

  /* Optional */
  /*  List of Restricted Regions */
  uint8_t restrictedRegions_valid;  /**< Must be set to true if restrictedRegions is being passed */
  uint32_t restrictedRegions_len;  /**< Must be set to # of elements in restrictedRegions */
  qmiLocHomeCarrierIdStructT_v02 restrictedRegions[QMI_LOC_FDCL_BS_LIST_MAX_SIZE_V02];
}qmiLocInjectFdclDataReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCINJECTFDCLDATASTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_INJECT_FDCL_DATA_SUCCESS_V02 = 0, /**<  Request was completed successfully \n  */
  eQMI_LOC_INJECT_FDCL_DATA_FAILURE_GENERAL_V02 = 1, /**<  Request failed \n  */
  eQMI_LOC_INJECT_FDCL_DATA_FAILURE_NO_CELLS_INJECTED_V02 = 2, /**<  Request failed because no cells were injected  */
  QMILOCINJECTFDCLDATASTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocInjectFdclDataStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject FDCL data to TLE. */
typedef struct {

  /* Mandatory */
  /*  Inject FDCL Data Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the Inject FDCL Data request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  FDCL Data Injection Status */
  qmiLocInjectFdclDataStatusEnumT_v02 inject_status;
  /**<   Status of the FDCL data injection.
 Values: \n
      - eQMI_LOC_INJECT_FDCL_DATA_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_INJECT_FDCL_DATA_FAILURE_GENERAL (1) --  Request failed \n
      - eQMI_LOC_INJECT_FDCL_DATA_FAILURE_NO_CELLS_INJECTED (2) --  Request failed because no cells were injected
 */

  /* Optional */
  /*  Error Message (NULL-Terminated) */
  uint8_t errorMsg_valid;  /**< Must be set to true if errorMsg is being passed */
  char errorMsg[QMI_LOC_INJECT_FDCL_DATA_ERROR_MSG_LEN_V02 + 1];
  /**<   Error message. \n
        - Type -- NULL-terminated string \n
        - Maximum string length (including NULL terminator) -- 256
     */
}qmiLocInjectFdclDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to blacklist GNSS SVs. */
typedef struct {

  /* Optional */
  /*  GLONASS SV IDs to Blacklist */
  uint8_t glo_persist_blacklist_sv_valid;  /**< Must be set to true if glo_persist_blacklist_sv is being passed */
  uint64_t glo_persist_blacklist_sv;
  /**<   Specifies the GLONASS SV mask to disable/blacklist.
       SV ID mapping -- SV 65 maps to bit 0. */

  /* Optional */
  /*  GLONASS SV IDs to Remove from Blacklist */
  uint8_t glo_clear_persist_blacklist_sv_valid;  /**< Must be set to true if glo_clear_persist_blacklist_sv is being passed */
  uint64_t glo_clear_persist_blacklist_sv;
  /**<   Specifies the GLONASS SV mask to remove from persistent blacklist.\n
       SV ID mapping -- SV 65 maps to bit 0. */

  /* Optional */
  /*  BDS SV IDs to Blacklist */
  uint8_t bds_persist_blacklist_sv_valid;  /**< Must be set to true if bds_persist_blacklist_sv is being passed */
  uint64_t bds_persist_blacklist_sv;
  /**<   Specifies the BDS SV mask to disable/blacklist.\n
       SV ID mapping -- SV 201 maps to bit 0. */

  /* Optional */
  /*  BDS SV IDs to Remove from Blacklist */
  uint8_t bds_clear_persist_blacklist_sv_valid;  /**< Must be set to true if bds_clear_persist_blacklist_sv is being passed */
  uint64_t bds_clear_persist_blacklist_sv;
  /**<   Specifies the BDS SV mask to remove from persistent blacklist.\n
       SV ID mapping -- SV 201 maps to bit 0. */

  /* Optional */
  /*  QZSS SV IDs to Blacklist */
  uint8_t qzss_persist_blacklist_sv_valid;  /**< Must be set to true if qzss_persist_blacklist_sv is being passed */
  uint64_t qzss_persist_blacklist_sv;
  /**<   Specifies the QZSS SV mask to disable/blacklist.\n
       SV ID mapping -- SV 193 maps to bit 0 */

  /* Optional */
  /*  QZSS SV IDs to Remove from Blacklist */
  uint8_t qzss_clear_persist_blacklist_sv_valid;  /**< Must be set to true if qzss_clear_persist_blacklist_sv is being passed */
  uint64_t qzss_clear_persist_blacklist_sv;
  /**<   Specifies the QZSS SV mask to remove from persistent blacklist.\n
       SV ID mapping -- SV 193 maps to bit 0. */

  /* Optional */
  /*  Galileo SV IDs to Blacklist */
  uint8_t gal_persist_blacklist_sv_valid;  /**< Must be set to true if gal_persist_blacklist_sv is being passed */
  uint64_t gal_persist_blacklist_sv;
  /**<   Specifies the Galileo SV mask to disable/blacklist.\n
       SV ID mapping -- SV 301 maps to bit 0. */

  /* Optional */
  /*  Galileo SV IDs to Remove from Blacklist */
  uint8_t gal_clear_persist_blacklist_sv_valid;  /**< Must be set to true if gal_clear_persist_blacklist_sv is being passed */
  uint64_t gal_clear_persist_blacklist_sv;
  /**<   Specifies the Galileo SV mask to remove from persistent blacklist.\n
       SV ID mapping -- SV 301 maps to bit 0. */

  /* Optional */
  /*  SBAS SV IDs to Blacklist */
  uint8_t sbas_persist_blacklist_sv_valid;  /**< Must be set to true if sbas_persist_blacklist_sv is being passed */
  uint64_t sbas_persist_blacklist_sv;
  /**<   Specifies the SBAS SV mask to disable/blacklist. SV ID mapping: \n
       - SV IDs 120-158 map to bits 0-38 \n
       - SV IDs 183-191 map to bits 39-47 */

  /* Optional */
  /*  SBAS SV IDs to Remove from Blacklist */
  uint8_t sbas_clear_persist_blacklist_sv_valid;  /**< Must be set to true if sbas_clear_persist_blacklist_sv is being passed */
  uint64_t sbas_clear_persist_blacklist_sv;
  /**<   Specifies the SBAS SV mask to remove from persistent blacklist. SV ID mapping: \n
       - SV IDs 120-158 map to bits 0-38 \n
       - SV IDs 183-191 map to bits 39-47 */

  /* Optional */
  /*  NAVIC SV IDs to Blacklist */
  uint8_t navic_persist_blacklist_sv_valid;  /**< Must be set to true if navic_persist_blacklist_sv is being passed */
  uint64_t navic_persist_blacklist_sv;
  /**<   Specifies the NAVIC SV mask to disable/blacklist. SV ID mapping: \n
       - SV IDs 401-414 map to bits 0-13. */

  /* Optional */
  /*  NAVIC SV IDs to Remove from Blacklist */
  uint8_t navic_clear_persist_blacklist_sv_valid;  /**< Must be set to true if navic_clear_persist_blacklist_sv is being passed */
  uint64_t navic_clear_persist_blacklist_sv;
  /**<   Specifies the NavIC SV mask to remove from persistent blacklist. SV ID mapping: \n
       - SV IDs 401-414 map to bits 0-13. */
}qmiLocSetBlacklistSvReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the GNSS blacklist
                      SV information. */
typedef struct {

  /* Mandatory */
  /*  Get Blacklist SV Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of Get Blacklist SV request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  GLONASS SV IDs Blacklisted */
  uint8_t glo_persist_blacklist_sv_valid;  /**< Must be set to true if glo_persist_blacklist_sv is being passed */
  uint64_t glo_persist_blacklist_sv;
  /**<   Specifies the blacklisted GLONASS SV mask. \n
       SV ID mapping -- SV 65 maps to bit 0. */

  /* Optional */
  /*  BDS SV IDs Blacklisted */
  uint8_t bds_persist_blacklist_sv_valid;  /**< Must be set to true if bds_persist_blacklist_sv is being passed */
  uint64_t bds_persist_blacklist_sv;
  /**<   Specifies the blacklisted BDS SV mask. \n
       SV ID mapping -- SV 201 maps to bit 0. */

  /* Optional */
  /*  QZSS SV IDs Blacklisted */
  uint8_t qzss_persist_blacklist_sv_valid;  /**< Must be set to true if qzss_persist_blacklist_sv is being passed */
  uint64_t qzss_persist_blacklist_sv;
  /**<   Specifies the blacklisted QZSS SV mask.\n
       SV ID mapping -- SV 193 maps to bit 0 */

  /* Optional */
  /*  Galileo SV IDs Blacklisted */
  uint8_t gal_persist_blacklist_sv_valid;  /**< Must be set to true if gal_persist_blacklist_sv is being passed */
  uint64_t gal_persist_blacklist_sv;
  /**<   Specifies the blacklisted Galileo SV mask. \n
       SV ID mapping -- SV 301 maps to bit 0 */

  /* Optional */
  /*  SBAS SV IDs Blacklisted */
  uint8_t sbas_persist_blacklist_sv_valid;  /**< Must be set to true if sbas_persist_blacklist_sv is being passed */
  uint64_t sbas_persist_blacklist_sv;
  /**<   Specifies the blacklisted SBAS SV mask. SV ID mapping: \n
       - SV IDs 120-158 map to bits 0-38 \n
       - SV IDs 183-191 map to bits 39-47 */

  /* Optional */
  /*  NAVIC SV IDs Blacklisted */
  uint8_t navic_persist_blacklist_sv_valid;  /**< Must be set to true if navic_persist_blacklist_sv is being passed */
  uint64_t navic_persist_blacklist_sv;
  /**<   Specifies the blacklisted NAVIC SV mask. SV ID mapping: \n
       - SV IDs 401-414 map to bits 0-13 */
}qmiLocGetBlacklistSvIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocConstellationMaskT_v02;
#define QMI_LOC_CONSTELLATION_GLO_V02 ((qmiLocConstellationMaskT_v02)0x00000001ull) /**<  Enable GLONASS. \n  */
#define QMI_LOC_CONSTELLATION_BDS_V02 ((qmiLocConstellationMaskT_v02)0x00000002ull) /**<  Enable BDS.\n  */
#define QMI_LOC_CONSTELLATION_QZSS_V02 ((qmiLocConstellationMaskT_v02)0x00000004ull) /**<  Enable QZSS. \n */
#define QMI_LOC_CONSTELLATION_GAL_V02 ((qmiLocConstellationMaskT_v02)0x00000008ull) /**<  Enable Galileo. \n */
#define QMI_LOC_CONSTELLATION_NAVIC_V02 ((qmiLocConstellationMaskT_v02)0x00000010ull) /**<  Enable NavIC.  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to enable/disable
                      GNSS constellations */
typedef struct {

  /* Mandatory */
  /*  Reset GNSS Constellation Control */
  uint8_t resetConstellations;
  /**<   Values: \n
       - TRUE --  Resets the GNSS constellation control to NV default. \n
                  Optional TLVs are disregarded.\n
       - FALSE -- Does not reset GNSS constellation control.
  */

  /* Optional */
  /*  GNSS Constellations to Enable */
  uint8_t enableMask_valid;  /**< Must be set to true if enableMask is being passed */
  qmiLocConstellationMaskT_v02 enableMask;
  /**<   Specifies which GNSS constellations to enable.
 GPS is always enabled.
 Valid only when resetConstellations is FALSE.
 Valid bitmasks: \n
      - QMI_LOC_CONSTELLATION_GLO (0x00000001) --  Enable GLONASS. \n
      - QMI_LOC_CONSTELLATION_BDS (0x00000002) --  Enable BDS.\n
      - QMI_LOC_CONSTELLATION_QZSS (0x00000004) --  Enable QZSS. \n
      - QMI_LOC_CONSTELLATION_GAL (0x00000008) --  Enable Galileo. \n
      - QMI_LOC_CONSTELLATION_NAVIC (0x00000010) --  Enable NavIC.  */

  /* Optional */
  /*  GNSS Constellations to Disable */
  uint8_t disableMask_valid;  /**< Must be set to true if disableMask is being passed */
  qmiLocConstellationMaskT_v02 disableMask;
  /**<   Specifies which GNSS constellations to disable.
 GPS cannot be disabled.
 Valid only when resetConstellations is FALSE.
 Valid bitmasks: \n
      - QMI_LOC_CONSTELLATION_GLO (0x00000001) --  Enable GLONASS. \n
      - QMI_LOC_CONSTELLATION_BDS (0x00000002) --  Enable BDS.\n
      - QMI_LOC_CONSTELLATION_QZSS (0x00000004) --  Enable QZSS. \n
      - QMI_LOC_CONSTELLATION_GAL (0x00000008) --  Enable Galileo. \n
      - QMI_LOC_CONSTELLATION_NAVIC (0x00000010) --  Enable NavIC.  */
}qmiLocSetConstellationConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCDCREPORTMSGTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_QZSS_JMA_DISASTER_PREVENTION_INFO_V02 = 43, /**<  Disaster Prevention information provided by Japan Meteolorogical Agency \n  */
  eQMI_LOC_QZSS_NON_JMA_DISASTER_PREVENTION_INFO_V02 = 44, /**<  Disaster Prevention information provided by other organizations  */
  QMILOCDCREPORTMSGTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocDcReportMsgTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the Disaster and Crisis report to the control point. */
typedef struct {

  /* Optional */
  /*  DC Report Message Type */
  uint8_t msgType_valid;  /**< Must be set to true if msgType is being passed */
  qmiLocDcReportMsgTypeEnumT_v02 msgType;
  /**<   Message type of DC report.
 Values:\n
      - eQMI_LOC_QZSS_JMA_DISASTER_PREVENTION_INFO (43) --  Disaster Prevention information provided by Japan Meteolorogical Agency \n
      - eQMI_LOC_QZSS_NON_JMA_DISASTER_PREVENTION_INFO (44) --  Disaster Prevention information provided by other organizations
 */

  /* Optional */
  /*  DC Report No of Valid Bits */
  uint8_t numValidBits_valid;  /**< Must be set to true if numValidBits is being passed */
  uint16_t numValidBits;
  /**<   Number of valid bits in dcReportData. \n
        Client makes use of only the specified number of valid bits. */

  /* Optional */
  /*  Data */
  uint8_t dcReportData_valid;  /**< Must be set to true if dcReportData is being passed */
  uint32_t dcReportData_len;  /**< Must be set to # of elements in dcReportData */
  uint8_t dcReportData[QMI_LOC_MAX_DCREPORT_LEN_V02];
  /**<   Disaster and crisis report. \n
         - Type -- Array of bytes \n
         - Maximum length of the array -- 64
    */
}qmiLocEventDcReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by a control point to register itself as a master
                     client. */
typedef struct {

  /* Mandatory */
  /*  Master Client 32-bit Key */
  uint32_t key;
  /**<   32-bit master client key */
}qmiLocRegisterMasterClientReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCREGISTERMASTERCLIENTSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_REGISTER_MASTER_CLIENT_SUCCESS_V02 = 0, /**<  Request was completed successfully - the associated control point is now the master client \n  */
  eQMI_LOC_REGISTER_MASTER_CLIENT_INVALID_KEY_V02 = 1, /**<  Request failed because the supplied master key is invalid \n  */
  eQMI_LOC_REGISTER_MASTER_CLIENT_ALREADY_HAVE_MASTER_CLIENT_V02 = 2, /**<  Request failed because there is already a master client registered \n  */
  eQMI_LOC_REGISTER_MASTER_CLIENT_INTERNAL_FAILURE_V02 = 3, /**<  Request failed due to unforeseen internal error   */
  QMILOCREGISTERMASTERCLIENTSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocRegisterMasterClientStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by a control point to register itself as a master
                     client. */
typedef struct {

  /* Mandatory */
  /*  Register Master Client Status */
  qmiLocRegisterMasterClientStatusEnumT_v02 status;
  /**<   Status of the master client registration
 Values: \n
      - eQMI_LOC_REGISTER_MASTER_CLIENT_SUCCESS (0) --  Request was completed successfully - the associated control point is now the master client \n
      - eQMI_LOC_REGISTER_MASTER_CLIENT_INVALID_KEY (1) --  Request failed because the supplied master key is invalid \n
      - eQMI_LOC_REGISTER_MASTER_CLIENT_ALREADY_HAVE_MASTER_CLIENT (2) --  Request failed because there is already a master client registered \n
      - eQMI_LOC_REGISTER_MASTER_CLIENT_INTERNAL_FAILURE (3) --  Request failed due to unforeseen internal error
 */
}qmiLocRegisterMasterClientIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCENGINELOCKSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_ENGINE_LOCK_STATE_ENABLED_V02 = 1, /**<  Location engine is enabled \n */
  eQMI_LOC_ENGINE_LOCK_STATE_DISABLED_V02 = 2, /**<  location engine is disabled for mobile-initiated sessions  */
  QMILOCENGINELOCKSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocEngineLockStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the engine lock state to the control point. */
typedef struct {

  /* Mandatory */
  /*  Engine State */
  qmiLocEngineLockStateEnumT_v02 engineLockState;
  /**<   Location engine lock state.
 Values: \n
      - eQMI_LOC_ENGINE_LOCK_STATE_ENABLED (1) --  Location engine is enabled \n
      - eQMI_LOC_ENGINE_LOCK_STATE_DISABLED (2) --  location engine is disabled for mobile-initiated sessions
 */

  /* Optional */
  /*  Subscription Type */
  uint8_t subType_valid;  /**< Must be set to true if subType is being passed */
  qmiLocLockSubInfoEnumT_v02 subType;
  /**<   Subscription to which Lock Type must be applied.
 Values: \n
      - eQMI_LOC_LOCK_DV_SUB (1) --  Lock Dedicated Voice subscription (DV sub) \n
      - eQMI_LOC_LOCK_DD_SUB (2) --  Lock Dedicated Data subscription (DD sub) \n
      - eQMI_LOC_LOCK_ALL_SUB (3) --  Lock all subscriptions
 */

  /* Optional */
  /*  Lock Client */
  uint8_t lockClient_valid;  /**< Must be set to true if lockClient is being passed */
  qmiLocLockClientMaskT_v02 lockClient;
  /**<   The client(s) who have been locked to the request position.
 If specified, the control point ignores engineLockState.
 Values: \n
      - QMI_LOC_LOCK_CLIENT_MASK_AFW (0x00000001) --  Lock AFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_NFW (0x00000002) --  Lock NFW client \n
      - QMI_LOC_LOCK_CLIENT_MASK_PRIVILEGED (0x00000004) --  Lock privileged client
 */
}qmiLocEventEngineLockStateIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to receive position reports. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocStartListenPositionReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to stop receiving position reports. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocStopListenPositionReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSYSTEMINFOENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_UNDEFINED_INFO_V02 = 0, /**<  Undefined \n */
  eQMI_LOC_NEXT_LEAP_SECOND_INFO_V02 = 1, /**<  Information about next (upcoming) leap second  */
  QMILOCSYSTEMINFOENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocSystemInfoEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t gpsTimeCurrent_valid;
  /**<   Specifies whether the gpsTimeCurrent field contains
        a valid value. */

  qmiLocGPSTimeStructT_v02 gpsTimeCurrent;
  /**<   \vspace{0.06in} \n The number of weeks since Jan. 5, 1980, and
       milliseconds into the current week. */

  uint8_t leapSecondsCurrent_valid;
  /**<   Specifies whether the leapSecondsCurrent field contains
        a valid value.*/

  uint8_t leapSecondsCurrent;
  /**<   Current leap second information.\n
       - Units -- Seconds */

  uint8_t gpsTimeNextLsEvent_valid;
  /**<   Specifies whether the gpsTimeNextLsEvent field contains
        a valid value*/

  qmiLocGPSTimeStructT_v02 gpsTimeNextLsEvent;
  /**<   \vspace{0.06in} \n The number of weeks since Jan. 5, 1980, and
         milliseconds into the week for next leap-second change event.
         Reported only when receiver has information
         on upcoming change event. */

  uint8_t leapSecondsNext_valid;
  /**<   Specifies whether the leapSecondsNext field contains
       a valid value*/

  uint8_t leapSecondsNext;
  /**<   Upcoming leap second information.
         Reported only when receiver has information
         on upcoming change event.\n
         - Units -- Seconds */
}qmiLocNextLeapSecondInfoStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Generic request used by the control point to query about system information. */
typedef struct {

  /* Mandatory */
  /*  System Information */
  qmiLocSystemInfoEnumT_v02 systemInfo;
  /**<   System info being requested.
 Values: \n
      - eQMI_LOC_UNDEFINED_INFO (0) --  Undefined \n
      - eQMI_LOC_NEXT_LEAP_SECOND_INFO (1) --  Information about next (upcoming) leap second
 */
}qmiLocSystemInfoReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Generic request used by the control point to query about system information. */
typedef struct {

  /* Mandatory */
  /*  System Information */
  qmiLocSystemInfoEnumT_v02 systemInfo;
  /**<   System information being requested.
 Values: \n
      - eQMI_LOC_UNDEFINED_INFO (0) --  Undefined \n
      - eQMI_LOC_NEXT_LEAP_SECOND_INFO (1) --  Information about next (upcoming) leap second
 */

  /* Optional */
  /*  Next Leap Second Information */
  uint8_t nextLeapSecondInfo_valid;  /**< Must be set to true if nextLeapSecondInfo is being passed */
  qmiLocNextLeapSecondInfoStructT_v02 nextLeapSecondInfo;
  /**<   \n Upcoming leap second information.
       Reported only when the receiver has information
       on an upcoming leap second change event.*/
}qmiLocSystemInfoIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCCONSTELLATIONSTATUSENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY_V02 = 0, /**<  Mandatory constellation, always enabled \n */
  eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY_V02 = 1, /**<  Enabled internally by the system software \n */
  eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT_V02 = 2, /**<  Enabled by the external client \n */
  eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED_V02 = 100, /**<  Constellation not supported \n */
  eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY_V02 = 101, /**<  Disabled internally by the system software \n */
  eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT_V02 = 102, /**<  Disabled by the external client \n */
  eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY_V02 = 103, /**<  Could not be enabled due to memory allocation failure  */
  QMILOCCONSTELLATIONSTATUSENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocConstellationStatusEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the GNSS constellation
                      configuration. */
typedef struct {

  /* Mandatory */
  /*  Get Constellation Configuration Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the constellation configuration query request. \n
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  GPS Constellation Status */
  uint8_t gps_status_valid;  /**< Must be set to true if gps_status is being passed */
  qmiLocConstellationStatusEnumT_v02 gps_status;
  /**<   Specifies the enablement status of GPS. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */

  /* Optional */
  /*  GLONASS Constellation Status */
  uint8_t glonass_status_valid;  /**< Must be set to true if glonass_status is being passed */
  qmiLocConstellationStatusEnumT_v02 glonass_status;
  /**<   Specifies the enablement status of GLONASS. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */

  /* Optional */
  /*  BDS Constellation Status */
  uint8_t bds_status_valid;  /**< Must be set to true if bds_status is being passed */
  qmiLocConstellationStatusEnumT_v02 bds_status;
  /**<   Specifies the enablement status of BDS. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */

  /* Optional */
  /*  QZSS Constellation Status */
  uint8_t qzss_status_valid;  /**< Must be set to true if qzss_status is being passed */
  qmiLocConstellationStatusEnumT_v02 qzss_status;
  /**<   Specifies the enablement status of QZSS. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */

  /* Optional */
  /*  Galileo Constellation Status */
  uint8_t galileo_status_valid;  /**< Must be set to true if galileo_status is being passed */
  qmiLocConstellationStatusEnumT_v02 galileo_status;
  /**<   Specifies the enablement status of Galileo. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */

  /* Optional */
  /*  NavIC Constellation Status */
  uint8_t navic_status_valid;  /**< Must be set to true if navic_status is being passed */
  qmiLocConstellationStatusEnumT_v02 navic_status;
  /**<   Specifies the enablement status of NavIC. \n
 Values: \n
      - eQMI_LOC_CONSTELLATION_ENABLED_MANDATORY (0) --  Mandatory constellation, always enabled \n
      - eQMI_LOC_CONSTELLATION_ENABLED_INTERNALLY (1) --  Enabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_ENABLED_BY_CLIENT (2) --  Enabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NOT_SUPPORTED (100) --  Constellation not supported \n
      - eQMI_LOC_CONSTELLATION_DISABLED_INTERNALLY (101) --  Disabled internally by the system software \n
      - eQMI_LOC_CONSTELLATION_DISABLED_BY_CLIENT (102) --  Disabled by the external client \n
      - eQMI_LOC_CONSTELLATION_DISABLED_NO_MEMORY (103) --  Could not be enabled due to memory allocation failure
 */
}qmiLocGetConstellationConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to enable position injection
                      in test mode. */
typedef struct {

  /* Mandatory */
  /*  Enable/Disable Test Mode */
  uint8_t enableTestMode;
  /**<   Specifies whether the test mode is enabled.
       If the control point has already enabled the test mode
       then this command has no effect */
}qmiLocEnablePositionInjectionTestModeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCENABLEPOSITIONINJECTIONTESTMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_TEST_MODE_UNKNOWN_V02 = 0, /**<  Test mode in unknown state \n */
  eQMI_LOC_TEST_MODE_ENABLED_V02 = 1, /**<  Test mode is enabled \n */
  eQMI_LOC_TEST_MODE_DISABLED_V02 = 2, /**<  Test mode is disbled \n */
  eQMI_LOC_TEST_MODE_ALREADY_ENABLED_V02 = 3, /**<  Test mode is already enabled \n */
  eQMI_LOC_TEST_MODE_ALREADY_DISABLED_V02 = 4, /**<  Test mode is already disabled  */
  QMILOCENABLEPOSITIONINJECTIONTESTMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocEnablePositionInjectionTestModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to enable position injection
                      in test mode. */
typedef struct {

  /* Mandatory */
  /*  Position Injection Test Mode Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of enable position injection test mode request. \n
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Test Mode State */
  uint8_t testModeState_valid;  /**< Must be set to true if testModeState is being passed */
  qmiLocEnablePositionInjectionTestModeEnumT_v02 testModeState;
  /**<   State of the test mode. \n
 Values: \n
      - eQMI_LOC_TEST_MODE_UNKNOWN (0) --  Test mode in unknown state \n
      - eQMI_LOC_TEST_MODE_ENABLED (1) --  Test mode is enabled \n
      - eQMI_LOC_TEST_MODE_DISABLED (2) --  Test mode is disbled \n
      - eQMI_LOC_TEST_MODE_ALREADY_ENABLED (3) --  Test mode is already enabled \n
      - eQMI_LOC_TEST_MODE_ALREADY_DISABLED (4) --  Test mode is already disabled
 */
}qmiLocEnablePositionInjectionTestModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject a test position. */
typedef struct {

  /* Mandatory */
  /*  Latitude */
  double latitude;
  /**<   Latitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -90.0 to 90.0      \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude
       */

  /* Mandatory */
  /*  Longitude */
  double longitude;
  /**<   Longitude (specified in WGS84 datum). \n
       - Type -- Floating point \n
       - Units -- Degrees \n
       - Range -- -180.0 to 180.0   \n
         - Positive values indicate eastern longitude \n
         - Negative values indicate western longitude
   */

  /* Mandatory */
  /*  Circular Horizontal Uncertainty */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units - Meters */

  /* Mandatory */
  /*  UTC Timestamp */
  uint64_t timestampUtc;
  /**<   - Units - Milliseconds since Jan. 1, 1970
     */

  /* Optional */
  /*  Position Source */
  uint8_t positionSource_valid;  /**< Must be set to true if positionSource is being passed */
  qmiLocPositionSourceEnumT_v02 positionSource;
  /**<   Values: \n
      - eQMI_LOC_POS_SRC_GNSS (1) --  Source of the position is GNSS
 */
}qmiLocInjectTestPositionReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject a test position. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the injected test position.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocInjectTestPositionIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to upload observed BS data. */
typedef struct {

  /* Mandatory */
  /*  Number of Cells Available */
  uint16_t numCellsAvailable;
  /**<    BS observed data cells available.
        - Range -- 1 to 65535 */
}qmiLocEventBsObsDataServiceReqIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to request the BS observed location
                     data from TLE. */
typedef struct {

  /* Optional */
  /*  UTC Timestamp */
  uint8_t timestampUtc_valid;  /**< Must be set to true if timestampUtc is being passed */
  uint64_t timestampUtc;
  /**<   UTC timestamp. \n
       - Units -- Milliseconds (since Jan. 1, 1970) */

  /* Optional */
  /*  Number of Cells Requested to Upload */
  uint8_t numCellsUpload_valid;  /**< Must be set to true if numCellsUpload is being passed */
  uint16_t numCellsUpload;
  /**<    Number of cells requested to upload.\n
        - Range -- 1 to 65535 \n
        Default is to upload all cells if this TLV is not included. */
}qmiLocGetBsObsDataReqMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocBsObservedDataValidMaskT_v02;
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_GPSWEEK_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000001ull) /**<  GPS week field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_GPSMSEC_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000002ull) /**<  GPS milliseconds field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_LATITUDE_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000004ull) /**<  Latitude field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_LONGITUDE_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000008ull) /**<  Longitude field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HOR_UNC_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000010ull) /**<  Horizontal Uncertainty field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_ALTITUDE_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000020ull) /**<  Altitude field is valid.\n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_ALT_UNC_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000040ull) /**<  Altitude uncertainty field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_SPEED_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000080ull) /**<  Speed field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_SPEED_UNC_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000100ull) /**<  Speed uncertainty field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HEADING_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000200ull) /**<  Heading field is valid. \n */
#define QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HEADING_UNC_V02 ((qmiLocBsObservedDataValidMaskT_v02)0x00000400ull) /**<  Heading uncertainty field is valid.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocBsObservedDataValidMaskT_v02 validMask;
  /**<   Bitmask indicating which of the fields in this TLV are valid. \n
 Valid bitmasks: \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_GPSWEEK (0x00000001) --  GPS week field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_GPSMSEC (0x00000002) --  GPS milliseconds field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_LATITUDE (0x00000004) --  Latitude field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_LONGITUDE (0x00000008) --  Longitude field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HOR_UNC (0x00000010) --  Horizontal Uncertainty field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_ALTITUDE (0x00000020) --  Altitude field is valid.\n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_ALT_UNC (0x00000040) --  Altitude uncertainty field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_SPEED (0x00000080) --  Speed field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_SPEED_UNC (0x00000100) --  Speed uncertainty field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HEADING (0x00000200) --  Heading field is valid. \n
      - QMI_LOC_BS_OBSERVED_DATA_MASK_VALID_HEADING_UNC (0x00000400) --  Heading uncertainty field is valid.
 */

  qmiLocFdclCellIdStructT_v02 cellId;
  /**<   Cell ID for this record. */

  uint16_t gpsWeek;
  /**<   GPS week. \n
       - Units -- Weeks (since Jan. 1, 1970) */

  uint32_t gpsMilliseconds;
  /**<   GPS milliseconds. \n
       - Units -- Milliseconds (since Jan. 1, 1970) */

  uint32_t bsLocalTimestamp;
  /**<   Last observed local timestamp for the cell. */

  int32_t posDeltaTime;
  /**<   Delta time between position and cell ID detection. \n
       - Units -- Milliseconds */

  float speed;
  /**<   Horizontal speed. \n
       - Units -- Meters per second */

  float speedUnc;
  /**<   Horizontal speed uncertainty. \n
       - Units -- Meters per second */

  double heading;
  /**<   Heading. \n
         - Units -- Radian */

  double headingUnc;
  /**<   Heading uncertainty. \n
       - Units -- Radian */

  qmiLocBsBestPositionStructT_v02 bsBestPosition;
  /**<   Base station best position. */
}qmiLocBsObservedDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request the BS observed location
                     data from TLE. */
typedef struct {

  /* Mandatory */
  /*  Get BS Observed Data Request Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the BS observed data request. \n
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Base Station List */
  uint32_t bsData_len;  /**< Must be set to # of elements in bsData */
  qmiLocBsObservedDataStructT_v02 bsData[QMI_LOC_FDCL_BS_LIST_MAX_SIZE_V02];
  /**<   A list of base station IDs for the FDCL request. */

  /* Optional */
  /*  More BS Data is Available */
  uint8_t moreBsAvailable_valid;  /**< Must be set to true if moreBsAvailable is being passed */
  uint8_t moreBsAvailable;
  /**<   Indicates whether more base station data is available. \n
       - 0x00 (FALSE) -- No more base station data is available. \n
       - 0x01 (TRUE)  -- More base station data is available. \n
       If not specified, moreBsAvailable defaults to FALSE.
  */
}qmiLocGetBsObsDataIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCEPHUPDATEACTIONENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_UPDATE_EPH_SRC_UNKNOWN_V02 = 0, /**<  Update ephemeris; source of ephemeris is unknown \n */
  eQMI_LOC_UPDATE_EPH_SRC_OTA_V02 = 1, /**<  Update ephemeris; source of ephemeris is OTA \n */
  eQMI_LOC_UPDATE_EPH_SRC_NETWORK_V02 = 2, /**<  Update ephemeris; source of ephemeris is network \n */
  eQMI_LOC_UPDATE_EPH_SRC_MAX_V02 = 999, /**<  Max value for update ephemeris action; do not use. \n */
  eQMI_LOC_DELETE_EPH_SRC_UNKNOWN_V02 = 1000, /**<  Delete previous ephemeris from unknown source \n */
  eQMI_LOC_DELETE_EPH_SRC_NETWORK_V02 = 1001, /**<  Delete previous ephemeris from network \n */
  eQMI_LOC_DELETE_EPH_SRC_OTA_V02 = 1002, /**<  Delete previous ephemeris from OTA \n */
  eQMI_LOC_DELETE_EPH_SRC_MAX_V02 = 1999, /**<  Maximum value for delete ephemeris action; do not use.  */
  QMILOCEPHUPDATEACTIONENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocEphUpdateActionEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   GNSS SV ID.
       Range:\n
       - GPS --    1 to 32 \n
       - QZSS --   193 to 197 \n
       - BDS --    201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --  401 to 414 \n
      */

  qmiLocEphUpdateActionEnumT_v02 updateAction;
  /**<   Specifies the source of ephemeris. \n
 - Type -- int32 enum \n
 Values: \n
      - eQMI_LOC_UPDATE_EPH_SRC_UNKNOWN (0) --  Update ephemeris; source of ephemeris is unknown \n
      - eQMI_LOC_UPDATE_EPH_SRC_OTA (1) --  Update ephemeris; source of ephemeris is OTA \n
      - eQMI_LOC_UPDATE_EPH_SRC_NETWORK (2) --  Update ephemeris; source of ephemeris is network \n
      - eQMI_LOC_UPDATE_EPH_SRC_MAX (999) --  Max value for update ephemeris action; do not use. \n
      - eQMI_LOC_DELETE_EPH_SRC_UNKNOWN (1000) --  Delete previous ephemeris from unknown source \n
      - eQMI_LOC_DELETE_EPH_SRC_NETWORK (1001) --  Delete previous ephemeris from network \n
      - eQMI_LOC_DELETE_EPH_SRC_OTA (1002) --  Delete previous ephemeris from OTA \n
      - eQMI_LOC_DELETE_EPH_SRC_MAX (1999) --  Maximum value for delete ephemeris action; do not use.
 */

  uint16_t IODE;
  /**<   Issue of data ephemeris used (unitless). \n
         - GPS -- IODE 8 bits \n
         - BDS -- AODE 5 bits \n
         - Galileo -- SIS IOD 10 bits */

  double aSqrt;
  /**<   Square root of semi-major axis. \n
       - Units -- Square root of meters */

  double deltaN;
  /**<   Mean motion difference from computed value. \n
       - Units -- Radians per second */

  double m0;
  /**<   Mean anomaly at reference time. \n
       - Units -- Radians */

  double eccentricity;
  /**<   Eccentricity (unitless).
  */

  double omega0;
  /**<   Longitude of ascending node of orbital plane at the weekly epoch. \n
       - Units -- Radians */

  double i0;
  /**<   Inclination angle at reference time. \n
       - Units -- Radians */

  double omega;
  /**<   Argument of perigee. \n
        Units -- Radians */

  double omegaDot;
  /**<   Rate of change of right ascension. \n
      - Units -- Radians/second */

  double iDot;
  /**<   Rate of change of inclination angle. \n
       - Units -- Radians/second */

  double cUc;
  /**<   Amplitude of the cosine harmonic correction term to the argument of latitude. \n
       - Units -- Radians */

  double cUs;
  /**<   Amplitude of the sine harmonic correction term to the argument of latitude. \n
       - Units -- Radians */

  double cRc;
  /**<   Amplitude of the cosine harmonic correction term to the orbit radius. \n
       - Units -- Meters */

  double cRs;
  /**<   Amplitude of the sine harmonic correction term to the orbit radius. \n
       - Units -- Meters */

  double cIc;
  /**<   Amplitude of the cosine harmonic correction term to the angle of inclination. \n
       - Units -- Radians */

  double cIs;
  /**<   Amplitude of the sine harmonic correction term to the angle of inclination. \n
       - Units -- Radians */

  uint32_t toe;
  /**<   Reference time of ephemeris. \n
       - Units -- Seconds */

  uint32_t toc;
  /**<   Clock data reference time of week.  \n
       - Units -- Seconds */

  double af0;
  /**<   Clock bias correction coefficient. \n
       - Units -- Seconds */

  double af1;
  /**<   Clock drift coefficient. \n
       - Units -- Seconds/second */

  double af2;
  /**<   Clock drift rate correction coefficient. \n
       - Units -- Seconds/seconds^2 */
}qmiLocEphGnssDataStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocEphGnssDataStructT_v02 commonEphemerisData;
  /**<   Common ephemeris data.   */

  uint8_t signalHealth;
  /**<   Three bitmask of signal health, where the set bit indicates an unhealthy signal.  \n
       Bit 0 -- L5 signal health. \n
       Bit 1 -- L2 signal health. \n
       Bit 2 -- L1 signal health. \n
       */

  uint8_t URAI;
  /**<   User range accuracy index (unitless).
    */

  uint8_t codeL2;
  /**<   Indicates which codes are commanded ON for the L2 channel (2-bits). \n
       Values: \n
       - 00 -- Reserved \n
       - 01 -- P code ON \n
       - 10 -- C/A code ON */

  uint8_t dataFlagL2P;
  /**<   L2 P-code indication flag.
       Value 1 indicates that the navigation data stream was commanded OFF on the P-code of the L2 channel. */

  double tgd;
  /**<   Time of group delay. \n
       - Units -- Seconds */

  uint8_t fitInterval;
  /**<   Indicates the curve-fit interval used by the CS.
       Values: \n
       - 0 -- Four hours \n
       - 1 -- Greater than four hours */

  uint16_t IODC;
  /**<   Issue of data, clock (unitless).
    */
}qmiLocGpsEphemerisT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends GPS ephemeris report for all signal types (L1/L2/L5)
                    to the control point. */
typedef struct {

  /* Mandatory */
  /*  GPS Ephemeris Data */
  uint32_t gpsEphemerisList_len;  /**< Must be set to # of elements in gpsEphemerisList */
  qmiLocGpsEphemerisT_v02 gpsEphemerisList[QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02];
  /**<   \n GPS ephemeris parameters. */

  /* Optional */
  /*  GPS Time When Ephemeris Report Is Sent */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<    */
}qmiLocGpsEphemerisReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t gnssSvId;
  /**<   GNSS SV ID. \n
       - Type -- uint16 \n
       - Range -- 65 to 96 (if known). When the slot number to SV ID mapping is unknown, set to 255. */

  qmiLocEphUpdateActionEnumT_v02 updateAction;
  /**<   Specifies the source of ephemeris. \n
 - Type -- int32 enum \n
 Values: \n
      - eQMI_LOC_UPDATE_EPH_SRC_UNKNOWN (0) --  Update ephemeris; source of ephemeris is unknown \n
      - eQMI_LOC_UPDATE_EPH_SRC_OTA (1) --  Update ephemeris; source of ephemeris is OTA \n
      - eQMI_LOC_UPDATE_EPH_SRC_NETWORK (2) --  Update ephemeris; source of ephemeris is network \n
      - eQMI_LOC_UPDATE_EPH_SRC_MAX (999) --  Max value for update ephemeris action; do not use. \n
      - eQMI_LOC_DELETE_EPH_SRC_UNKNOWN (1000) --  Delete previous ephemeris from unknown source \n
      - eQMI_LOC_DELETE_EPH_SRC_NETWORK (1001) --  Delete previous ephemeris from network \n
      - eQMI_LOC_DELETE_EPH_SRC_OTA (1002) --  Delete previous ephemeris from OTA \n
      - eQMI_LOC_DELETE_EPH_SRC_MAX (1999) --  Maximum value for delete ephemeris action; do not use.
 */

  uint8_t bnHealth;
  /**<   SV health flags.
       Values: \n
       - 0 -- Healthy \n
       - 1 -- Unhealthy */

  uint8_t lnHealth;
  /**<   Ln SV health flags; GLONASS-M.
       Values: \n
       - 0 -- Healthy \n
       - 1 -- Unhealthy */

  uint8_t tb;
  /**<   Index of a time interval within current day according to UTC(SU) + 03 hours 00 min (unitless). \n
    */

  uint8_t ft;
  /**<   SV accuracy index (unitless). \n
    */

  uint8_t gloM;
  /**<   GLONASS-M flag. Values: \n
       - 0 -- GLONASS \n
       - 1 -- GLONASS-M */

  uint8_t enAge;
  /**<   Characterizes age of current information. \n
       - Units -- Days */

  uint8_t gloFrequency;
  /**<   GLONASS frequency number + 8. \n
       - Range -- 1 to 14
  */

  uint8_t p1;
  /**<   Time interval between two adjacent values of tb parameter. \n
       - Units -- Minutes */

  uint8_t p2;
  /**<   Flag of oddness (1) or evenness (0) of the value of tb
       for intervals 30 or 60 minutes. */

  float deltaTau;
  /**<   Time difference between navigation RF signal transmitted in L2 sub-band \n
       and aviation RF signal transmitted in L1 sub-band. \n
      - Units -- Seconds */

  double position[3];
  /**<   Satellite XYZ position. \n
       - Type -- array of doubles \n
       - Units -- Meters */

  double velocity[3];
  /**<   Satellite XYZ velocity. \n
       - Type -- Array of doubles \n
       - Units -- Meters per second */

  double acceleration[3];
  /**<   Satellite XYZ sola-luni acceleration. \n
       - Type -- Array of doubles \n
       - Units -- Meters per second^2 */

  float tauN;
  /**<   Satellite clock correction relative to GLONASS time. \n
       - Units -- Seconds */

  float gamma;
  /**<   Relative deviation of predicted carrier frequency value
       from nominal value at the instant tb (unitless). \n
      */

  double toe;
  /**<   Complete ephemeris time, including N4, NT, and Tb.
       [(N4-1)*1461 + (NT-1)]*86400 + tb*900 \n
       - Units -- Seconds */

  uint16_t nt;
  /**<   Current date, calendar number of days within four-year interval.
       Starting from the 1st of January in a leap year. \n
       - Units -- Days */
}qmiLocGloEphemerisT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends GLONASS ephemeris report to the control point. */
typedef struct {

  /* Mandatory */
  /*  GLONASS Ephemeris Data */
  uint32_t gloEphemerisList_len;  /**< Must be set to # of elements in gloEphemerisList */
  qmiLocGloEphemerisT_v02 gloEphemerisList[QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02];
  /**<   GLONASS ephemeris parameters. */

  /* Optional */
  /*  GPS Time When Ephemeris Report Is Sent */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<   \n GPS system time. */
}qmiLocGloEphemerisReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocEphGnssDataStructT_v02 commonEphemerisData;
  /**<   Common ephemeris data.   */

  uint8_t svHealth;
  /**<   Satellite health information applied to both B1 and B2 (SatH1).
       Values: \n
       - 0 -- Healthy \n
       - 1 -- Unhealthy */

  uint8_t AODC;
  /**<   Age of data clock. \n
       - Units -- Hours */

  double tgd1;
  /**<   Equipment group delay differential on B1 signal. \n
       - Units -- Nanoseconds */

  double tgd2;
  /**<   Equipment group delay differential on B2 signal. \n
      - Units -- Nanoseconds */

  uint8_t URAI;
  /**<   User range accuracy index (four bits), unitless. \n
     */
}qmiLocBdsEphemerisT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the BDS ephemeris report to the control point. */
typedef struct {

  /* Mandatory */
  /*  BDS Ephemeris Data */
  uint32_t bdsEphemerisList_len;  /**< Must be set to # of elements in bdsEphemerisList */
  qmiLocBdsEphemerisT_v02 bdsEphemerisList[QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  GPS Time When Ephemeris Report Is Sent */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<    */
}qmiLocBdsEphemerisReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGALEPHSOURCESIGNAL_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GAL_EPH_SIGNAL_SRC_UNKNOWN_V02 = 0, /**<  Galileo signal is unknown \n  */
  eQMI_LOC_GAL_EPH_SIGNAL_SRC_E1B_V02 = 1, /**<  Galileo signal is E1B \n */
  eQMI_LOC_GAL_EPH_SIGNAL_SRC_E5A_V02 = 2, /**<  Galileo signal is E5A \n */
  eQMI_LOC_GAL_EPH_SIGNAL_SRC_E5B_V02 = 3, /**<  Galileo signal is E5B  */
  QMILOCGALEPHSOURCESIGNAL_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGalEphSourceSignal_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocEphGnssDataStructT_v02 commonEphemerisData;
  /**<   Common ephemeris data.   */

  qmiLocGalEphSourceSignal_v02 dataSourceSignal;
  /**<   Galileo signal source. \n
 Values: \n
      - eQMI_LOC_GAL_EPH_SIGNAL_SRC_UNKNOWN (0) --  Galileo signal is unknown \n
      - eQMI_LOC_GAL_EPH_SIGNAL_SRC_E1B (1) --  Galileo signal is E1B \n
      - eQMI_LOC_GAL_EPH_SIGNAL_SRC_E5A (2) --  Galileo signal is E5A \n
      - eQMI_LOC_GAL_EPH_SIGNAL_SRC_E5B (3) --  Galileo signal is E5B  */

  uint8_t sisIndex;
  /**<   Signal-in-space index for dual frequency E1-E5b/E5a based on dataSignalSource (unitless). \n
    */

  double bgdE1E5a;
  /**<   E1-E5a broadcast group delay from F/Nav (E5A). \n
       - Units -- Seconds */

  double bgdE1E5b;
  /**<   E1-E5b broadcast group delay from I/Nav (E1B or E5B). \n
       For E1B or E5B signal, both bgdE1E5a and bgdE1E5b are valid. \n
       For E5A signal, only bgdE1E5a is valid. \n
       Signal source identified using dataSignalSource. \n
       - Units -- Seconds */

  uint8_t svHealth;
  /**<   SV health status of the signal identified by dataSourceSignal. \n
       Values: \n
       - Only 3 bits for E5a (F/NAV) \n
       - 6 bits for E1B, E5b (I/NAV) \n
         - F/NAV Bit 0 is the DVS (Data Validity Status) bit \n
         - F/NAV Bits 1 and 2 are HS bits (Signal Health Status) \n
         - I/NAV Bits 0, 2, 3 are for E1B, bits 1, 4, 5 are for E5B \n
         - I/NAV Bit 0, 1 are the DVS bit \n
         - I/NAV Bit 2, 3, 4, 5 are the HS bits \n
       - A signal is only useful when all three bits for a component are 0. */
}qmiLocGalEphemerisT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the Galileo ephemeris report to the control point. */
typedef struct {

  /* Mandatory */
  /*  Galileo Ephemeris Data */
  uint32_t galEphemerisList_len;  /**< Must be set to # of elements in galEphemerisList */
  qmiLocGalEphemerisT_v02 galEphemerisList[QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  GPS Time When Ephemeris Report Is Sent */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<   */
}qmiLocGalEphemerisReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the QZSS ephemeris report to the control point. */
typedef struct {

  /* Mandatory */
  /*  QZSS Ephemeris Data */
  uint32_t qzssEphemerisList_len;  /**< Must be set to # of elements in qzssEphemerisList */
  qmiLocGpsEphemerisT_v02 qzssEphemerisList[QMI_LOC_EPHEMERIS_LIST_MAX_SIZE_V02];

  /* Optional */
  /*  GPS Time When Ephemeris Report Is Sent */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<   */
}qmiLocQzssEphemerisReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to put the engine in or out of a
                     constrained Time Unc mode, where the engine keeps its Time
                     Unc below the specified constraint. */
typedef struct {

  /* Mandatory */
  /*  Tunc Constraint On */
  uint8_t tuncConstraintOn;
  /**<   Specifies the constrained tunc mode desired by the control point.
       Values:\n
       - True -- Engine maintains Tunc below specified constraint. \n
       - False -- Engine does not maintain Tunc.
        */

  /* Optional */
  /*  Tunc Constraint */
  uint8_t tuncConstraint_valid;  /**< Must be set to true if tuncConstraint is being passed */
  float tuncConstraint;
  /**<   If tuncConstraint is set to ON, the engine maintains its time
       uncertainty below the specified constraint in tuncConstraint. The units
       are in ms. If this parameter is not specified and tuncConstraint is set
       to ON, the engine picks up the default tuncConstraint.
       */

  /* Optional */
  /*  Energy Budget */
  uint8_t energyBudget_valid;  /**< Must be set to true if energyBudget is being passed */
  uint32_t energyBudget;
  /**<   If tuncConstraintOn is set to ON and energyBudget is specified, the
       engine uses Energy Budget as the maximum energy to use while keeping the
       engine in constrained tunc mode. If no energy budget is specified, the
       engine assumes that the budget is infinite. \n
       - Units -- 0.1 milliwatt second
       */
}qmiLocSetConstrainedTuncModeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to put the engine in or out of a
                     constrained Time Unc mode, where the engine keeps its Time
                     Unc below the specified constraint. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the set tunc constrained mode request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocSetConstrainedTuncModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to enable position-assisted clock
                     estimation mode in the location engine. */
typedef struct {

  /* Mandatory */
  /*  enablePositionAssistedClockEst */
  uint8_t enablePositionAssistedClockEst;
  /**<   Specifies the position-assisted clock estimation mode desired by the control point.
         Values: \n
         - True -- Engine enables position-assisted clock estimation mode. \n
         - False -- Engine disables position-assisted clock estimation mode.
        */
}qmiLocEnablePositionAssistedClockEstReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to enable position-assisted clock
                     estimation mode in the location engine. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the enable position-assisted clock estimator mode request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */
}qmiLocEnablePositionAssistedClockEstIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query the energy consumed by
                     the GNSS engine.  */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocQueryGNSSEnergyConsumedReqMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the energy consumed by
                     the GNSS engine.  */
typedef struct {

  /* Mandatory */
  /*  Energy Consumed Since Last Boot */
  uint64_t energyConsumedSinceLastBoot;
  /**<   Energy consumed by the GNSS engine since bootup in units of 0.1 milliwatt seconds.
       A value of 0xffffffffffffffff indicates an invalid reading.
       */

  /* Mandatory */
  /*  Energy Consumed Since First Boot */
  uint64_t energyConsumedSinceFirstBoot;
  /**<   Energy consumed by the GNSS engine since the first bootup in units of 0.1 milliwatt seconds.
       A value of 0xffffffffffffffff indicates an invalid reading.
       */
}qmiLocQueryGNSSEnergyConsumedIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocEventReportMaskT_v02;
#define QMI_LOC_DELETE_GPS_EPHEMERIS_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000001ull) /**<  GPS ephemeris parameters have been deleted. \n */
#define QMI_LOC_DELETE_GLO_EPHEMERIS_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000002ull) /**<  GLONASS ephemeris parameters have been deleted.\n  */
#define QMI_LOC_DELETE_BDS_EPHEMERIS_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000004ull) /**<  BDS ephemeris parameters have been deleted.\n  */
#define QMI_LOC_DELETE_GAL_EPHEMERIS_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000008ull) /**<  Galileo ephemeris parameters have been deleted.\n  */
#define QMI_LOC_DELETE_QZSS_EPHEMERIS_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000010ull) /**<  QZSS ephemeris parameters have been deleted. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_1_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000020ull) /**<  Reserved delete ephemeris bit 1.\n  */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_2_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000040ull) /**<  Reserved delete ephemeris bit 2. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_3_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000080ull) /**<  Reserved delete ephemeris bit 3. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_4_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000100ull) /**<  Reserved delete ephemeris bit 4. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_5_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000200ull) /**<  Reserved delete ephemeris bit 5. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_6_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000400ull) /**<  Reserved delete ephemeris bit 6. \n */
#define QMI_LOC_DELETE_RESERVED_EPHEMERIS_7_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00000800ull) /**<  Reserved delete ephemeris bit 7. \n */
#define QMI_LOC_DELETE_GPS_SV_POLY_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00001000ull) /**<  GPS SV polynomials have been deleted.\n  */
#define QMI_LOC_DELETE_GLO_SV_POLY_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00002000ull) /**<  GLONASS SV polynomials have been deleted.  */
#define QMI_LOC_DELETE_BDS_SV_POLY_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00004000ull) /**<  BDS SV polynomials have been deleted.  */
#define QMI_LOC_DELETE_GAL_SV_POLY_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00008000ull) /**<  Galileo SV polynomials have been deleted.\n  */
#define QMI_LOC_DELETE_QZSS_SV_POLY_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00010000ull) /**<  QZSS SV polynomials have been deleted. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_1_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00020000ull) /**<  Reserved delete SV poly bit 1.\n  */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_2_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00040000ull) /**<  Reserved delete SV poly bit 2. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_3_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00080000ull) /**<  Reserved delete SV poly bit 3. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_4_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00100000ull) /**<  Reserved delete SV poly bit 4. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_5_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00200000ull) /**<  Reserved delete SV poly bit 5. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_6_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00400000ull) /**<  Reserved delete SV poly bit 6. \n */
#define QMI_LOC_DELETE_RESERVED_SV_POLY_7_ALL_V02 ((qmiLocEventReportMaskT_v02)0x00800000ull) /**<  Reserved delete SV poly bit 7. \n */
#define QMI_LOC_DELETE_GPS_IONO_ALL_V02 ((qmiLocEventReportMaskT_v02)0x01000000ull) /**<  GPS IONO parameters have been deleted. \n */
#define QMI_LOC_DELETE_GLO_IONO_ALL_V02 ((qmiLocEventReportMaskT_v02)0x02000000ull) /**<  GLONASS IONO parameters have been deleted. \n */
#define QMI_LOC_DELETE_BDS_IONO_ALL_V02 ((qmiLocEventReportMaskT_v02)0x04000000ull) /**<  BDS IONO parameters have been deleted. \n */
#define QMI_LOC_DELETE_GAL_IONO_ALL_V02 ((qmiLocEventReportMaskT_v02)0x08000000ull) /**<  Galileo IONO parameters have been deleted.\n  */
#define QMI_LOC_DELETE_QZSS_IONO_ALL_V02 ((qmiLocEventReportMaskT_v02)0x10000000ull) /**<  QZSS IONO parameters have been deleted.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocSvSystemEnumT_v02 dataSource;
  /**<   Specifies the satellite system source of the ionospheric model.
 Values: \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite
 */

  float alpha0;
  /**<   Klobuchar model parameter alpha 0.\n
       - Unit -- Seconds
  */

  float alpha1;
  /**<   Klobuchar model parameter alpha 1.\n
       - Unit -- Seconds / Semi-circle
  */

  float alpha2;
  /**<   Klobuchar model parameter alpha 2.\n
       - Unit -- Seconds / Semi-circle^2
  */

  float alpha3;
  /**<   Klobuchar model parameter alpha 3.\n
       - Unit -- Seconds / semi-circle^3
  */

  float beta0;
  /**<   Klobuchar model parameter beta 0.\n
      - Unit -- Seconds
  */

  float beta1;
  /**<   Klobuchar Model parameter beta 1.\n
      - Unit -- Seconds / Semi-circle
  */

  float beta2;
  /**<   Klobuchar model parameter beta 2.\n
       - Unit -- Seconds / Semi-circle^2
  */

  float beta3;
  /**<   Klobuchar model parameter beta 3.\n
       - Unit -- Seconds / semi-circle^3
  */
}qmiLocKlobucharIonoModelT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends a report of modem events to the control point. */
typedef struct {

  /* Mandatory */
  /*  Event Report */
  qmiLocEventReportMaskT_v02 eventReport;
  /**<   Bitmask indicating the modem event.
 Valid bitmasks: \n
      - QMI_LOC_DELETE_GPS_EPHEMERIS_ALL (0x00000001) --  GPS ephemeris parameters have been deleted. \n
      - QMI_LOC_DELETE_GLO_EPHEMERIS_ALL (0x00000002) --  GLONASS ephemeris parameters have been deleted.\n
      - QMI_LOC_DELETE_BDS_EPHEMERIS_ALL (0x00000004) --  BDS ephemeris parameters have been deleted.\n
      - QMI_LOC_DELETE_GAL_EPHEMERIS_ALL (0x00000008) --  Galileo ephemeris parameters have been deleted.\n
      - QMI_LOC_DELETE_QZSS_EPHEMERIS_ALL (0x00000010) --  QZSS ephemeris parameters have been deleted. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_1_ALL (0x00000020) --  Reserved delete ephemeris bit 1.\n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_2_ALL (0x00000040) --  Reserved delete ephemeris bit 2. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_3_ALL (0x00000080) --  Reserved delete ephemeris bit 3. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_4_ALL (0x00000100) --  Reserved delete ephemeris bit 4. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_5_ALL (0x00000200) --  Reserved delete ephemeris bit 5. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_6_ALL (0x00000400) --  Reserved delete ephemeris bit 6. \n
      - QMI_LOC_DELETE_RESERVED_EPHEMERIS_7_ALL (0x00000800) --  Reserved delete ephemeris bit 7. \n
      - QMI_LOC_DELETE_GPS_SV_POLY_ALL (0x00001000) --  GPS SV polynomials have been deleted.\n
      - QMI_LOC_DELETE_GLO_SV_POLY_ALL (0x00002000) --  GLONASS SV polynomials have been deleted.
      - QMI_LOC_DELETE_BDS_SV_POLY_ALL (0x00004000) --  BDS SV polynomials have been deleted.
      - QMI_LOC_DELETE_GAL_SV_POLY_ALL (0x00008000) --  Galileo SV polynomials have been deleted.\n
      - QMI_LOC_DELETE_QZSS_SV_POLY_ALL (0x00010000) --  QZSS SV polynomials have been deleted. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_1_ALL (0x00020000) --  Reserved delete SV poly bit 1.\n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_2_ALL (0x00040000) --  Reserved delete SV poly bit 2. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_3_ALL (0x00080000) --  Reserved delete SV poly bit 3. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_4_ALL (0x00100000) --  Reserved delete SV poly bit 4. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_5_ALL (0x00200000) --  Reserved delete SV poly bit 5. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_6_ALL (0x00400000) --  Reserved delete SV poly bit 6. \n
      - QMI_LOC_DELETE_RESERVED_SV_POLY_7_ALL (0x00800000) --  Reserved delete SV poly bit 7. \n
      - QMI_LOC_DELETE_GPS_IONO_ALL (0x01000000) --  GPS IONO parameters have been deleted. \n
      - QMI_LOC_DELETE_GLO_IONO_ALL (0x02000000) --  GLONASS IONO parameters have been deleted. \n
      - QMI_LOC_DELETE_BDS_IONO_ALL (0x04000000) --  BDS IONO parameters have been deleted. \n
      - QMI_LOC_DELETE_GAL_IONO_ALL (0x08000000) --  Galileo IONO parameters have been deleted.\n
      - QMI_LOC_DELETE_QZSS_IONO_ALL (0x10000000) --  QZSS IONO parameters have been deleted.
 */

  /* Optional */
  /*  GPS System Time of Event Report */
  uint8_t gpsSystemTime_valid;  /**< Must be set to true if gpsSystemTime is being passed */
  qmiLocGnssTimeStructT_v02 gpsSystemTime;
  /**<   \n GPS time when the event report is sent. */

  /* Optional */
  /*  Klobuchar Ionospheric Model */
  uint8_t klobucharIonoModel_valid;  /**< Must be set to true if klobucharIonoModel is being passed */
  qmiLocKlobucharIonoModelT_v02 klobucharIonoModel;

  /* Optional */
  /*  GLONASS Time Scale Correction */
  uint8_t tauC_valid;  /**< Must be set to true if tauC is being passed */
  double tauC;
  /**<   GLONASS time scale correction to UTC time,
       as defined in the GLONASS ICD Edition 5.1 page 36. \n
      - Unit -- Seconds
  */

  /* Optional */
  /*  Leap Seconds */
  uint8_t leapSec_valid;  /**< Must be set to true if leapSec is being passed */
  int8_t leapSec;
  /**<   Leap seconds (GPS-UTC) from GPS.\n
      - Unit -- Seconds
  */

  /* Optional */
  /*  Features Mask */
  uint8_t featureStatusReport_valid;  /**< Must be set to true if featureStatusReport is being passed */
  qmiLocFeaturesStatusMaskT_v02 featureStatusReport;
  /**<   Bitmask indicating the modem feature status for
 features controlled with licenses.
 Valid bitmasks: \n
      - QMI_LOC_FEATURE_STATUS_CARRIER_PHASE (0x00000001) --  Carrier Phase feature status. \n
      - QMI_LOC_FEATURE_STATUS_SV_POLYNOMIALS (0x00000002) --  SV Polynomial reporting status.\n
      - QMI_LOC_FEATURE_STATUS_SV_EPHEMERIS (0x00000004) --  SV Ephemeris reporting status.\n
      - QMI_LOC_FEATURE_STATUS_SINGLE_FREQUENCY (0x00000008) --  GNSS Single Frequency status.\n
      - QMI_LOC_FEATURE_STATUS_MULTI_FREQUENCY (0x00000010) --  GNSS Multi Frequency status. \n
      - QMI_LOC_FEATURE_STATUS_TIME_FREQUENCY (0x00000020) --  Time and Frequency status.\n
      - QMI_LOC_FEATURE_STATUS_TIME_UNCERTAINTY (0x00000040) --  Time Uncertainty  status. \n
      - QMI_LOC_FEATURE_STATUS_CLOCK_ESTIMATE (0x00000080) --  Clock Estimate status. \n
 */
}qmiLocEventReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint16_t bpAmpI;
  /**<   GNSS BP amplitude I; for GLO, it is the average BP amplitude I.*/

  uint16_t bpAmpQ;
  /**<   GNSS BP amplitude Q ; for GLO, it is the average BP amplitude Q.   */

  int32_t jammerPwrDb;
  /**<   Jammer power metrics, in units of dB. */
}qmiLocMePerGnssRfStructType_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request the band measurement metrics.  */
typedef struct {

  /* Mandatory */
  /*  System Tick */
  uint64_t systemTick;
  /**<   System counter at which RF status is updated.*/

  /* Mandatory */
  /*  Band1 PGA Gain Db */
  int32_t band1PgaGainDb;
  /**<   GNSS Band1 RX path PGA gain in units of dB. \n
       - GEN9 (nominal values) -- 0 to +4 \n
       - Limit -- -12 to +18
   */

  /* Optional */
  /*  GPS L1ca RF Statistics */
  uint8_t gpsL1caRfStats_valid;  /**< Must be set to true if gpsL1caRfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 gpsL1caRfStats;
  /**<   GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 160-200 \n
       - Limit -- 89-356 \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  GloG1 RF Statistics */
  uint8_t gloG1RfStats_valid;  /**< Must be set to true if gloG1RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 gloG1RfStats;
  /**<   GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 120-180 \n
       - Limit -- 128-512   \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  BDS B1 RF Statistics */
  uint8_t bdsB1RfStats_valid;  /**< Must be set to true if bdsB1RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 bdsB1RfStats;
  /**<   GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 160-200 \n
       - Limit -- 75-582 \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  Galileo E1 RF Statistics */
  uint8_t galE1RfStats_valid;  /**< Must be set to true if galE1RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 galE1RfStats;
  /**<   GNSS BP amplitude in dB.\n
       - GEN9 (nominal values) -- 160-200 \n
       - Limit -- 75-582    \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  GPS L2 cRf Statistics */
  uint8_t gpsL2cRfStats_valid;  /**< Must be set to true if gpsL2cRfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 gpsL2cRfStats;
  /**<   GNSS BP amplitude in dB.\n
       - GEN9 (nominal values) -- 160-200 \n
       - Limit -- 89-356    \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  Glo G2 RF Statistics */
  uint8_t gloG2RfStats_valid;  /**< Must be set to true if gloG2RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 gloG2RfStats;
  /**<   GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 120-180 \n
       - Limit -- 128-512  \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  BDS B2 RF Statistics */
  uint8_t bdsB2RfStats_valid;  /**< Must be set to true if bdsB2RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 bdsB2RfStats;
  /**<   GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 160-200 \n
       - Limit -- 75-582     \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  Band 5 PGA Gain dB */
  uint8_t band5PgaGainDb_valid;  /**< Must be set to true if band5PgaGainDb is being passed */
  int32_t band5PgaGainDb;
  /**<   GNSS Band5 RX path PGA gain in units of dB. \n
       - GEN9 (nominal values) -- -4 to 0 \n
       - Limit -- -12 to +18
   */

  /* Optional */
  /*  GPS L5 RF Statistics */
  uint8_t gpsL5RfStats_valid;  /**< Must be set to true if gpsL5RfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 gpsL5RfStats;
  /**<   \n GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 60-100 \n
       - Limit -- 60-150 \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */

  /* Optional */
  /*  GalE5A RF Statistics */
  uint8_t galE5ARfStats_valid;  /**< Must be set to true if galE5ARfStats is being passed */
  qmiLocMePerGnssRfStructType_v02 galE5ARfStats;
  /**<   \n GNSS BP amplitude in dB. \n
       - GEN9 (nominal values) -- 60-100 \n
       - Limit -- 60-150  \n
       - Limit of l_JammerPwrDb -- -18 to 105 dB
  */
}qmiLocGetBandMeasurementMetricsIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCREQUESTPROTOCOLENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_CTRL_PLANE_V02 = 0, /**<  Cellular control plane requests the location \n */
  eQMI_LOC_SUPL_V02 = 1, /**<  SUPL requests the location \n  */
  eQMI_LOC_IMS_V02 = 2, /**<  IMS requests the location \n */
  eQMI_LOC_SIM_V02 = 3, /**<  SIM requests the location \n  */
  eQMI_LOC_MDT_V02 = 4, /**<  MDT requests the location \n  */
  eQMI_LOC_TLOC_V02 = 5, /**<  Trusted location requests the location \n */
  eQMI_LOC_OTHER_V02 = 6, /**<  Other protocol stack requests the location  */
  QMILOCREQUESTPROTOCOLENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocRequestProtocolEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCREQUESTORENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_REQUESTOR_CARRIER_V02 = 0, /**<  Wireless service provider \n  */
  eQMI_LOC_REQUESTOR_OEM_V02 = 1, /**<  Device manufacturer \n  */
  eQMI_LOC_REQUESTOR_MODEM_CHIPSET_VENDOR_V02 = 2, /**<  Modem chipset vendor \n */
  eQMI_LOC_REQUESTOR_GNSS_CHIPSET_VENDOR_V02 = 3, /**<  GNSS chipset vendor \n */
  eQMI_LOC_REQUESTOR_OTHER_CHIPSET_VENDOR_V02 = 4, /**<  Other chipset vendor \n */
  eQMI_LOC_REQUESTOR_AUTOMOBILE_CLIENT_V02 = 5, /**<  Automobile client \n */
  eQMI_LOC_REQUESTOR_OTHER_V02 = 6, /**<  Other requestor  */
  QMILOCREQUESTORENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocRequestorEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCREQUESTRESPONSETYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_REJECTED_V02 = 0, /**<  Request rejected because framework has not provided permission for this use case \n */
  eQMI_LOC_ACCEPTED_NO_LOCATION_PROVIDED_V02 = 1, /**<  Request accepted but could not provide location because of a failure \n */
  eQMI_LOC_ACCEPTED_LOCATION_PROVIDED_V02 = 2, /**<  Request accepted and location provided  */
  QMILOCREQUESTRESPONSETYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocRequestResponseTypeEnumT_v02;
/**
    @}
  */

typedef uint32_t qmiLocResponseLocProtocolMaskT_v02;
#define QMI_LOC_GNSS_POSITION_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000001) /**<  GNSS position has been reported to the client \n */
#define QMI_LOC_GNSS_MEASUREMENT_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000002) /**<  GNSS measurement has been reported to the client \n */
#define QMI_LOC_OTDOA_MEASUREMENT_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000004) /**<  OTDOA measurement has been reported to the client \n */
#define QMI_LOC_DBH_DATA_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000008) /**<  DBH data has been reported to the client \n */
#define QMI_LOC_SRN_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000010) /**<  SRN has been reported to the client \n */
#define QMI_LOC_ECID_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000020) /**<  Enhanced cell ID has been reported to the client \n */
#define QMI_LOC_WLAN_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000040) /**<  WLAN measurement has been reported to the client \n */
#define QMI_LOC_BARO_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000080) /**<  Barometer has been reported to the client \n  */
#define QMI_LOC_PPM_V02 ((qmiLocResponseLocProtocolMaskT_v02)0x00000100) /**<  Pilot phase measurement has been reported to the client  */
/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Notifies the application framework that location
                    related information has been requested. */
typedef struct {

  /* Mandatory */
  /*  Location Request Protocol Stack */
  qmiLocRequestProtocolEnumT_v02 protocolStack;
  /**<   Protocol stack that is requesting the non-framework location information.
 Values: \n
      - eQMI_LOC_CTRL_PLANE (0) --  Cellular control plane requests the location \n
      - eQMI_LOC_SUPL (1) --  SUPL requests the location \n
      - eQMI_LOC_IMS (2) --  IMS requests the location \n
      - eQMI_LOC_SIM (3) --  SIM requests the location \n
      - eQMI_LOC_MDT (4) --  MDT requests the location \n
      - eQMI_LOC_TLOC (5) --  Trusted location requests the location \n
      - eQMI_LOC_OTHER (6) --  Other protocol stack requests the location
 */

  /* Mandatory */
  /*  Location Requestor */
  qmiLocRequestorEnumT_v02 requestor;
  /**<   Entity that is requesting/receiving the location information.
 Values: \n
      - eQMI_LOC_REQUESTOR_CARRIER (0) --  Wireless service provider \n
      - eQMI_LOC_REQUESTOR_OEM (1) --  Device manufacturer \n
      - eQMI_LOC_REQUESTOR_MODEM_CHIPSET_VENDOR (2) --  Modem chipset vendor \n
      - eQMI_LOC_REQUESTOR_GNSS_CHIPSET_VENDOR (3) --  GNSS chipset vendor \n
      - eQMI_LOC_REQUESTOR_OTHER_CHIPSET_VENDOR (4) --  Other chipset vendor \n
      - eQMI_LOC_REQUESTOR_AUTOMOBILE_CLIENT (5) --  Automobile client \n
      - eQMI_LOC_REQUESTOR_OTHER (6) --  Other requestor
 */

  /* Mandatory */
  /*  Requestor Identification String */
  char requestorId[QMI_LOC_MAX_REQUESTOR_ID_STRING_LENGTH_V02 + 1];
  /**<   String identification of the endpoint receiving the location information.
       */

  /* Mandatory */
  /*  Location Requestor Response Type */
  qmiLocRequestResponseTypeEnumT_v02 responseType;
  /**<   Indicates whether the location information was provided for this request.
 Values: \n
      - eQMI_LOC_REJECTED (0) --  Request rejected because framework has not provided permission for this use case \n
      - eQMI_LOC_ACCEPTED_NO_LOCATION_PROVIDED (1) --  Request accepted but could not provide location because of a failure \n
      - eQMI_LOC_ACCEPTED_LOCATION_PROVIDED (2) --  Request accepted and location provided
 */

  /* Mandatory */
  /*  Location Response Protocol Mask */
  qmiLocResponseLocProtocolMaskT_v02 responseProtocol;
  /**<   Indicates types of location information that have been reported.
 Values: \n
      - QMI_LOC_GNSS_POSITION (0x00000001) --  GNSS position has been reported to the client \n
      - QMI_LOC_GNSS_MEASUREMENT (0x00000002) --  GNSS measurement has been reported to the client \n
      - QMI_LOC_OTDOA_MEASUREMENT (0x00000004) --  OTDOA measurement has been reported to the client \n
      - QMI_LOC_DBH_DATA (0x00000008) --  DBH data has been reported to the client \n
      - QMI_LOC_SRN (0x00000010) --  SRN has been reported to the client \n
      - QMI_LOC_ECID (0x00000020) --  Enhanced cell ID has been reported to the client \n
      - QMI_LOC_WLAN (0x00000040) --  WLAN measurement has been reported to the client \n
      - QMI_LOC_BARO (0x00000080) --  Barometer has been reported to the client \n
      - QMI_LOC_PPM (0x00000100) --  Pilot phase measurement has been reported to the client
 */

  /* Mandatory */
  /*  Emergency Mode */
  uint8_t inEmergencyMode;
  /**<   Indicates whether the device is in a user-initiated emergency session.
       */

  /* Mandatory */
  /*  Cached Location */
  uint8_t isCachedLocation;
  /**<   Indicates the cached location provided.
       */

  /* Optional */
  /*  Client Identification String */
  uint8_t clientStrId_valid;  /**< Must be set to true if clientStrId is being passed */
  char clientStrId[QMI_LOC_MAX_CLIENT_ID_STRING_LENGTH_V02 + 1];
  /**<   String identification of the client who requested the location.\n
       - Type -- NULL-terminated string \n
       - Maximum string length (including NULL terminator) -- 5
       */
}qmiLocLocationRequestNotificationIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPLATFORMPOWERSTATEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_POWER_STATE_UNKNOWN_V02 = 0, /**<  Platform power state unknown \n */
  eQMI_LOC_POWER_STATE_SUSPENDED_V02 = 1, /**<  Platform has entered a lower power state \n */
  eQMI_LOC_POWER_STATE_RESUME_V02 = 2, /**<  Platform has entered a higher power state \n */
  eQMI_LOC_POWER_STATE_SHUTDOWN_V02 = 3, /**<  Platform has started to gracefully shutdown  */
  QMILOCPLATFORMPOWERSTATEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocPlatformPowerStateEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject the platform power state
                     on CV2x and other platforms. */
typedef struct {

  /* Mandatory */
  /*  Power State */
  qmiLocPlatformPowerStateEnumT_v02 powerState;
  /**<   Power state of the platform; can be used by the location
       engine for its own power modes. */
}qmiLocInjectPlatformPowerStateReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to inject the platform power state
                     on CV2x and other platforms. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the platform power state injection request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled

 */
}qmiLocInjectPlatformPowerStateIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Configures the robust location. */
typedef struct {

  /* Mandatory */
  /*  Enable */
  uint8_t enable;
  /**<   Specifies the robust location configuration. \n
       - 0x00 (FALSE) -- Disable \n
       - 0x01 (TRUE)  -- Enable
  */

  /* Optional */
  /*  Enable for E911 */
  uint8_t enableForE911_valid;  /**< Must be set to true if enableForE911 is being passed */
  uint8_t enableForE911;
  /**<    Specifies the robust location configuration during e911 state. \n
       - 0x00 (FALSE) -- Disable \n
       - 0x01 (TRUE)  -- Enable
  */
}qmiLocSetRobustLocationReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  uint8_t major;
  /**<   Major version number. */

  uint16_t minor;
  /**<   Minor version number. */
}qmiLocRobustLocationVersionT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Queries the robust location configuration. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Enable */
  uint8_t isEnabled_valid;  /**< Must be set to true if isEnabled is being passed */
  uint8_t isEnabled;
  /**<   Configuration of robust location.  \n
       - 0x00 (FALSE) -- Disabled  \n
       - 0x01 (TRUE)  -- Enabled
  */

  /* Optional */
  /*  Enable for E911 */
  uint8_t isEnabledForE911_valid;  /**< Must be set to true if isEnabledForE911 is being passed */
  uint8_t isEnabledForE911;
  /**<   Configuration of robust location during e911 state. \n
       - 0x00 (FALSE) -- Disabled \n
       - 0x01 (TRUE)  -- Enabled
  */

  /* Optional */
  /*  Robust Location Version */
  uint8_t robustLocationVersion_valid;  /**< Must be set to true if robustLocationVersion is being passed */
  qmiLocRobustLocationVersionT_v02 robustLocationVersion;
  /**<   \n Major and minor version of the supported robust location feature. */
}qmiLocGetRobustLocationConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

typedef uint64_t qmiLocEnvAidingSvCorrectionValidMaskT_v02;
#define QMI_LOC_ENV_AIDING_SV_CORRECTION_LINE_OF_SIGHT_PROBABILITY_VALID_V02 ((qmiLocEnvAidingSvCorrectionValidMaskT_v02)0x00000001ull) /**<  Validity of the probabilitySvIsLineofSight field. \n */
#define QMI_LOC_ENV_AIDING_SV_CORRECTION_EXCESS_PATH_LENGTH_VALID_V02 ((qmiLocEnvAidingSvCorrectionValidMaskT_v02)0x00000002ull) /**<  Validity of the excessPathLengthMeters field . \n */
#define QMI_LOC_ENV_AIDING_SV_CORRECTION_EXCESS_PATH_LENGTH_UNC_VALID_V02 ((qmiLocEnvAidingSvCorrectionValidMaskT_v02)0x00000004ull) /**<  Validity of the excessPathLengthUncMeters field. \n */
#define QMI_LOC_ENV_AIDING_SV_CORRECTION_REFLECTING_PLANE_VALID_V02 ((qmiLocEnvAidingSvCorrectionValidMaskT_v02)0x00000008ull) /**<  Validity of the reflectingPlane field.  */
/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  double latitudeDegrees;
  /**<   Latitude of the reflecting plane. \n
       - Units -- Degrees */

  double longitudeDegrees;
  /**<   Longitude of the reflecting plane.\n
       - Units -- Degrees */

  double altitudeMeters;
  /**<   Altitude of the reflecting point in the plane above the WGS-84 reference ellipsoid. \n
       - Units -- Meters */

  double azimuthDegrees;
  /**<   Azimuth clockwise from north of the reflecting plane. \n
       - Units -- Degrees */
}qmiLocEnvAidingReflectingPlaneStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_aggregates
    @{
  */
typedef struct {

  qmiLocEnvAidingSvCorrectionValidMaskT_v02 svCorrectionFlags;
  /**<   Indicates which correction values are valid. \n
      - QMI_LOC_ENV_AIDING_SV_CORRECTION_LINE_OF_SIGHT_PROBABILITY_VALID (0x00000001) --  Validity of the probabilitySvIsLineofSight field. \n
      - QMI_LOC_ENV_AIDING_SV_CORRECTION_EXCESS_PATH_LENGTH_VALID (0x00000002) --  Validity of the excessPathLengthMeters field . \n
      - QMI_LOC_ENV_AIDING_SV_CORRECTION_EXCESS_PATH_LENGTH_UNC_VALID (0x00000004) --  Validity of the excessPathLengthUncMeters field. \n
      - QMI_LOC_ENV_AIDING_SV_CORRECTION_REFLECTING_PLANE_VALID (0x00000008) --  Validity of the reflectingPlane field.  */

  qmiLocSvSystemEnumT_v02 constellation;
  /**<   Constellation of the given satellite. \n
      - eQMI_LOC_SV_SYSTEM_GPS (1) --  GPS satellite \n
      - eQMI_LOC_SV_SYSTEM_GALILEO (2) --  Galileo satellite \n
      - eQMI_LOC_SV_SYSTEM_SBAS (3) --  SBAS satellite \n
      - eQMI_LOC_SV_SYSTEM_COMPASS (4) --  COMPASS satellite (Deprecated) \n
      - eQMI_LOC_SV_SYSTEM_GLONASS (5) --  GLONASS satellite \n
      - eQMI_LOC_SV_SYSTEM_BDS (6) --  BDS satellite \n
      - eQMI_LOC_SV_SYSTEM_QZSS (7) --  QZSS satellite \n
      - eQMI_LOC_SV_SYSTEM_NAVIC (8) --  NavIC satellite  */

  uint16_t svid;
  /**<   GNSS SV ID. Range: \n
       - GPS --     1 to 32 \n
       - GLONASS -- 65 to 96 \n
       - QZSS --    193 to 197  \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414 */

  float carrierFrequencyHz;
  /**<   Carrier frequency of the signal to correct.
       For example, the GPS L1 center frequency 1,575,420,000 Hz,
       or varying GLO channels.
       For a receiver with capabilities to track multiple frequencies for the same satellite,
       multiple corrections for the same satellite can be provided. \n
       - Units -- Hz  */

  float probabilitySvIsLineofSight;
  /**<   Probability that the satellite is estimated to be in line-of-sight condition at the specified location.
       Validity is determined by setting the relevant bit in the svCorrectionFlags.  \n
       - Range -- 0-1  */

  float excessPathLengthMeters;
  /**<   Excess path length to subtract from pseudorange before using it for positioning.
       Determines validity by setting the relevant bit in the svCorrectionFlags. \n
       - Units -- Meters */

  float excessPathLengthUncMeters;
  /**<   Error estimate (1-sigma) for the excess path length estimate.
       Determines validity by setting the relevant bit in svCorrectionFlags. \n
       - Units -- Meters */

  qmiLocEnvAidingReflectingPlaneStructT_v02 reflectingPlane;
  /**<   Reflects plane characteristics such as location and azimuth.
       Determines validity by setting the relevant bit in svCorrectionFlags */
}qmiLocEnvAidingSVCorrectionStructT_v02;  /* Type */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to inject environment aided
                     measurement corrections. */
typedef struct {

  /* Mandatory */
  /*  Current Message Sequence Number  */
  uint8_t seqNum;
  /**<   Current message number; used for segmentation/assembly of environment aiding
       injection data. */

  /* Mandatory */
  /*  Maximum Number of Messages to send */
  uint8_t maxMessageNum;
  /**<   Maximum number of messages to send for injecting environment aiding data. */

  /* Optional */
  /*  Environment Bearing Validity */
  uint8_t envBearingValidity_valid;  /**< Must be set to true if envBearingValidity is being passed */
  uint8_t envBearingValidity;
  /**<   Indicates whether the environment bearing is valid. */

  /* Optional */
  /*  Environment Bearing */
  uint8_t envBearingDegrees_valid;  /**< Must be set to true if envBearingDegrees is being passed */
  float envBearingDegrees;
  /**<   Environment bearing in degrees clockwise from true North (0.0 to 360.0],
       in the direction of user motion. Environment bearing is provided when it is
       known with high probability that velocity is aligned with an environment
       feature, such as a building or road. If user speed is zero,
       envBearingDegrees represents bearing of most recent speed that was > 0.
       As position approaches another road or open area, envBearingUncDegrees grows, and
       at some stage envBearingDegrees becomes invalid. If the road is curved in the vicinity
       of the user location, envBearingUncDegrees includes the amount
       by which the road direction changes in the area of position uncertainty.
    */

  /* Optional */
  /*  Environment Bearing Uncertainty */
  uint8_t envBearingUncDegrees_valid;  /**< Must be set to true if envBearingUncDegrees is being passed */
  float envBearingUncDegrees;
  /**<   Environment bearing uncertainty. \n
       - Range -- 0 to 180  \n
       - Units -- Degrees      */

  /* Optional */
  /*  Latitude */
  uint8_t latitudeDegrees_valid;  /**< Must be set to true if latitudeDegrees is being passed */
  double latitudeDegrees;
  /**<   Latitude at which the corrections are computed.  \n
       - Units -- Degrees  */

  /* Optional */
  /*  Longitude */
  uint8_t longitudeDegrees_valid;  /**< Must be set to true if longitudeDegrees is being passed */
  double longitudeDegrees;
  /**<   Longitude at which the corrections are computed.\n
       - Units -- Degrees   */

  /* Optional */
  /*  Horizontal Position Uncertainty */
  uint8_t horizontalPositionUncMeters_valid;  /**< Must be set to true if horizontalPositionUncMeters is being passed */
  double horizontalPositionUncMeters;
  /**<   Horizontal uncertainty (68% confidence) on the device position at which
       the corrections are provided. This value is useful to judge
       accuracy of the provided corrections.  \n
       - Units -- Meters  */

  /* Optional */
  /*  Altitude */
  uint8_t altitudeMeters_valid;  /**< Must be set to true if altitudeMeters is being passed */
  double altitudeMeters;
  /**<   Altitude above the WGS-84 reference ellipsoid at which the corrections are computed.  \n
       - Units -- Meters */

  /* Optional */
  /*  Altitude Uncertainty */
  uint8_t altitudeUncMeters_valid;  /**< Must be set to true if altitudeUncMeters is being passed */
  double altitudeUncMeters;
  /**<   Altitude uncertainty (68% confidence) on the device position at which the
       corrections are provided. This value is useful to judge accuracy of the
       provided corrections.   \n
       - Units -- Meters */

  /* Optional */
  /*  Time of Applicability */
  uint8_t toaGpsNanosecondsOfWeek_valid;  /**< Must be set to true if toaGpsNanosecondsOfWeek is being passed */
  uint64_t toaGpsNanosecondsOfWeek;
  /**<   Time of applicability, GPS time of week. \n
       - Units -- Nanoseconds */

  /* Optional */
  /*  SV Corrections */
  uint8_t svCorrection_valid;  /**< Must be set to true if svCorrection is being passed */
  uint32_t svCorrection_len;  /**< Must be set to # of elements in svCorrection */
  qmiLocEnvAidingSVCorrectionStructT_v02 svCorrection[QMI_LOC_ENV_AIDING_CORRECTION_MAX_SV_USED_V02];
  /**<   \n Measurement corrections for satellites in view. */
}qmiLocEventInjectEnvAidingReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the minimum GPS week number. */
typedef struct {

  /* Mandatory */
  /*  Minimum GPS Week Number */
  uint16_t minGpsWeekNumber;
  /**<   Minimum GPS week number. */
}qmiLocSetMinGpsWeekNumberReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by control point to query the minimum GPS week number. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Minimum GPS Week Number */
  uint8_t minGpsWeekNumber_valid;  /**< Must be set to true if minGpsWeekNumber is being passed */
  uint16_t minGpsWeekNumber;
  /**<   Minimum GPS week number. */
}qmiLocGetMinGpsWeekNumberIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends SAP-INS generated aiding information to the control point. */
typedef struct {

  /* Mandatory */
  /*  Filter Status */
  uint8_t status;
  /**<   Filter status. */

  /* Mandatory */
  /*  Filter Fix Status */
  uint8_t fixStatus;
  /**<   Filter fix status information. */

  /* Mandatory */
  /*  GNSS System Time Information */
  qmiLocGnssTimeStructT_v02 systemTime;

  /* Optional */
  /*  Filter State Information */
  uint8_t state_valid;  /**< Must be set to true if state is being passed */
  double state[QMI_LOC_FILTER_ELEMENT_SIZE_SEVENTEEN_V02];
  /**<   Filter state information. */

  /* Optional */
  /*  Filter Variance Information */
  uint8_t var_valid;  /**< Must be set to true if var is being passed */
  double var[QMI_LOC_FILTER_ELEMENT_SIZE_SEVENTEEN_V02];
  /**<   Filter variance information. */

  /* Optional */
  /*  Filter Reliability 1 */
  uint8_t rel1_valid;  /**< Must be set to true if rel1 is being passed */
  uint8_t rel1;
  /**<   Filter reliability 1. */

  /* Optional */
  /*  Filter Reliability 2 */
  uint8_t rel2_valid;  /**< Must be set to true if rel2 is being passed */
  uint8_t rel2;
  /**<   Filter reliability 2. */

  /* Optional */
  /*  Filter Residual 1 */
  uint8_t residual1_valid;  /**< Must be set to true if residual1 is being passed */
  double residual1;
  /**<   Filter residual 1. */

  /* Optional */
  /*  Filter Observation 1 */
  uint8_t obs1_valid;  /**< Must be set to true if obs1 is being passed */
  double obs1[QMI_LOC_FILTER_ELEMENT_SIZE_SIX_V02];
  /**<   Filter observation 1. */

  /* Optional */
  /*  Filter Variance 1 */
  uint8_t var1_valid;  /**< Must be set to true if var1 is being passed */
  double var1;
  /**<   Filter variance 1. */

  /* Optional */
  /*  Filter Result 1 */
  uint8_t result1_valid;  /**< Must be set to true if result1 is being passed */
  uint8_t result1;
  /**<   Filter result 1. */

  /* Optional */
  /*  Filter Residual 2 */
  uint8_t residual2_valid;  /**< Must be set to true if residual2 is being passed */
  double residual2;
  /**<   Filter residual 2. */

  /* Optional */
  /*  Filter Observation 2 */
  uint8_t obs2_valid;  /**< Must be set to true if obs2 is being passed */
  double obs2[QMI_LOC_FILTER_ELEMENT_SIZE_SIX_V02];
  /**<   Filter observation 2. */

  /* Optional */
  /*  Filter Variance 2 */
  uint8_t var2_valid;  /**< Must be set to true if var2 is being passed */
  double var2;
  /**<   Filter variance 2. */

  /* Optional */
  /*  Filter Result 2 */
  uint8_t result2_valid;  /**< Must be set to true if result2 is being passed */
  uint8_t result2;
  /**<   Filter result 2. */

  /* Optional */
  /*  Filter Residual 3 */
  uint8_t residual3_valid;  /**< Must be set to true if residual3 is being passed */
  double residual3[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter residual 3. */

  /* Optional */
  /*  Filter Variance 3 */
  uint8_t var3_valid;  /**< Must be set to true if var3 is being passed */
  double var3[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter variance 3. */

  /* Optional */
  /*  Filter Result 3 */
  uint8_t result3_valid;  /**< Must be set to true if result3 is being passed */
  uint8_t result3[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter result 3. */

  /* Optional */
  /*  Filter Residual 4 */
  uint8_t residual4_valid;  /**< Must be set to true if residual4 is being passed */
  double residual4[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter residual 4. */

  /* Optional */
  /*  Filter Variance 4 */
  uint8_t var4_valid;  /**< Must be set to true if var4 is being passed */
  double var4[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter variance 4. */

  /* Optional */
  /*  Filter Result 4 */
  uint8_t result4_valid;  /**< Must be set to true if result4 is being passed */
  uint8_t result4[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter result 4. */

  /* Optional */
  /*  Filter Acceleration */
  uint8_t acc_valid;  /**< Must be set to true if acc is being passed */
  double acc[QMI_LOC_FILTER_ELEMENT_SIZE_THREE_V02];
  /**<   Filter acceleration. */

  /* Optional */
  /*  Filter Quaternion */
  uint8_t quat_valid;  /**< Must be set to true if quat is being passed */
  double quat[QMI_LOC_FILTER_ELEMENT_SIZE_FOUR_V02];
  /**<   Filter quaternion. */

  /* Optional */
  /*  Bias M1 */
  uint8_t biasM1_valid;  /**< Must be set to true if biasM1 is being passed */
  float biasM1[QMI_LOC_IPM_ELEMENT_SIZE_THREE_V02];
  /**<   Bias M1. */

  /* Optional */
  /*  Bias V1 */
  uint8_t biasV1_valid;  /**< Must be set to true if biasV1 is being passed */
  float biasV1[QMI_LOC_IPM_ELEMENT_SIZE_THREE_V02];
  /**<   Bias V1. */

  /* Optional */
  /*  Bias M2 */
  uint8_t biasM2_valid;  /**< Must be set to true if biasM2 is being passed */
  float biasM2[QMI_LOC_IPM_ELEMENT_SIZE_THREE_V02];
  /**<   Bias M2. */

  /* Optional */
  /*  Bias V2 */
  uint8_t biasV2_valid;  /**< Must be set to true if biasV2 is being passed */
  float biasV2[QMI_LOC_IPM_ELEMENT_SIZE_THREE_V02];
  /**<   Bias V2. */

  /* Optional */
  /*  Rotation Matrix 1 */
  uint8_t rMat1_valid;  /**< Must be set to true if rMat1 is being passed */
  double rMat1[QMI_LOC_IPM_ELEMENT_SIZE_NINE_V02];
  /**<   Rotation matrix 1, Arranged row-wise. */

  /* Optional */
  /*  Rotation Matrix 1 count */
  uint8_t rMat1Count_valid;  /**< Must be set to true if rMat1Count is being passed */
  uint32_t rMat1Count;
  /**<   Rotation matrix 1 count. */

  /* Optional */
  /*  Rotation Matrix 2 */
  uint8_t rMat2_valid;  /**< Must be set to true if rMat2 is being passed */
  double rMat2[QMI_LOC_IPM_ELEMENT_SIZE_NINE_V02];
  /**<   Rotation matrix 2, arranged row-wise. */

  /* Optional */
  /*  Detector 1 Reset */
  uint8_t det1Reset_valid;  /**< Must be set to true if det1Reset is being passed */
  uint8_t det1Reset;
  /**<   Detector 1 reset. */

  /* Optional */
  /*  Detector 2 Status */
  uint8_t det2Status_valid;  /**< Must be set to true if det2Status is being passed */
  uint8_t det2Status;
  /**<   Detector 2 status. */

  /* Optional */
  /*  Detector 2 Position */
  uint8_t det2Position_valid;  /**< Must be set to true if det2Position is being passed */
  double det2Position[QMI_LOC_INS_ELEMENT_SIZE_THREE_V02];
  /**<   Detector 2 position. */

  /* Optional */
  /*  Detector 2 Position Uncertainty */
  uint8_t det2PositionUnc_valid;  /**< Must be set to true if det2PositionUnc is being passed */
  float det2PositionUnc[QMI_LOC_INS_ELEMENT_SIZE_TWO_V02];
  /**<   Detector 2 position uncertainty. */

  /* Optional */
  /*  Detector 3 Status */
  uint8_t det3Status_valid;  /**< Must be set to true if det3Status is being passed */
  uint8_t det3Status;
  /**<   Detector 3 status. */

  /* Optional */
  /*  Detector 3 Variance 1 */
  uint8_t det3Variance1_valid;  /**< Must be set to true if det3Variance1 is being passed */
  float det3Variance1[QMI_LOC_INS_ELEMENT_SIZE_THREE_V02];
  /**<   Detector 3 variance 1 */

  /* Optional */
  /*  Detector 3 Variance 2 */
  uint8_t det3Variance2_valid;  /**< Must be set to true if det3Variance2 is being passed */
  float det3Variance2[QMI_LOC_INS_ELEMENT_SIZE_THREE_V02];
  /**<   Detector 3 variance 2. */

  /* Optional */
  /*  Detector 4 Status */
  uint8_t det4Status_valid;  /**< Must be set to true if det4Status is being passed */
  uint8_t det4Status;
  /**<   Detector 4 status. */

  /* Optional */
  /*  Detector 4 Position */
  uint8_t det4Position_valid;  /**< Must be set to true if det4Position is being passed */
  double det4Position[QMI_LOC_INS_ELEMENT_SIZE_THREE_V02];
  /**<   Detector 4 position. */

  /* Optional */
  /*  Detector 5 Status */
  uint8_t det5Status_valid;  /**< Must be set to true if det5Status is being passed */
  uint8_t det5Status;
  /**<   Detector 5 status. */

  /* Optional */
  /*  Detector 6 Status */
  uint8_t det6Status_valid;  /**< Must be set to true if det6Status is being passed */
  float det6Status;
  /**<   Detector 6 status. */

  /* Optional */
  /*  Satellite Identifier */
  uint8_t gnssSvId_valid;  /**< Must be set to true if gnssSvId is being passed */
  uint32_t gnssSvId_len;  /**< Must be set to # of elements in gnssSvId */
  uint16_t gnssSvId[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   GNSS SV ID.
       Range: \n
       - GPS -- 1 to 32 \n
       - GLONASS -- 65 to 96; set as 255 when slot-number to SV ID mapping is unknown \n
       - QZSS --    193 to 197 \n
       - BDS --     201 to 263 \n
       - Galileo -- 301 to 336 \n
       - NavIC --   401 to 414
     */

  /* Optional */
  /*  GNSS Signal Type */
  uint8_t measType_valid;  /**< Must be set to true if measType is being passed */
  uint32_t measType_len;  /**< Must be set to # of elements in measType */
  qmiLocGnssSignalTypeMaskT_v02 measType[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   Indicates the GNSS signal type of each satellite in gnssSvID. The
 signal type list is aligned with the SVs in gnssSvId. Value 0
 means invalid.
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1CA (0x00000001) --  GPS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L1C (0x00000002) --  GPS L1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L2C_L (0x00000004) --  GPS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GPS_L5_Q (0x00000008) --  GPS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G1 (0x00000010) --  GLONASS G1 (L1OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GLONASS_G2 (0x00000020) --  GLONASS G2 (L2OF) RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E1_C (0x00000040) --  Galileo E1_C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q (0x00000080) --  Galileo E5A_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q (0x00000100) --  Galileo E5B_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1_I (0x00000200) --  BeiDou B1_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B1C (0x00000400) --  BeiDou B1C RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2_I (0x00000800) --  BeiDou B2_I RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I (0x00001000) --  BeiDou B2A_I RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1CA (0x00002000) --  QZSS L1CA RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L1S (0x00004000) --  QZSS L1S RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L2C_L (0x00008000) --  QZSS L2C_L RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_QZSS_L5_Q (0x00010000) --  QZSS L5_Q RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_SBAS_L1_CA (0x00020000) --  SBAS L1_CA RF band
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_NAVIC_L5 (0x00040000) --  NavIC L5 RF band \n
      - QMI_LOC_MASK_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q (0x00080000) --  BeiDou B2A_Q RF band  */

  /* Optional */
  /*  Measurement Variance 1 */
  uint8_t measVar1_valid;  /**< Must be set to true if measVar1 is being passed */
  uint32_t measVar1_len;  /**< Must be set to # of elements in measVar1 */
  float measVar1[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   This list matches the order of SVs in gnssSvID list. */

  /* Optional */
  /*  Measurement Usage Information 1 */
  uint8_t measUse1_valid;  /**< Must be set to true if measUse1 is being passed */
  uint32_t measUse1_len;  /**< Must be set to # of elements in measUse1 */
  uint32_t measUse1[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   This list matches the order of SVs in gnssSvID list. */

  /* Optional */
  /*  Measurement Variance 2 */
  uint8_t measVar2_valid;  /**< Must be set to true if measVar2 is being passed */
  uint32_t measVar2_len;  /**< Must be set to # of elements in measVar2 */
  float measVar2[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<    This list matches the order of SVs in gnssSvID list. */

  /* Optional */
  /*  Measurement Usage Information 2 */
  uint8_t measUse2_valid;  /**< Must be set to true if measUse2 is being passed */
  uint32_t measUse2_len;  /**< Must be set to # of elements in measUse2 */
  uint32_t measUse2[QMI_LOC_EXPANDED_SV_INFO_LIST_MAX_SIZE_V02];
  /**<   This list matches the order of SVs in gnssSvID list.*/
}qmiLocSapInsParamsIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Requests the control point to query XTRA information. */
typedef struct {
  /* This element is a placeholder to prevent the declaration of
     an empty struct.  DO NOT USE THIS FIELD UNDER ANY CIRCUMSTANCE */
  char __placeholder;
}qmiLocEventQueryXtraInfoReqIndMsgT_v02;

  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCPARAMETERTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_PARAMETER_TYPE_RESERVED_V02 = 0, /**<  Do not use.  */
  eQMI_LOC_PARAMETER_TYPE_MINIMUM_SV_ELEVATION_V02 = 1, /**<  Minimum SV elevation to use for computing position.  */
  QMILOCPARAMETERTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocParameterTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control to
                     set a specific parameter for the GNSS engine to use. */
typedef struct {

  /* Mandatory */
  /*  Parameter Type */
  qmiLocParameterTypeEnumT_v02 paramType;
  /**<   Parameter type. Values: \n
      - eQMI_LOC_PARAMETER_TYPE_RESERVED (0) --  Do not use.
      - eQMI_LOC_PARAMETER_TYPE_MINIMUM_SV_ELEVATION (1) --  Minimum SV elevation to use for computing position.
 */

  /* Optional */
  /*  Minimum SV Elevation */
  uint8_t minSvElevation_valid;  /**< Must be set to true if minSvElevation is being passed */
  uint8_t minSvElevation;
  /**<   Specifies the minimum SV elevation to use for positioning.
       GNSS Position Engine does not use SVs with elevation lower than the
       configured minimum elevation setting to compute position.\n
       - Units -- Degrees \n
       - Range -- 0 - 90
  */
}qmiLocSetParameterReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to query a specific
                     parameter in use by GNSS engine. */
typedef struct {

  /* Mandatory */
  /*  Parameter Type */
  qmiLocParameterTypeEnumT_v02 paramType;
  /**<   Parameter type. Values:
      - eQMI_LOC_PARAMETER_TYPE_RESERVED (0) --  Do not use.
      - eQMI_LOC_PARAMETER_TYPE_MINIMUM_SV_ELEVATION (1) --  Minimum SV elevation to use for computing position.
 */
}qmiLocGetParameterReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query a specific
                     parameter in use by GNSS engine. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request. Values:\n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Mandatory */
  /*  Parameter Type */
  qmiLocParameterTypeEnumT_v02 paramType;
  /**<   Parameter type. Values: \n
      - eQMI_LOC_PARAMETER_TYPE_RESERVED (0) --  Do not use.
      - eQMI_LOC_PARAMETER_TYPE_MINIMUM_SV_ELEVATION (1) --  Minimum SV elevation to use for computing position.
 */

  /* Optional */
  /*  Minimum SV Elevation */
  uint8_t minSvElevation_valid;  /**< Must be set to true if minSvElevation is being passed */
  uint8_t minSvElevation;
  /**<   Specifies the minimum SV elevation to use for positioning.
       GNSS Position Engine does not use SVs with elevation lower than the
       configured minimum elevation setting to compute position fix. \n
       - Units -- Degrees \n
       - Range -- 0 - 90
  */
}qmiLocGetParameterIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCSTATSREPORTINGCONFIGENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_REPORT_CURRENT_STATUS_V02 = 0, /**<  Current status of the engine statistics. \n  */
  eQMI_LOC_REPORTING_INTERVAL_10_SEC_V02 = 1, /**<  The time interval  is 10 seconds \n  */
  eQMI_LOC_REPORTING_INTERVAL_20_SEC_V02 = 2, /**<  The time interval 20 seconds \n  */
  eQMI_LOC_REPORTING_INTERVAL_30_SEC_V02 = 3, /**<  The time interval is 30 seconds \n  */
  eQMI_LOC_REPORTING_INTERVAL_60_SEC_V02 = 4, /**<  The time interval is 60 seconds \n  */
  eQMI_LOC_REPORTING_INTERVAL_SESSION_V02 = 5, /**<  The time interval is the entire session (receiver ON to receiver OFF) */
  QMILOCSTATSREPORTINGCONFIGENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocStatsReportingConfigEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to start or stop receiving the
                     location engine statistics.
     */
typedef struct {

  /* Mandatory */
  /*  Enable Statistics Reporting */
  uint8_t enable;
  /**<   When set to True, configure to start sending the location engine statistics
       at the interval provided. \n
       When set to False, configure to stop sending the locationeEngine statistics. */

  /* Optional */
  /*  Interval Duration */
  uint8_t interval_valid;  /**< Must be set to true if interval is being passed */
  qmiLocStatsReportingConfigEnumT_v02 interval;
  /**<   Interval for the location statistics reporting.
 Values: \n
      - eQMI_LOC_REPORT_CURRENT_STATUS (0) --  Current status of the engine statistics. \n
      - eQMI_LOC_REPORTING_INTERVAL_10_SEC (1) --  The time interval  is 10 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_20_SEC (2) --  The time interval 20 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_30_SEC (3) --  The time interval is 30 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_60_SEC (4) --  The time interval is 60 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_SESSION (5) --  The time interval is the entire session (receiver ON to receiver OFF)

 */
}qmiLocSetStatisticsConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request the current configuration
                     of receving the location engine statistics. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the get location engine statistics report request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Statistics Report Enabled */
  uint8_t enabled_valid;  /**< Must be set to true if enabled is being passed */
  uint8_t enabled;
  /**<   When set to True, send the location engine statistics at the interval
       provided by the Interval Duration TLV. \n
       When set to False, do not send the location engine statistics. */

  /* Optional */
  /*  Interval Duration */
  uint8_t interval_valid;  /**< Must be set to true if interval is being passed */
  qmiLocStatsReportingConfigEnumT_v02 interval;
  /**<   Interval for the location statistics reporting.
 Values: \n
      - eQMI_LOC_REPORT_CURRENT_STATUS (0) --  Current status of the engine statistics. \n
      - eQMI_LOC_REPORTING_INTERVAL_10_SEC (1) --  The time interval  is 10 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_20_SEC (2) --  The time interval 20 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_30_SEC (3) --  The time interval is 30 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_60_SEC (4) --  The time interval is 60 seconds \n
      - eQMI_LOC_REPORTING_INTERVAL_SESSION (5) --  The time interval is the entire session (receiver ON to receiver OFF)

 */
}qmiLocGetStatisticsConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the location engine statistics to the control point. */
typedef struct {

  /* Optional */
  /*  Absolute Valid Age for XTRA Data */
  uint8_t absValidAge_valid;  /**< Must be set to true if absValidAge is being passed */
  uint32_t absValidAge;
  /**<   Number of hours (absolute) for which the current XTRA information is valid. \n
       - Units -- Hours  */

  /* Optional */
  /*  Average Power Consumed */
  uint8_t averagePowerConsumed_valid;  /**< Must be set to true if averagePowerConsumed is being passed */
  float averagePowerConsumed;
  /**<   Indicates the average power consumed by the receiver during
       the requested interval of time (interval). \n
       - Unit -- milliwatts  */

  /* Optional */
  /*  Receiver Power Consumption Duration */
  uint8_t powerConsumptionDuration_valid;  /**< Must be set to true if powerConsumptionDuration is being passed */
  uint32_t powerConsumptionDuration;
  /**<   Indicates the duration for average power consumed (averagePowerConsumed)
       by the receiver during the requested interval of time (interval). \n
       - Unit -- Milliseconds */

  /* Optional */
  /*  Latitude */
  uint8_t latitude_valid;  /**< Must be set to true if latitude is being passed */
  double latitude;
  /**<   - Units -- Degrees \n
       - Range -- -90.0 to 90.0 \n
        - Positive values indicate northern latitude \n
        - Negative values indicate southern latitude  */

  /* Optional */
  /*  Longitude */
  uint8_t longitude_valid;  /**< Must be set to true if longitude is being passed */
  double longitude;
  /**<   Longitude; valid range is 180.0 to 180.0 degrees.
       Postive values indicate eastern longitude, negative values
       indicate western longitude.
      */

  /* Optional */
  /*  Altitude With Respect to Ellipsoid */
  uint8_t altitudeWrtEllipsoid_valid;  /**< Must be set to true if altitudeWrtEllipsoid is being passed */
  float altitudeWrtEllipsoid;
  /**<   Altitude with respect to the WGS84 ellipsoid.\n
       - Units -- Meters \n
       - Range -- -500 to 15883 */

  /* Optional */
  /*  Altitude With Respect to Sea Level */
  uint8_t altitudeWrtMeanSeaLevel_valid;  /**< Must be set to true if altitudeWrtMeanSeaLevel is being passed */
  float altitudeWrtMeanSeaLevel;
  /**<   Altitude with respect to mean sea level.\n
       - Units -- Meters */

  /* Optional */
  /*  Circular Horizontal Position Uncertainty */
  uint8_t horUncCircular_valid;  /**< Must be set to true if horUncCircular is being passed */
  float horUncCircular;
  /**<   Horizontal position uncertainty (circular).\n
       - Units -- Meters */

  /* Optional */
  /*  Vertical Uncertainty */
  uint8_t vertUnc_valid;  /**< Must be set to true if vertUnc is being passed */
  float vertUnc;
  /**<   - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Minor Axis */
  uint8_t horUncEllipseSemiMinor_valid;  /**< Must be set to true if horUncEllipseSemiMinor is being passed */
  float horUncEllipseSemiMinor;
  /**<   Semi-minor axis of horizontal elliptical uncertainty. \n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Elliptical Uncertainty Semi-Major Axis */
  uint8_t horUncEllipseSemiMajor_valid;  /**< Must be set to true if horUncEllipseSemiMajor is being passed */
  float horUncEllipseSemiMajor;
  /**<   Semi-major axis of horizontal elliptical uncertainty. \n
       - Units -- Meters */

  /* Optional */
  /*  Horizontal Circular Confidence */
  uint8_t horCircularConfidence_valid;  /**< Must be set to true if horCircularConfidence is being passed */
  uint8_t horCircularConfidence;
  /**<   Horizontal circular uncertainty confidence; valid range is 0 to 99 percent.
       */

  /* Optional */
  /*  Horizontal Reliability */
  uint8_t horReliability_valid;  /**< Must be set to true if horReliability is being passed */
  qmiLocReliabilityEnumT_v02 horReliability;
  /**<   Specifies the reliability of the horizontal position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Horizontal Speed */
  uint8_t horSpeed_valid;  /**< Must be set to true if horSpeed is being passed */
  float horSpeed;
  /**<   Horizontal speed.\n
       - Units -- Meters per second  */

  /* Optional */
  /*  Horizontal Speed Uncertainty */
  uint8_t horSpeedUnc_valid;  /**< Must be set to true if horSpeedUnc is being passed */
  float horSpeedUnc;
  /**<   Horizontal speed uncertainty. \n
       - Units -- Meters per second */

  /* Optional */
  /*  Vertical Confidence */
  uint8_t vertConfidence_valid;  /**< Must be set to true if vertConfidence is being passed */
  uint8_t vertConfidence;
  /**<   Vertical uncertainty confidence; valid range is 0 to 99 percent.  */

  /* Optional */
  /*  Vertical Reliability */
  uint8_t vertReliability_valid;  /**< Must be set to true if vertReliability is being passed */
  qmiLocReliabilityEnumT_v02 vertReliability;
  /**<   Specifies the reliability of the vertical position.
 Values: \n
      - eQMI_LOC_RELIABILITY_NOT_SET (0) --  Location reliability is not set \n
      - eQMI_LOC_RELIABILITY_VERY_LOW (1) --  Location reliability is very low; use it at your own risk \n
      - eQMI_LOC_RELIABILITY_LOW (2) --  Location reliability is low; little or no cross-checking is possible \n
      - eQMI_LOC_RELIABILITY_MEDIUM (3) --  Location reliability is medium; limited cross-check passed \n
      - eQMI_LOC_RELIABILITY_HIGH (4) --  Location reliability is high; strong cross-check passed
 */

  /* Optional */
  /*  Vertical Speed */
  uint8_t vertSpeed_valid;  /**< Must be set to true if vertSpeed is being passed */
  float vertSpeed;
  /**<   - Units -- Meters per second */

  /* Optional */
  /*  Vertical Speed Uncertainty */
  uint8_t vertSpeedUnc_valid;  /**< Must be set to true if vertSpeedUnc is being passed */
  float vertSpeedUnc;
  /**<   - Units -- Meters per second */

  /* Optional */
  /*  GPS Week */
  uint8_t gpsWeek_valid;  /**< Must be set to true if gpsWeek is being passed */
  uint16_t gpsWeek;
  /**<   GPS week number at reference tick. \n
       - Units -- Weeks  */

  /* Optional */
  /*  GPS Reference Tick */
  uint8_t gpsMsec_valid;  /**< Must be set to true if gpsMsec is being passed */
  uint32_t gpsMsec;
  /**<   GPS millisecond at reference tick.
      */

  /* Optional */
  /*  Clock Bias */
  uint8_t clkTimeBias_valid;  /**< Must be set to true if clkTimeBias is being passed */
  float clkTimeBias;
  /**<   Clock bias in milliseconds.
       Range is greater than -0.5 and less than 0.5. */

  /* Optional */
  /*  Clock Bias Uncertainity  */
  uint8_t clkTimeBiasUnc_valid;  /**< Must be set to true if clkTimeBiasUnc is being passed */
  float clkTimeBiasUnc;
  /**<   One-sided maximum time bias uncertainty in float. \n
         - Units -- Milliseconds */
}qmiLocGnssStatisticsReportIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCGNSSPDRMODEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_GNSS_PDR_CASUAL_MODE_V02 = 0, /**<  Casual mode when GNSS is in PDR.  */
  eQMI_LOC_GNSS_PDR_FITNESS_MODE_V02 = 1, /**<  Fitness mode when GNSS is in PDR.  */
  QMILOCGNSSPDRMODEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocGnssPdrModeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to configure the GNSS mode for PDR.
   */
typedef struct {

  /* Optional */
  /*  GNSS PDR Mode */
  uint8_t mode_valid;  /**< Must be set to true if mode is being passed */
  qmiLocGnssPdrModeEnumT_v02 mode;
  /**<   PDR Mode for GNSS.
 Values: \n
      - eQMI_LOC_GNSS_PDR_CASUAL_MODE (0) --  Casual mode when GNSS is in PDR.
      - eQMI_LOC_GNSS_PDR_FITNESS_MODE (1) --  Fitness mode when GNSS is in PDR.

 */
}qmiLocSetGnssPdrModeReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request the current mode
                     of the GNSS engine for PDR. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request to get GNSS mode when in PDR.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled

 */

  /* Optional */
  /*  GNSS Mode: Casual or Fitness When in PDR */
  uint8_t mode_valid;  /**< Must be set to true if mode is being passed */
  qmiLocGnssPdrModeEnumT_v02 mode;
  /**<   Mode for GNSS when in PDR. */
}qmiLocGetGnssPdrModeIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to request for the current
                     Calibrated state when in PDR. */
typedef struct {

  /* Mandatory */
  /*  Status */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request to get the current Calibrated state
 of the magnetometer when in PDR.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled

 */

  /* Optional */
  /*  Calibrated State */
  uint8_t isCalibrated_valid;  /**< Must be set to true if isCalibrated is being passed */
  uint8_t isCalibrated;
  /**<   Calibrated state of the Magnetometer when in PDR.
       Values: \n
       - TRUE  -- Calibrated \n
       - FALSE -- Not calibrated */
}qmiLocGetMagCalStatePdrIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Request Message; Used by the control point to set the multiband configuration
                      for all GNSS constellations. */
typedef struct {

  /* Optional */
  /*  Secondary GNSS Constellation Configuration */
  uint8_t secondaryGnssConfig_valid;  /**< Must be set to true if secondaryGnssConfig is being passed */
  qmiLocGNSSConstellEnumT_v02 secondaryGnssConfig;
  /**<   Specifies the secondary GNSS constellation configuration. \n
 Primary GNSS bands are as follows: \n
 - GPS L1 \n
 - GLONASS G1 \n
 - BDS B1i and BDS B1c \n
 - Gallileo E1a \n
 - QZSS L1 \n
 - NavIc L5 \n
 All other GNSS bands are considered secondary GNSS bands.
 Set bits enable all secondary bands of specified GNSS system.
 Unset bits disable all secondary bands of specified GNSS system.
 Valid bitmasks: \n
      - eQMI_SYSTEM_GPS (0x01) --  Enable GPS \n
      - eQMI_SYSTEM_GLO (0x02) --  Enable GLONASS \n
      - eQMI_SYSTEM_BDS (0x04) --  Enable BDS \n
      - eQMI_SYSTEM_GAL (0x08) --  Enable Galileo \n
      - eQMI_SYSTEM_QZSS (0x10) --  Enable QZSS \n
      - eQMI_SYSTEM_NAVIC (0x20) --  Enable NavIC
 */
}qmiLocSetMultibandConfigReqMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Used by the control point to query the multiband
                      configuration for all GNSS constellations. */
typedef struct {

  /* Mandatory */
  /*  Status of the Request */
  qmiLocStatusEnumT_v02 status;
  /**<   Status of the request.
 Values: \n
      - eQMI_LOC_SUCCESS (0) --  Request was completed successfully \n
      - eQMI_LOC_GENERAL_FAILURE (1) --  Request failed because of a general failure \n
      - eQMI_LOC_UNSUPPORTED (2) --  Request failed because it is not supported \n
      - eQMI_LOC_INVALID_PARAMETER (3) --  Request failed because it contained invalid parameters \n
      - eQMI_LOC_ENGINE_BUSY (4) --  Request failed because the engine is busy \n
      - eQMI_LOC_PHONE_OFFLINE (5) --  Request failed because the phone is offline \n
      - eQMI_LOC_TIMEOUT (6) --  Request failed because it has timed out \n
      - eQMI_LOC_CONFIG_NOT_SUPPORTED (7) --  Request failed because an undefined configuration was requested \n
      - eQMI_LOC_INSUFFICIENT_MEMORY (8) --  Request failed because the engine could not allocate sufficient memory for the request \n
      - eQMI_LOC_MAX_GEOFENCE_PROGRAMMED (9) --  Request failed because the maximum number of Geofences are already programmed \n
      - eQMI_LOC_XTRA_VERSION_CHECK_FAILURE (10) --  Location service failed because of an XTRA version-based file format check failure \n
      - eQMI_LOC_GNSS_DISABLED (11) --  Request failed because the location service is disabled
 */

  /* Optional */
  /*  Secondary GNSS Constellation Configuration */
  uint8_t secondaryGnssConfig_valid;  /**< Must be set to true if secondaryGnssConfig is being passed */
  qmiLocGNSSConstellEnumT_v02 secondaryGnssConfig;
  /**<   Specifies the secondary GNSS constellation configuration.
 Primary GNSS bands are as follows: \n
 - GPS L1 \n
 - GLONASS G1 \n
 - BDS B1i and BDS B1c \n
 - Galileo E1a \n
 - QZSS L1 \n
 - NavIc L5 \n
 All other GNSS bands are considered secondary GNSS bands. \n
 Set bit -- All secondary bands of specified GNSS system are enabled. \n
 Unset bit -- All secondary bands of specified GNSS system are disabled. \n
 Valid bitmasks: \n
      - eQMI_SYSTEM_GPS (0x01) --  Enable GPS \n
      - eQMI_SYSTEM_GLO (0x02) --  Enable GLONASS \n
      - eQMI_SYSTEM_BDS (0x04) --  Enable BDS \n
      - eQMI_SYSTEM_GAL (0x08) --  Enable Galileo \n
      - eQMI_SYSTEM_QZSS (0x10) --  Enable QZSS \n
      - eQMI_SYSTEM_NAVIC (0x20) --  Enable NavIC
 */
}qmiLocGetMultibandConfigIndMsgT_v02;  /* Message */
/**
    @}
  */

/** @addtogroup loc_qmi_enums
    @{
  */
typedef enum {
  QMILOCLATENCYINFOTYPEENUMT_MIN_ENUM_VAL_V02 = -2147483647, /**< To force a 32 bit signed enum.  Do not change or use*/
  eQMI_LOC_LATENCY_INFO_TYPE_INVALID_V02 = 0, /**<  Invalid latency information type. \n  */
  eQMI_LOC_LATENCY_INFO_TYPE_MEASUREMENT_V02 = 1, /**<  Latency information type measurement.  */
  QMILOCLATENCYINFOTYPEENUMT_MAX_ENUM_VAL_V02 = 2147483647 /**< To force a 32 bit signed enum.  Do not change or use*/
}qmiLocLatencyInfoTypeEnumT_v02;
/**
    @}
  */

/** @addtogroup loc_qmi_messages
    @{
  */
/** Indication Message; Sends the latency information to the control point. */
typedef struct {

  /* Mandatory */
  /*  Latency Information Type */
  qmiLocLatencyInfoTypeEnumT_v02 latencyInfo;
  /**<   Latency information type. Values: \n
      - eQMI_LOC_LATENCY_INFO_TYPE_INVALID (0) --  Invalid latency information type. \n
      - eQMI_LOC_LATENCY_INFO_TYPE_MEASUREMENT (1) --  Latency information type measurement.
 */

  /* Optional */
  /*  Latency Measurement at Checkpoint 1 */
  uint8_t sysTickAtChkPt1_valid;  /**< Must be set to true if sysTickAtChkPt1 is being passed */
  uint64_t sysTickAtChkPt1;
  /**<   Latency measurement at checkpoint 1.  \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 2 */
  uint8_t sysTickAtChkPt2_valid;  /**< Must be set to true if sysTickAtChkPt2 is being passed */
  uint64_t sysTickAtChkPt2;
  /**<   Latency measurement at checkpoint 2.  \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 3 */
  uint8_t sysTickAtChkPt3_valid;  /**< Must be set to true if sysTickAtChkPt3 is being passed */
  uint64_t sysTickAtChkPt3;
  /**<   Latency measurement at checkpoint 3.  \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 4 */
  uint8_t sysTickAtChkPt4_valid;  /**< Must be set to true if sysTickAtChkPt4 is being passed */
  uint64_t sysTickAtChkPt4;
  /**<   Latency measurement at checkpoint 4 \n
      - Units -- ticks  */

  /* Optional */
  /*  Latency Measurement at Checkpoint 5 */
  uint8_t sysTickAtChkPt5_valid;  /**< Must be set to true if sysTickAtChkPt5 is being passed */
  uint64_t sysTickAtChkPt5;
  /**<   Latency measurement at checkpoint 5.  \n
      - Units -- ticks  */

  /* Optional */
  /*  Latency Measurement at Checkpoint 6 */
  uint8_t sysTickAtChkPt6_valid;  /**< Must be set to true if sysTickAtChkPt6 is being passed */
  uint64_t sysTickAtChkPt6;
  /**<   Latency measurement at checkpoint 6. \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 7 */
  uint8_t sysTickAtChkPt7_valid;  /**< Must be set to true if sysTickAtChkPt7 is being passed */
  uint64_t sysTickAtChkPt7;
  /**<   Latency measurement at checkpoint 7. \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 8 */
  uint8_t sysTickAtChkPt8_valid;  /**< Must be set to true if sysTickAtChkPt8 is being passed */
  uint64_t sysTickAtChkPt8;
  /**<   Latency measurement at checkpoint 8. \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 9 */
  uint8_t sysTickAtChkPt9_valid;  /**< Must be set to true if sysTickAtChkPt9 is being passed */
  uint64_t sysTickAtChkPt9;
  /**<   Latency measurement at checkpoint 9. \n
      - Units -- ticks */

  /* Optional */
  /*  Latency Measurement at Checkpoint 10 */
  uint8_t sysTickAtChkPt10_valid;  /**< Must be set to true if sysTickAtChkPt10 is being passed */
  uint64_t sysTickAtChkPt10;
  /**<   Latency measurement at checkpoint 10.  \n
      - Units -- ticks */

  /* Optional */
  /*  Measurement Report Frame Count */
  uint8_t fCountOfMeasBlk_valid;  /**< Must be set to true if fCountOfMeasBlk is being passed */
  uint32_t fCountOfMeasBlk;
  /**<   Time information to tie measblk and latency IPC. */
}qmiLocLatencyInformationIndMsgT_v02;  /* Message */
/**
    @}
  */

/* Conditional compilation tags for message removal */
//#define REMOVE_QMI_LOC_ADD_CIRCULAR_GEOFENCE_V02
//#define REMOVE_QMI_LOC_ADD_GEOFENCE_CONTEXT_V02
//#define REMOVE_QMI_LOC_CROWDSOURCE_MANAGER_CONTROL_V02
//#define REMOVE_QMI_LOC_CROWDSOURCE_MANAGER_READ_DATA_V02
//#define REMOVE_QMI_LOC_DC_REPORT_V02
//#define REMOVE_QMI_LOC_DELETE_ASSIST_DATA_V02
//#define REMOVE_QMI_LOC_DELETE_GEOFENCE_V02
//#define REMOVE_QMI_LOC_DELETE_GEOFENCE_CONTEXT_V02
//#define REMOVE_QMI_LOC_DELETE_GNSS_SERVICE_DATA_V02
//#define REMOVE_QMI_LOC_DELETE_SUPL_CERTIFICATE_V02
//#define REMOVE_QMI_LOC_EDIT_GEOFENCE_V02
//#define REMOVE_QMI_LOC_ENABLE_POSITION_ASSISTED_CLOCK_EST_V02
//#define REMOVE_QMI_LOC_ENABLE_POSITION_INJECTION_TEST_MODE_V02
//#define REMOVE_QMI_LOC_EVENT_BATCHING_STATUS_V02
//#define REMOVE_QMI_LOC_EVENT_BATCH_FULL_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_BDS_EPHEMERIS_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_BS_OBS_DATA_SERVICE_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_DBT_POSITION_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_DBT_SESSION_STATUS_V02
//#define REMOVE_QMI_LOC_EVENT_ENGINE_LOCK_STATE_V02
//#define REMOVE_QMI_LOC_EVENT_ENGINE_STATE_V02
//#define REMOVE_QMI_LOC_EVENT_FDCL_SERVICE_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_FIX_SESSION_STATE_V02
//#define REMOVE_QMI_LOC_EVENT_GALILEO_EPHEMERIS_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_GDT_DOWNLOAD_BEGIN_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_GDT_DOWNLOAD_END_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_GDT_RECEIVE_DONE_V02
//#define REMOVE_QMI_LOC_EVENT_GDT_UPLOAD_BEGIN_STATUS_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_GDT_UPLOAD_END_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_GEOFENCE_BATCHED_BREACH_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_GEOFENCE_BATCHED_DWELL_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_GEOFENCE_BREACH_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_GEOFENCE_GEN_ALERT_V02
//#define REMOVE_QMI_LOC_EVENT_GEOFENCE_PROXIMITY_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_GET_TIME_ZONE_INFO_V02
//#define REMOVE_QMI_LOC_EVENT_GLONASS_EPHEMERIS_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_GNSS_MEASUREMENT_REPORT_IND_V02
//#define REMOVE_QMI_LOC_EVENT_GNSS_SV_INFO_V02
//#define REMOVE_QMI_LOC_EVENT_GPS_EPHEMERIS_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_INJECT_POSITION_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_INJECT_PREDICTED_ORBITS_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_INJECT_SRN_AP_DATA_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_INJECT_TIME_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_INJECT_WIFI_AP_DATA_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_INTERNAL_STATUS_REPORT_IND_V02
//#define REMOVE_QMI_LOC_EVENT_LIVE_BATCHED_POSITION_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_LOCATION_SERVER_CONNECTION_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_MOTION_DATA_CONTROL_V02
//#define REMOVE_QMI_LOC_EVENT_NI_GEOFENCE_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_EVENT_NI_NOTIFY_VERIFY_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_NMEA_V02
//#define REMOVE_QMI_LOC_EVENT_PEDOMETER_CONTROL_V02
//#define REMOVE_QMI_LOC_EVENT_POSITION_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_QUERY_XTRA_INFO_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_QZSS_EPHEMERIS_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_SAP_INS_PARAMETERS_V02
//#define REMOVE_QMI_LOC_EVENT_SENSOR_STREAMING_READY_STATUS_V02
//#define REMOVE_QMI_LOC_EVENT_SET_SPI_STREAMING_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_SV_POLYNOMIAL_REPORT_IND_V02
//#define REMOVE_QMI_LOC_EVENT_TIME_SYNC_REQ_V02
//#define REMOVE_QMI_LOC_EVENT_UNPROPAGATED_POSITION_REPORT_V02
//#define REMOVE_QMI_LOC_EVENT_VEHICLE_DATA_READY_STATUS_V02
//#define REMOVE_QMI_LOC_EVENT_WIFI_REQ_V02
//#define REMOVE_QMI_LOC_GDT_DOWNLOAD_BEGIN_STATUS_V02
//#define REMOVE_QMI_LOC_GDT_DOWNLOAD_END_STATUS_V02
//#define REMOVE_QMI_LOC_GDT_DOWNLOAD_READY_STATUS_V02
//#define REMOVE_QMI_LOC_GDT_RECEIVE_DONE_STATUS_V02
//#define REMOVE_QMI_LOC_GDT_UPLOAD_BEGIN_STATUS_V02
//#define REMOVE_QMI_LOC_GDT_UPLOAD_END_V02
//#define REMOVE_QMI_LOC_GET_AVAILABLE_WWAN_POSITION_V02
//#define REMOVE_QMI_LOC_GET_BAND_MEASUREMENT_METRICS_V02
//#define REMOVE_QMI_LOC_GET_BATCH_SIZE_V02
//#define REMOVE_QMI_LOC_GET_BEST_AVAILABLE_POSITION_V02
//#define REMOVE_QMI_LOC_GET_BLACKLIST_SV_V02
//#define REMOVE_QMI_LOC_GET_BS_OBS_DATA_V02
//#define REMOVE_QMI_LOC_GET_CONSTELLATION_CONTROL_V02
//#define REMOVE_QMI_LOC_GET_CRADLE_MOUNT_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_ENGINE_LOCK_V02
//#define REMOVE_QMI_LOC_GET_EXTERNAL_POWER_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_FDCL_BS_LIST_V02
//#define REMOVE_QMI_LOC_GET_FIX_CRITERIA_V02
//#define REMOVE_QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_GNSS_PDR_MODE_V02
//#define REMOVE_QMI_LOC_GET_LOW_POWER_MODE_V02
//#define REMOVE_QMI_LOC_GET_MAG_CAL_STATE_PDR_V02
//#define REMOVE_QMI_LOC_GET_MIN_GPS_WEEK_NUMBER_V02
//#define REMOVE_QMI_LOC_GET_MULTIBAND_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_NI_GEOFENCE_ID_LIST_V02
//#define REMOVE_QMI_LOC_GET_NMEA_TYPES_V02
//#define REMOVE_QMI_LOC_GET_OPERATION_MODE_V02
//#define REMOVE_QMI_LOC_GET_PARAMETER_V02
//#define REMOVE_QMI_LOC_GET_POSITION_ENGINE_CONFIG_PARAMETERS_V02
//#define REMOVE_QMI_LOC_GET_PREDICTED_ORBITS_DATA_SOURCE_V02
//#define REMOVE_QMI_LOC_GET_PREDICTED_ORBITS_DATA_VALIDITY_V02
//#define REMOVE_QMI_LOC_GET_PROTOCOL_CONFIG_PARAMETERS_V02
//#define REMOVE_QMI_LOC_GET_REGISTERED_EVENTS_V02
//#define REMOVE_QMI_LOC_GET_ROBUST_LOCATION_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_SBAS_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_SENSOR_CONTROL_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_V02
//#define REMOVE_QMI_LOC_GET_SENSOR_PROPERTIES_V02
//#define REMOVE_QMI_LOC_GET_SERVER_V02
//#define REMOVE_QMI_LOC_GET_SERVICE_REVISION_V02
//#define REMOVE_QMI_LOC_GET_STATISTICS_CONFIG_V02
//#define REMOVE_QMI_LOC_GET_SUPPORTED_FEATURE_V02
//#define REMOVE_QMI_LOC_GET_SUPPORTED_FIELDS_V02
//#define REMOVE_QMI_LOC_GET_SUPPORTED_MSGS_V02
//#define REMOVE_QMI_LOC_GET_XTRA_T_SESSION_CONTROL_V02
//#define REMOVE_QMI_LOC_GNSS_STATISTICS_REPORT_V02
//#define REMOVE_QMI_LOC_GTP_AP_STATUS_V02
//#define REMOVE_QMI_LOC_INFORM_CLIENT_REVISION_V02
//#define REMOVE_QMI_LOC_INFORM_LOCATION_SERVER_CONN_STATUS_V02
//#define REMOVE_QMI_LOC_INFORM_NI_USER_RESPONSE_V02
//#define REMOVE_QMI_LOC_INJECT_APCACHE_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_APDONOTCACHE_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_ENV_AIDING_V02
//#define REMOVE_QMI_LOC_INJECT_FDCL_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_GSM_CELL_INFO_V02
//#define REMOVE_QMI_LOC_INJECT_GTP_CLIENT_DOWNLOADED_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_MOTION_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_NETWORK_INITIATED_MESSAGE_V02
//#define REMOVE_QMI_LOC_INJECT_PLATFORM_POWER_STATE_V02
//#define REMOVE_QMI_LOC_INJECT_POSITION_V02
//#define REMOVE_QMI_LOC_INJECT_PREDICTED_ORBITS_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_SENSOR_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_SRN_AP_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_SUBSCRIBER_ID_V02
//#define REMOVE_QMI_LOC_INJECT_SUPL_CERTIFICATE_V02
//#define REMOVE_QMI_LOC_INJECT_TDSCDMA_CELL_INFO_V02
//#define REMOVE_QMI_LOC_INJECT_TEST_POSITION_V02
//#define REMOVE_QMI_LOC_INJECT_TIME_SYNC_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_TIME_ZONE_INFO_V02
//#define REMOVE_QMI_LOC_INJECT_UTC_TIME_V02
//#define REMOVE_QMI_LOC_INJECT_VEHICLE_SENSOR_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_WCDMA_CELL_INFO_V02
//#define REMOVE_QMI_LOC_INJECT_WIFI_AP_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_WIFI_POSITION_V02
//#define REMOVE_QMI_LOC_INJECT_XTRA_DATA_V02
//#define REMOVE_QMI_LOC_INJECT_XTRA_PCID_V02
//#define REMOVE_QMI_LOC_LATENCY_INFORMATION_V02
//#define REMOVE_QMI_LOC_LOCATION_REQUEST_NOTIFICATION_V02
//#define REMOVE_QMI_LOC_NOTIFY_WIFI_ATTACHMENT_STATUS_V02
//#define REMOVE_QMI_LOC_NOTIFY_WIFI_ENABLED_STATUS_V02
//#define REMOVE_QMI_LOC_NOTIFY_WIFI_STATUS_V02
//#define REMOVE_QMI_LOC_PEDOMETER_REPORT_V02
//#define REMOVE_QMI_LOC_QUERY_AON_CONFIG_V02
//#define REMOVE_QMI_LOC_QUERY_GEOFENCE_V02
//#define REMOVE_QMI_LOC_QUERY_GNSS_ENERGY_CONSUMED_V02
//#define REMOVE_QMI_LOC_QUERY_OTB_ACCUMULATED_DISTANCE_V02
//#define REMOVE_QMI_LOC_QUERY_XTRA_INFO_V02
//#define REMOVE_QMI_LOC_READ_FROM_BATCH_V02
//#define REMOVE_QMI_LOC_REGISTER_MASTER_CLIENT_V02
//#define REMOVE_QMI_LOC_REG_EVENTS_V02
//#define REMOVE_QMI_LOC_RELEASE_BATCH_V02
//#define REMOVE_QMI_LOC_SECURE_GET_AVAILABLE_POSITION_V02
//#define REMOVE_QMI_LOC_SET_BLACKLIST_SV_V02
//#define REMOVE_QMI_LOC_SET_CONSTELLATION_CONTROL_V02
//#define REMOVE_QMI_LOC_SET_CONSTRAINED_TUNC_MODE_V02
//#define REMOVE_QMI_LOC_SET_CRADLE_MOUNT_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_ENGINE_LOCK_V02
//#define REMOVE_QMI_LOC_SET_EXTERNAL_POWER_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_GEOFENCE_ENGINE_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_V02
//#define REMOVE_QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_GNSS_PDR_MODE_V02
//#define REMOVE_QMI_LOC_SET_INTERNAL_STATUS_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_LOW_POWER_MODE_V02
//#define REMOVE_QMI_LOC_SET_MIN_GPS_WEEK_NUMBER_V02
//#define REMOVE_QMI_LOC_SET_MULTIBAND_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_NMEA_TYPES_V02
//#define REMOVE_QMI_LOC_SET_OPERATION_MODE_V02
//#define REMOVE_QMI_LOC_SET_PARAMETER_V02
//#define REMOVE_QMI_LOC_SET_POSITION_ENGINE_CONFIG_PARAMETERS_V02
//#define REMOVE_QMI_LOC_SET_PREMIUM_SERVICES_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_PROTOCOL_CONFIG_PARAMETERS_V02
//#define REMOVE_QMI_LOC_SET_ROBUST_LOCATION_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_SBAS_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_SENSOR_CONTROL_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_V02
//#define REMOVE_QMI_LOC_SET_SENSOR_PROPERTIES_V02
//#define REMOVE_QMI_LOC_SET_SERVER_V02
//#define REMOVE_QMI_LOC_SET_SPI_STATUS_V02
//#define REMOVE_QMI_LOC_SET_STATISTICS_CONFIG_V02
//#define REMOVE_QMI_LOC_SET_XTRA_T_SESSION_CONTROL_V02
//#define REMOVE_QMI_LOC_SET_XTRA_VERSION_CHECK_V02
//#define REMOVE_QMI_LOC_START_V02
//#define REMOVE_QMI_LOC_START_BATCHING_V02
//#define REMOVE_QMI_LOC_START_DBT_V02
//#define REMOVE_QMI_LOC_START_LISTEN_POSITION_V02
//#define REMOVE_QMI_LOC_START_OUTDOOR_TRIP_BATCHING_V02
//#define REMOVE_QMI_LOC_STOP_V02
//#define REMOVE_QMI_LOC_STOP_BATCHING_V02
//#define REMOVE_QMI_LOC_STOP_DBT_V02
//#define REMOVE_QMI_LOC_STOP_LISTEN_POSITION_V02
//#define REMOVE_QMI_LOC_SYSTEM_INFO_V02
//#define REMOVE_QMI_LOC_WWAN_OUT_OF_SERVICE_NOTIFICATION_V02

/*Service Message Definition*/
/** @addtogroup loc_qmi_msg_ids
    @{
  */
#define QMI_LOC_GET_SUPPORTED_MSGS_REQ_V02 0x001E
#define QMI_LOC_GET_SUPPORTED_MSGS_RESP_V02 0x001E
#define QMI_LOC_GET_SUPPORTED_FIELDS_REQ_V02 0x001F
#define QMI_LOC_GET_SUPPORTED_FIELDS_RESP_V02 0x001F
#define QMI_LOC_INFORM_CLIENT_REVISION_REQ_V02 0x0020
#define QMI_LOC_INFORM_CLIENT_REVISION_RESP_V02 0x0020
#define QMI_LOC_REG_EVENTS_REQ_V02 0x0021
#define QMI_LOC_REG_EVENTS_RESP_V02 0x0021
#define QMI_LOC_START_REQ_V02 0x0022
#define QMI_LOC_START_RESP_V02 0x0022
#define QMI_LOC_STOP_REQ_V02 0x0023
#define QMI_LOC_STOP_RESP_V02 0x0023
#define QMI_LOC_EVENT_POSITION_REPORT_IND_V02 0x0024
#define QMI_LOC_EVENT_GNSS_SV_INFO_IND_V02 0x0025
#define QMI_LOC_EVENT_NMEA_IND_V02 0x0026
#define QMI_LOC_EVENT_NI_NOTIFY_VERIFY_REQ_IND_V02 0x0027
#define QMI_LOC_EVENT_INJECT_TIME_REQ_IND_V02 0x0028
#define QMI_LOC_EVENT_INJECT_PREDICTED_ORBITS_REQ_IND_V02 0x0029
#define QMI_LOC_EVENT_INJECT_POSITION_REQ_IND_V02 0x002A
#define QMI_LOC_EVENT_ENGINE_STATE_IND_V02 0x002B
#define QMI_LOC_EVENT_FIX_SESSION_STATE_IND_V02 0x002C
#define QMI_LOC_EVENT_WIFI_REQ_IND_V02 0x002D
#define QMI_LOC_EVENT_SENSOR_STREAMING_READY_STATUS_IND_V02 0x002E
#define QMI_LOC_EVENT_TIME_SYNC_REQ_IND_V02 0x002F
#define QMI_LOC_EVENT_SET_SPI_STREAMING_REPORT_IND_V02 0x0030
#define QMI_LOC_EVENT_LOCATION_SERVER_CONNECTION_REQ_IND_V02 0x0031
#define QMI_LOC_GET_SERVICE_REVISION_REQ_V02 0x0032
#define QMI_LOC_GET_SERVICE_REVISION_RESP_V02 0x0032
#define QMI_LOC_GET_SERVICE_REVISION_IND_V02 0x0032
#define QMI_LOC_GET_FIX_CRITERIA_REQ_V02 0x0033
#define QMI_LOC_GET_FIX_CRITERIA_RESP_V02 0x0033
#define QMI_LOC_GET_FIX_CRITERIA_IND_V02 0x0033
#define QMI_LOC_NI_USER_RESPONSE_REQ_V02 0x0034
#define QMI_LOC_NI_USER_RESPONSE_RESP_V02 0x0034
#define QMI_LOC_NI_USER_RESPONSE_IND_V02 0x0034
#define QMI_LOC_INJECT_PREDICTED_ORBITS_DATA_REQ_V02 0x0035
#define QMI_LOC_INJECT_PREDICTED_ORBITS_DATA_RESP_V02 0x0035
#define QMI_LOC_INJECT_PREDICTED_ORBITS_DATA_IND_V02 0x0035
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_SOURCE_REQ_V02 0x0036
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_SOURCE_RESP_V02 0x0036
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_SOURCE_IND_V02 0x0036
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_VALIDITY_REQ_V02 0x0037
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_VALIDITY_RESP_V02 0x0037
#define QMI_LOC_GET_PREDICTED_ORBITS_DATA_VALIDITY_IND_V02 0x0037
#define QMI_LOC_INJECT_UTC_TIME_REQ_V02 0x0038
#define QMI_LOC_INJECT_UTC_TIME_RESP_V02 0x0038
#define QMI_LOC_INJECT_UTC_TIME_IND_V02 0x0038
#define QMI_LOC_INJECT_POSITION_REQ_V02 0x0039
#define QMI_LOC_INJECT_POSITION_RESP_V02 0x0039
#define QMI_LOC_INJECT_POSITION_IND_V02 0x0039
#define QMI_LOC_SET_ENGINE_LOCK_REQ_V02 0x003A
#define QMI_LOC_SET_ENGINE_LOCK_RESP_V02 0x003A
#define QMI_LOC_SET_ENGINE_LOCK_IND_V02 0x003A
#define QMI_LOC_GET_ENGINE_LOCK_REQ_V02 0x003B
#define QMI_LOC_GET_ENGINE_LOCK_RESP_V02 0x003B
#define QMI_LOC_GET_ENGINE_LOCK_IND_V02 0x003B
#define QMI_LOC_SET_SBAS_CONFIG_REQ_V02 0x003C
#define QMI_LOC_SET_SBAS_CONFIG_RESP_V02 0x003C
#define QMI_LOC_SET_SBAS_CONFIG_IND_V02 0x003C
#define QMI_LOC_GET_SBAS_CONFIG_REQ_V02 0x003D
#define QMI_LOC_GET_SBAS_CONFIG_RESP_V02 0x003D
#define QMI_LOC_GET_SBAS_CONFIG_IND_V02 0x003D
#define QMI_LOC_SET_NMEA_TYPES_REQ_V02 0x003E
#define QMI_LOC_SET_NMEA_TYPES_RESP_V02 0x003E
#define QMI_LOC_SET_NMEA_TYPES_IND_V02 0x003E
#define QMI_LOC_GET_NMEA_TYPES_REQ_V02 0x003F
#define QMI_LOC_GET_NMEA_TYPES_RESP_V02 0x003F
#define QMI_LOC_GET_NMEA_TYPES_IND_V02 0x003F
#define QMI_LOC_SET_LOW_POWER_MODE_REQ_V02 0x0040
#define QMI_LOC_SET_LOW_POWER_MODE_RESP_V02 0x0040
#define QMI_LOC_SET_LOW_POWER_MODE_IND_V02 0x0040
#define QMI_LOC_GET_LOW_POWER_MODE_REQ_V02 0x0041
#define QMI_LOC_GET_LOW_POWER_MODE_RESP_V02 0x0041
#define QMI_LOC_GET_LOW_POWER_MODE_IND_V02 0x0041
#define QMI_LOC_SET_SERVER_REQ_V02 0x0042
#define QMI_LOC_SET_SERVER_RESP_V02 0x0042
#define QMI_LOC_SET_SERVER_IND_V02 0x0042
#define QMI_LOC_GET_SERVER_REQ_V02 0x0043
#define QMI_LOC_GET_SERVER_RESP_V02 0x0043
#define QMI_LOC_GET_SERVER_IND_V02 0x0043
#define QMI_LOC_DELETE_ASSIST_DATA_REQ_V02 0x0044
#define QMI_LOC_DELETE_ASSIST_DATA_RESP_V02 0x0044
#define QMI_LOC_DELETE_ASSIST_DATA_IND_V02 0x0044
#define QMI_LOC_SET_XTRA_T_SESSION_CONTROL_REQ_V02 0x0045
#define QMI_LOC_SET_XTRA_T_SESSION_CONTROL_RESP_V02 0x0045
#define QMI_LOC_SET_XTRA_T_SESSION_CONTROL_IND_V02 0x0045
#define QMI_LOC_GET_XTRA_T_SESSION_CONTROL_REQ_V02 0x0046
#define QMI_LOC_GET_XTRA_T_SESSION_CONTROL_RESP_V02 0x0046
#define QMI_LOC_GET_XTRA_T_SESSION_CONTROL_IND_V02 0x0046
#define QMI_LOC_INJECT_WIFI_POSITION_REQ_V02 0x0047
#define QMI_LOC_INJECT_WIFI_POSITION_RESP_V02 0x0047
#define QMI_LOC_INJECT_WIFI_POSITION_IND_V02 0x0047
#define QMI_LOC_NOTIFY_WIFI_STATUS_REQ_V02 0x0048
#define QMI_LOC_NOTIFY_WIFI_STATUS_RESP_V02 0x0048
#define QMI_LOC_NOTIFY_WIFI_STATUS_IND_V02 0x0048
#define QMI_LOC_GET_REGISTERED_EVENTS_REQ_V02 0x0049
#define QMI_LOC_GET_REGISTERED_EVENTS_RESP_V02 0x0049
#define QMI_LOC_GET_REGISTERED_EVENTS_IND_V02 0x0049
#define QMI_LOC_SET_OPERATION_MODE_REQ_V02 0x004A
#define QMI_LOC_SET_OPERATION_MODE_RESP_V02 0x004A
#define QMI_LOC_SET_OPERATION_MODE_IND_V02 0x004A
#define QMI_LOC_GET_OPERATION_MODE_REQ_V02 0x004B
#define QMI_LOC_GET_OPERATION_MODE_RESP_V02 0x004B
#define QMI_LOC_GET_OPERATION_MODE_IND_V02 0x004B
#define QMI_LOC_SET_SPI_STATUS_REQ_V02 0x004C
#define QMI_LOC_SET_SPI_STATUS_RESP_V02 0x004C
#define QMI_LOC_SET_SPI_STATUS_IND_V02 0x004C
#define QMI_LOC_INJECT_SENSOR_DATA_REQ_V02 0x004D
#define QMI_LOC_INJECT_SENSOR_DATA_RESP_V02 0x004D
#define QMI_LOC_INJECT_SENSOR_DATA_IND_V02 0x004D
#define QMI_LOC_INJECT_TIME_SYNC_DATA_REQ_V02 0x004E
#define QMI_LOC_INJECT_TIME_SYNC_DATA_RESP_V02 0x004E
#define QMI_LOC_INJECT_TIME_SYNC_DATA_IND_V02 0x004E
#define QMI_LOC_SET_CRADLE_MOUNT_CONFIG_REQ_V02 0x004F
#define QMI_LOC_SET_CRADLE_MOUNT_CONFIG_RESP_V02 0x004F
#define QMI_LOC_SET_CRADLE_MOUNT_CONFIG_IND_V02 0x004F
#define QMI_LOC_GET_CRADLE_MOUNT_CONFIG_REQ_V02 0x0050
#define QMI_LOC_GET_CRADLE_MOUNT_CONFIG_RESP_V02 0x0050
#define QMI_LOC_GET_CRADLE_MOUNT_CONFIG_IND_V02 0x0050
#define QMI_LOC_SET_EXTERNAL_POWER_CONFIG_REQ_V02 0x0051
#define QMI_LOC_SET_EXTERNAL_POWER_CONFIG_RESP_V02 0x0051
#define QMI_LOC_SET_EXTERNAL_POWER_CONFIG_IND_V02 0x0051
#define QMI_LOC_GET_EXTERNAL_POWER_CONFIG_REQ_V02 0x0052
#define QMI_LOC_GET_EXTERNAL_POWER_CONFIG_RESP_V02 0x0052
#define QMI_LOC_GET_EXTERNAL_POWER_CONFIG_IND_V02 0x0052
#define QMI_LOC_INFORM_LOCATION_SERVER_CONN_STATUS_REQ_V02 0x0053
#define QMI_LOC_INFORM_LOCATION_SERVER_CONN_STATUS_RESP_V02 0x0053
#define QMI_LOC_INFORM_LOCATION_SERVER_CONN_STATUS_IND_V02 0x0053
#define QMI_LOC_SET_PROTOCOL_CONFIG_PARAMETERS_REQ_V02 0x0054
#define QMI_LOC_SET_PROTOCOL_CONFIG_PARAMETERS_RESP_V02 0x0054
#define QMI_LOC_SET_PROTOCOL_CONFIG_PARAMETERS_IND_V02 0x0054
#define QMI_LOC_GET_PROTOCOL_CONFIG_PARAMETERS_REQ_V02 0x0055
#define QMI_LOC_GET_PROTOCOL_CONFIG_PARAMETERS_RESP_V02 0x0055
#define QMI_LOC_GET_PROTOCOL_CONFIG_PARAMETERS_IND_V02 0x0055
#define QMI_LOC_SET_SENSOR_CONTROL_CONFIG_REQ_V02 0x0056
#define QMI_LOC_SET_SENSOR_CONTROL_CONFIG_RESP_V02 0x0056
#define QMI_LOC_SET_SENSOR_CONTROL_CONFIG_IND_V02 0x0056
#define QMI_LOC_GET_SENSOR_CONTROL_CONFIG_REQ_V02 0x0057
#define QMI_LOC_GET_SENSOR_CONTROL_CONFIG_RESP_V02 0x0057
#define QMI_LOC_GET_SENSOR_CONTROL_CONFIG_IND_V02 0x0057
#define QMI_LOC_SET_SENSOR_PROPERTIES_REQ_V02 0x0058
#define QMI_LOC_SET_SENSOR_PROPERTIES_RESP_V02 0x0058
#define QMI_LOC_SET_SENSOR_PROPERTIES_IND_V02 0x0058
#define QMI_LOC_GET_SENSOR_PROPERTIES_REQ_V02 0x0059
#define QMI_LOC_GET_SENSOR_PROPERTIES_RESP_V02 0x0059
#define QMI_LOC_GET_SENSOR_PROPERTIES_IND_V02 0x0059
#define QMI_LOC_SET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_REQ_V02 0x005A
#define QMI_LOC_SET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_RESP_V02 0x005A
#define QMI_LOC_SET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_IND_V02 0x005A
#define QMI_LOC_GET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_REQ_V02 0x005B
#define QMI_LOC_GET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_RESP_V02 0x005B
#define QMI_LOC_GET_SENSOR_PERFORMANCE_CONTROL_CONFIGURATION_IND_V02 0x005B
#define QMI_LOC_INJECT_SUPL_CERTIFICATE_REQ_V02 0x005C
#define QMI_LOC_INJECT_SUPL_CERTIFICATE_RESP_V02 0x005C
#define QMI_LOC_INJECT_SUPL_CERTIFICATE_IND_V02 0x005C
#define QMI_LOC_DELETE_SUPL_CERTIFICATE_REQ_V02 0x005D
#define QMI_LOC_DELETE_SUPL_CERTIFICATE_RESP_V02 0x005D
#define QMI_LOC_DELETE_SUPL_CERTIFICATE_IND_V02 0x005D
#define QMI_LOC_SET_POSITION_ENGINE_CONFIG_PARAMETERS_REQ_V02 0x005E
#define QMI_LOC_SET_POSITION_ENGINE_CONFIG_PARAMETERS_RESP_V02 0x005E
#define QMI_LOC_SET_POSITION_ENGINE_CONFIG_PARAMETERS_IND_V02 0x005E
#define QMI_LOC_GET_POSITION_ENGINE_CONFIG_PARAMETERS_REQ_V02 0x005F
#define QMI_LOC_GET_POSITION_ENGINE_CONFIG_PARAMETERS_RESP_V02 0x005F
#define QMI_LOC_GET_POSITION_ENGINE_CONFIG_PARAMETERS_IND_V02 0x005F
#define QMI_LOC_EVENT_NI_GEOFENCE_NOTIFICATION_IND_V02 0x0060
#define QMI_LOC_EVENT_GEOFENCE_GEN_ALERT_IND_V02 0x0061
#define QMI_LOC_EVENT_GEOFENCE_BREACH_NOTIFICATION_IND_V02 0x0062
#define QMI_LOC_ADD_CIRCULAR_GEOFENCE_REQ_V02 0x0063
#define QMI_LOC_ADD_CIRCULAR_GEOFENCE_RESP_V02 0x0063
#define QMI_LOC_ADD_CIRCULAR_GEOFENCE_IND_V02 0x0063
#define QMI_LOC_DELETE_GEOFENCE_REQ_V02 0x0064
#define QMI_LOC_DELETE_GEOFENCE_RESP_V02 0x0064
#define QMI_LOC_DELETE_GEOFENCE_IND_V02 0x0064
#define QMI_LOC_QUERY_GEOFENCE_REQ_V02 0x0065
#define QMI_LOC_QUERY_GEOFENCE_RESP_V02 0x0065
#define QMI_LOC_QUERY_GEOFENCE_IND_V02 0x0065
#define QMI_LOC_EDIT_GEOFENCE_REQ_V02 0x0066
#define QMI_LOC_EDIT_GEOFENCE_RESP_V02 0x0066
#define QMI_LOC_EDIT_GEOFENCE_IND_V02 0x0066
#define QMI_LOC_GET_BEST_AVAILABLE_POSITION_REQ_V02 0x0067
#define QMI_LOC_GET_BEST_AVAILABLE_POSITION_RESP_V02 0x0067
#define QMI_LOC_GET_BEST_AVAILABLE_POSITION_IND_V02 0x0067
#define QMI_LOC_INJECT_MOTION_DATA_REQ_V02 0x0068
#define QMI_LOC_INJECT_MOTION_DATA_RESP_V02 0x0068
#define QMI_LOC_INJECT_MOTION_DATA_IND_V02 0x0068
#define QMI_LOC_GET_NI_GEOFENCE_ID_LIST_REQ_V02 0x0069
#define QMI_LOC_GET_NI_GEOFENCE_ID_LIST_RESP_V02 0x0069
#define QMI_LOC_GET_NI_GEOFENCE_ID_LIST_IND_V02 0x0069
#define QMI_LOC_INJECT_GSM_CELL_INFO_REQ_V02 0x006A
#define QMI_LOC_INJECT_GSM_CELL_INFO_RESP_V02 0x006A
#define QMI_LOC_INJECT_GSM_CELL_INFO_IND_V02 0x006A
#define QMI_LOC_INJECT_NETWORK_INITIATED_MESSAGE_REQ_V02 0x006B
#define QMI_LOC_INJECT_NETWORK_INITIATED_MESSAGE_RESP_V02 0x006B
#define QMI_LOC_INJECT_NETWORK_INITIATED_MESSAGE_IND_V02 0x006B
#define QMI_LOC_WWAN_OUT_OF_SERVICE_NOTIFICATION_REQ_V02 0x006C
#define QMI_LOC_WWAN_OUT_OF_SERVICE_NOTIFICATION_RESP_V02 0x006C
#define QMI_LOC_WWAN_OUT_OF_SERVICE_NOTIFICATION_IND_V02 0x006C
#define QMI_LOC_EVENT_PEDOMETER_CONTROL_IND_V02 0x006D
#define QMI_LOC_EVENT_MOTION_DATA_CONTROL_IND_V02 0x006E
#define QMI_LOC_PEDOMETER_REPORT_REQ_V02 0x006F
#define QMI_LOC_PEDOMETER_REPORT_RESP_V02 0x006F
#define QMI_LOC_PEDOMETER_REPORT_IND_V02 0x006F
#define QMI_LOC_INJECT_WCDMA_CELL_INFO_REQ_V02 0x0070
#define QMI_LOC_INJECT_WCDMA_CELL_INFO_RESP_V02 0x0070
#define QMI_LOC_INJECT_WCDMA_CELL_INFO_IND_V02 0x0070
#define QMI_LOC_INJECT_TDSCDMA_CELL_INFO_REQ_V02 0x0071
#define QMI_LOC_INJECT_TDSCDMA_CELL_INFO_RESP_V02 0x0071
#define QMI_LOC_INJECT_TDSCDMA_CELL_INFO_IND_V02 0x0071
#define QMI_LOC_INJECT_SUBSCRIBER_ID_REQ_V02 0x0072
#define QMI_LOC_INJECT_SUBSCRIBER_ID_RESP_V02 0x0072
#define QMI_LOC_INJECT_SUBSCRIBER_ID_IND_V02 0x0072
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONFIG_REQ_V02 0x0073
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONFIG_RESP_V02 0x0073
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONFIG_IND_V02 0x0073
#define QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_REQ_V02 0x0074
#define QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_RESP_V02 0x0074
#define QMI_LOC_GET_GEOFENCE_ENGINE_CONFIG_IND_V02 0x0074
#define QMI_LOC_GET_BATCH_SIZE_REQ_V02 0x0075
#define QMI_LOC_GET_BATCH_SIZE_RESP_V02 0x0075
#define QMI_LOC_GET_BATCH_SIZE_IND_V02 0x0075
#define QMI_LOC_START_BATCHING_REQ_V02 0x0076
#define QMI_LOC_START_BATCHING_RESP_V02 0x0076
#define QMI_LOC_START_BATCHING_IND_V02 0x0076
#define QMI_LOC_EVENT_BATCH_FULL_NOTIFICATION_IND_V02 0x0077
#define QMI_LOC_EVENT_LIVE_BATCHED_POSITION_REPORT_IND_V02 0x0078
#define QMI_LOC_READ_FROM_BATCH_REQ_V02 0x0079
#define QMI_LOC_READ_FROM_BATCH_RESP_V02 0x0079
#define QMI_LOC_READ_FROM_BATCH_IND_V02 0x0079
#define QMI_LOC_STOP_BATCHING_REQ_V02 0x007A
#define QMI_LOC_STOP_BATCHING_RESP_V02 0x007A
#define QMI_LOC_STOP_BATCHING_IND_V02 0x007A
#define QMI_LOC_RELEASE_BATCH_REQ_V02 0x007B
#define QMI_LOC_RELEASE_BATCH_RESP_V02 0x007B
#define QMI_LOC_RELEASE_BATCH_IND_V02 0x007B
#define QMI_LOC_EVENT_INJECT_WIFI_AP_DATA_REQ_IND_V02 0x007C
#define QMI_LOC_INJECT_WIFI_AP_DATA_REQ_V02 0x007D
#define QMI_LOC_INJECT_WIFI_AP_DATA_RESP_V02 0x007D
#define QMI_LOC_INJECT_WIFI_AP_DATA_IND_V02 0x007D
#define QMI_LOC_NOTIFY_WIFI_ATTACHMENT_STATUS_REQ_V02 0x007E
#define QMI_LOC_NOTIFY_WIFI_ATTACHMENT_STATUS_RESP_V02 0x007E
#define QMI_LOC_NOTIFY_WIFI_ATTACHMENT_STATUS_IND_V02 0x007E
#define QMI_LOC_NOTIFY_WIFI_ENABLED_STATUS_REQ_V02 0x007F
#define QMI_LOC_NOTIFY_WIFI_ENABLED_STATUS_RESP_V02 0x007F
#define QMI_LOC_NOTIFY_WIFI_ENABLED_STATUS_IND_V02 0x007F
#define QMI_LOC_EVENT_GEOFENCE_BATCHED_BREACH_NOTIFICATION_IND_V02 0x0080
#define QMI_LOC_EVENT_VEHICLE_DATA_READY_STATUS_IND_V02 0x0081
#define QMI_LOC_INJECT_VEHICLE_SENSOR_DATA_REQ_V02 0x0082
#define QMI_LOC_INJECT_VEHICLE_SENSOR_DATA_RESP_V02 0x0082
#define QMI_LOC_INJECT_VEHICLE_SENSOR_DATA_IND_V02 0x0082
#define QMI_LOC_GET_AVAILABLE_WWAN_POSITION_REQ_V02 0x0083
#define QMI_LOC_GET_AVAILABLE_WWAN_POSITION_RESP_V02 0x0083
#define QMI_LOC_GET_AVAILABLE_WWAN_POSITION_IND_V02 0x0083
#define QMI_LOC_SET_PREMIUM_SERVICES_CONFIG_REQ_V02 0x0084
#define QMI_LOC_SET_PREMIUM_SERVICES_CONFIG_RESP_V02 0x0084
#define QMI_LOC_SET_PREMIUM_SERVICES_CONFIG_IND_V02 0x0084
#define QMI_LOC_SET_XTRA_VERSION_CHECK_REQ_V02 0x0085
#define QMI_LOC_SET_XTRA_VERSION_CHECK_RESP_V02 0x0085
#define QMI_LOC_SET_XTRA_VERSION_CHECK_IND_V02 0x0085
#define QMI_LOC_EVENT_GNSS_MEASUREMENT_REPORT_IND_V02 0x0086
#define QMI_LOC_EVENT_SV_POLYNOMIAL_REPORT_IND_V02 0x0087
#define QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG_V02 0x0088
#define QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG_RESP_V02 0x0088
#define QMI_LOC_SET_GNSS_CONSTELL_REPORT_CONFIG_IND_V02 0x0088
#define QMI_LOC_ADD_GEOFENCE_CONTEXT_REQ_V02 0x0089
#define QMI_LOC_ADD_GEOFENCE_CONTEXT_RESP_V02 0x0089
#define QMI_LOC_ADD_GEOFENCE_CONTEXT_IND_V02 0x0089
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_REQ_V02 0x008A
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_RESP_V02 0x008A
#define QMI_LOC_SET_GEOFENCE_ENGINE_CONTEXT_IND_V02 0x008A
#define QMI_LOC_DELETE_GEOFENCE_CONTEXT_REQ_V02 0x008B
#define QMI_LOC_DELETE_GEOFENCE_CONTEXT_RESP_V02 0x008B
#define QMI_LOC_DELETE_GEOFENCE_CONTEXT_IND_V02 0x008B
#define QMI_LOC_EVENT_GEOFENCE_PROXIMITY_NOTIFICATION_IND_V02 0x008C
#define QMI_LOC_INJECT_GTP_CLIENT_DOWNLOADED_DATA_REQ_V02 0x008D
#define QMI_LOC_INJECT_GTP_CLIENT_DOWNLOADED_DATA_RESP_V02 0x008D
#define QMI_LOC_INJECT_GTP_CLIENT_DOWNLOADED_DATA_IND_V02 0x008D
#define QMI_LOC_GDT_UPLOAD_BEGIN_STATUS_REQ_V02 0x008E
#define QMI_LOC_GDT_UPLOAD_BEGIN_STATUS_RESP_V02 0x008E
#define QMI_LOC_GDT_UPLOAD_BEGIN_STATUS_IND_V02 0x008E
#define QMI_LOC_GDT_UPLOAD_END_REQ_V02 0x008F
#define QMI_LOC_GDT_UPLOAD_END_RESP_V02 0x008F
#define QMI_LOC_GDT_UPLOAD_END_IND_V02 0x008F
#define QMI_LOC_EVENT_GDT_UPLOAD_BEGIN_STATUS_REQ_IND_V02 0x0090
#define QMI_LOC_EVENT_GDT_UPLOAD_END_REQ_IND_V02 0x0091
#define QMI_LOC_START_DBT_REQ_V02 0x0092
#define QMI_LOC_START_DBT_RESP_V02 0x0092
#define QMI_LOC_START_DBT_IND_V02 0x0092
#define QMI_LOC_EVENT_DBT_POSITION_REPORT_IND_V02 0x0093
#define QMI_LOC_EVENT_DBT_SESSION_STATUS_IND_V02 0x0094
#define QMI_LOC_STOP_DBT_REQ_V02 0x0095
#define QMI_LOC_STOP_DBT_RESP_V02 0x0095
#define QMI_LOC_STOP_DBT_IND_V02 0x0095
#define QMI_LOC_SECURE_GET_AVAILABLE_POSITION_REQ_V02 0x0096
#define QMI_LOC_SECURE_GET_AVAILABLE_POSITION_RESP_V02 0x0096
#define QMI_LOC_SECURE_GET_AVAILABLE_POSITION_IND_V02 0x0096
#define QMI_LOC_EVENT_GEOFENCE_BATCHED_DWELL_NOTIFICATION_IND_V02 0x0097
#define QMI_LOC_EVENT_GET_TIME_ZONE_INFO_IND_V02 0x0098
#define QMI_LOC_INJECT_TIME_ZONE_INFO_REQ_V02 0x0099
#define QMI_LOC_INJECT_TIME_ZONE_INFO_RESP_V02 0x0099
#define QMI_LOC_INJECT_TIME_ZONE_INFO_IND_V02 0x0099
#define QMI_LOC_INJECT_APCACHE_DATA_REQ_V02 0x009A
#define QMI_LOC_INJECT_APCACHE_DATA_RESP_V02 0x009A
#define QMI_LOC_INJECT_APCACHE_DATA_IND_V02 0x009A
#define QMI_LOC_INJECT_APDONOTCACHE_DATA_REQ_V02 0x009B
#define QMI_LOC_INJECT_APDONOTCACHE_DATA_RESP_V02 0x009B
#define QMI_LOC_INJECT_APDONOTCACHE_DATA_IND_V02 0x009B
#define QMI_LOC_EVENT_BATCHING_STATUS_IND_V02 0x009C
#define QMI_LOC_QUERY_AON_CONFIG_REQ_V02 0x009D
#define QMI_LOC_QUERY_AON_CONFIG_RESP_V02 0x009D
#define QMI_LOC_QUERY_AON_CONFIG_IND_V02 0x009D
#define QMI_LOC_GTP_AP_STATUS_REQ_V02 0x009E
#define QMI_LOC_GTP_AP_STATUS_RESP_V02 0x009E
#define QMI_LOC_GTP_AP_STATUS_IND_V02 0x009E
#define QMI_LOC_GDT_DOWNLOAD_BEGIN_STATUS_REQ_V02 0x009F
#define QMI_LOC_GDT_DOWNLOAD_BEGIN_STATUS_RESP_V02 0x009F
#define QMI_LOC_GDT_DOWNLOAD_BEGIN_STATUS_IND_V02 0x009F
#define QMI_LOC_GDT_DOWNLOAD_READY_STATUS_REQ_V02 0x00A0
#define QMI_LOC_GDT_DOWNLOAD_READY_STATUS_RESP_V02 0x00A0
#define QMI_LOC_GDT_DOWNLOAD_READY_STATUS_IND_V02 0x00A0
#define QMI_LOC_GDT_RECEIVE_DONE_STATUS_REQ_V02 0x00A1
#define QMI_LOC_GDT_RECEIVE_DONE_STATUS_RESP_V02 0x00A1
#define QMI_LOC_GDT_RECEIVE_DONE_STATUS_IND_V02 0x00A1
#define QMI_LOC_GDT_DOWNLOAD_END_STATUS_REQ_V02 0x00A2
#define QMI_LOC_GDT_DOWNLOAD_END_STATUS_RESP_V02 0x00A2
#define QMI_LOC_GDT_DOWNLOAD_END_STATUS_IND_V02 0x00A2
#define QMI_LOC_EVENT_GDT_DOWNLOAD_BEGIN_REQ_IND_V02 0x00A3
#define QMI_LOC_EVENT_GDT_RECEIVE_DONE_IND_V02 0x00A4
#define QMI_LOC_EVENT_GDT_DOWNLOAD_END_REQ_IND_V02 0x00A5
#define QMI_LOC_DELETE_GNSS_SERVICE_DATA_REQ_V02 0x00A6
#define QMI_LOC_DELETE_GNSS_SERVICE_DATA_RESP_V02 0x00A6
#define QMI_LOC_DELETE_GNSS_SERVICE_DATA_IND_V02 0x00A6
#define QMI_LOC_INJECT_XTRA_DATA_REQ_V02 0x00A7
#define QMI_LOC_INJECT_XTRA_DATA_RESP_V02 0x00A7
#define QMI_LOC_INJECT_XTRA_DATA_IND_V02 0x00A7
#define QMI_LOC_INJECT_XTRA_PCID_REQ_V02 0x00A8
#define QMI_LOC_INJECT_XTRA_PCID_RESP_V02 0x00A8
#define QMI_LOC_INJECT_XTRA_PCID_IND_V02 0x00A8
#define QMI_LOC_GET_SUPPORTED_FEATURE_REQ_V02 0x00A9
#define QMI_LOC_GET_SUPPORTED_FEATURE_RESP_V02 0x00A9
#define QMI_LOC_GET_SUPPORTED_FEATURE_IND_V02 0x00A9
#define QMI_LOC_SET_INTERNAL_STATUS_CONFIG_REQ_V02 0x00AA
#define QMI_LOC_SET_INTERNAL_STATUS_CONFIG_RESP_V02 0x00AA
#define QMI_LOC_SET_INTERNAL_STATUS_CONFIG_IND_V02 0x00AA
#define QMI_LOC_EVENT_INTERNAL_STATUS_REPORT_IND_V02 0x00AB
#define QMI_LOC_EVENT_INJECT_SRN_AP_DATA_REQ_IND_V02 0x00AC
#define QMI_LOC_INJECT_SRN_AP_DATA_REQ_V02 0x00AD
#define QMI_LOC_INJECT_SRN_AP_DATA_RESP_V02 0x00AD
#define QMI_LOC_INJECT_SRN_AP_DATA_IND_V02 0x00AD
#define QMI_LOC_CROWDSOURCE_MANAGER_CONTROL_REQ_V02 0x00AE
#define QMI_LOC_CROWDSOURCE_MANAGER_CONTROL_RESP_V02 0x00AE
#define QMI_LOC_CROWDSOURCE_MANAGER_CONTROL_IND_V02 0x00AE
#define QMI_LOC_CROWDSOURCE_MANAGER_READ_DATA_REQ_V02 0x00AF
#define QMI_LOC_CROWDSOURCE_MANAGER_READ_DATA_RESP_V02 0x00AF
#define QMI_LOC_QUERY_XTRA_INFO_REQ_V02 0x00B0
#define QMI_LOC_QUERY_XTRA_INFO_RESP_V02 0x00B0
#define QMI_LOC_QUERY_XTRA_INFO_IND_V02 0x00B0
#define QMI_LOC_START_OUTDOOR_TRIP_BATCHING_REQ_V02 0x00B1
#define QMI_LOC_START_OUTDOOR_TRIP_BATCHING_RESP_V02 0x00B1
#define QMI_LOC_START_OUTDOOR_TRIP_BATCHING_IND_V02 0x00B1
#define QMI_LOC_QUERY_OTB_ACCUMULATED_DISTANCE_REQ_V02 0x00B2
#define QMI_LOC_QUERY_OTB_ACCUMULATED_DISTANCE_RESP_V02 0x00B2
#define QMI_LOC_QUERY_OTB_ACCUMULATED_DISTANCE_IND_V02 0x00B2
#define QMI_LOC_EVENT_FDCL_SERVICE_REQ_IND_V02 0x00B3
#define QMI_LOC_GET_FDCL_BS_LIST_REQ_V02 0x00B4
#define QMI_LOC_GET_FDCL_BS_LIST_RESP_V02 0x00B4
#define QMI_LOC_GET_FDCL_BS_LIST_IND_V02 0x00B4
#define QMI_LOC_INJECT_FDCL_DATA_REQ_V02 0x00B5
#define QMI_LOC_INJECT_FDCL_DATA_RESP_V02 0x00B5
#define QMI_LOC_INJECT_FDCL_DATA_IND_V02 0x00B5
#define QMI_LOC_SET_BLACKLIST_SV_REQ_V02 0x00B6
#define QMI_LOC_SET_BLACKLIST_SV_RESP_V02 0x00B6
#define QMI_LOC_SET_BLACKLIST_SV_IND_V02 0x00B6
#define QMI_LOC_GET_BLACKLIST_SV_REQ_V02 0x00B7
#define QMI_LOC_GET_BLACKLIST_SV_RESP_V02 0x00B7
#define QMI_LOC_GET_BLACKLIST_SV_IND_V02 0x00B7
#define QMI_LOC_SET_CONSTELLATION_CONTROL_REQ_V02 0x00B8
#define QMI_LOC_SET_CONSTELLATION_CONTROL_RESP_V02 0x00B8
#define QMI_LOC_SET_CONSTELLATION_CONTROL_IND_V02 0x00B8
#define QMI_LOC_DC_REPORT_IND_V02 0x00B9
#define QMI_LOC_REGISTER_MASTER_CLIENT_REQ_V02 0x00BA
#define QMI_LOC_REGISTER_MASTER_CLIENT_RESP_V02 0x00BA
#define QMI_LOC_REGISTER_MASTER_CLIENT_IND_V02 0x00BA
#define QMI_LOC_EVENT_ENGINE_LOCK_STATE_IND_V02 0x00BB
#define QMI_LOC_START_LISTEN_POSITION_REQ_V02 0x00BC
#define QMI_LOC_START_LISTEN_POSITION_RESP_V02 0x00BC
#define QMI_LOC_STOP_LISTEN_POSITION_REQ_V02 0x00BD
#define QMI_LOC_STOP_LISTEN_POSITION_RESP_V02 0x00BD
#define QMI_LOC_SYSTEM_INFO_REQ_V02 0x00BE
#define QMI_LOC_SYSTEM_INFO_RESP_V02 0x00BE
#define QMI_LOC_SYSTEM_INFO_IND_V02 0x00BE
#define QMI_LOC_GET_CONSTELLATION_CONTROL_REQ_V02 0x00BF
#define QMI_LOC_GET_CONSTELLATION_CONTROL_RESP_V02 0x00BF
#define QMI_LOC_GET_CONSTELLATION_CONTROL_IND_V02 0x00BF
#define QMI_LOC_EVENT_UNPROPAGATED_POSITION_REPORT_IND_V02 0x00C0
#define QMI_LOC_ENABLE_POSITION_INJECTION_TEST_MODE_REQ_V02 0x00C1
#define QMI_LOC_ENABLE_POSITION_INJECTION_TEST_MODE_RESP_V02 0x00C1
#define QMI_LOC_ENABLE_POSITION_INJECTION_TEST_MODE_IND_V02 0x00C1
#define QMI_LOC_INJECT_TEST_POSITION_REQ_V02 0x00C2
#define QMI_LOC_INJECT_TEST_POSITION_RESP_V02 0x00C2
#define QMI_LOC_INJECT_TEST_POSITION_IND_V02 0x00C2
#define QMI_LOC_EVENT_BS_OBS_DATA_SERVICE_REQ_IND_V02 0x00C3
#define QMI_LOC_GET_BS_OBS_DATA_REQ_V02 0x00C4
#define QMI_LOC_GET_BS_OBS_DATA_RESP_V02 0x00C4
#define QMI_LOC_GET_BS_OBS_DATA_IND_V02 0x00C4
#define QMI_LOC_EVENT_GPS_EPHEMERIS_REPORT_IND_V02 0x00C5
#define QMI_LOC_EVENT_GLONASS_EPHEMERIS_REPORT_IND_V02 0x00C6
#define QMI_LOC_EVENT_BDS_EPHEMERIS_REPORT_IND_V02 0x00C7
#define QMI_LOC_EVENT_GALILEO_EPHEMERIS_REPORT_IND_V02 0x00C8
#define QMI_LOC_EVENT_QZSS_EPHEMERIS_REPORT_IND_V02 0x00C9
#define QMI_LOC_SET_CONSTRAINED_TUNC_MODE_REQ_V02 0x00CA
#define QMI_LOC_SET_CONSTRAINED_TUNC_MODE_RESP_V02 0x00CA
#define QMI_LOC_SET_CONSTRAINED_TUNC_MODE_IND_V02 0x00CA
#define QMI_LOC_ENABLE_POSITION_ASSISTED_CLOCK_EST_REQ_V02 0x00CB
#define QMI_LOC_ENABLE_POSITION_ASSISTED_CLOCK_EST_RESP_V02 0x00CB
#define QMI_LOC_ENABLE_POSITION_ASSISTED_CLOCK_EST_IND_V02 0x00CB
#define QMI_LOC_QUERY_GNSS_ENERGY_CONSUMED_REQ_V02 0x00CC
#define QMI_LOC_QUERY_GNSS_ENERGY_CONSUMED_RESP_V02 0x00CC
#define QMI_LOC_QUERY_GNSS_ENERGY_CONSUMED_IND_V02 0x00CC
#define QMI_LOC_EVENT_REPORT_IND_V02 0x00CD
#define QMI_LOC_GET_BAND_MEASUREMENT_METRICS_IND_V02 0x00CE
#define QMI_LOC_LOCATION_REQUEST_NOTIFICATION_IND_V02 0x00CF
#define QMI_LOC_INJECT_PLATFORM_POWER_STATE_REQ_V02 0x00D0
#define QMI_LOC_INJECT_PLATFORM_POWER_STATE_RESP_V02 0x00D0
#define QMI_LOC_INJECT_PLATFORM_POWER_STATE_IND_V02 0x00D0
#define QMI_LOC_SET_ROBUST_LOCATION_CONFIG_REQ_V02 0x00D1
#define QMI_LOC_SET_ROBUST_LOCATION_CONFIG_RESP_V02 0x00D1
#define QMI_LOC_SET_ROBUST_LOCATION_CONFIG_IND_V02 0x00D1
#define QMI_LOC_GET_ROBUST_LOCATION_CONFIG_REQ_V02 0x00D2
#define QMI_LOC_GET_ROBUST_LOCATION_CONFIG_RESP_V02 0x00D2
#define QMI_LOC_GET_ROBUST_LOCATION_CONFIG_IND_V02 0x00D2
#define QMI_LOC_INJECT_ENV_AIDING_REQ_V02 0x00D3
#define QMI_LOC_INJECT_ENV_AIDING_RESP_V02 0x00D3
#define QMI_LOC_INJECT_ENV_AIDING_IND_V02 0x00D3
#define QMI_LOC_SET_MIN_GPS_WEEK_NUMBER_REQ_V02 0x00D4
#define QMI_LOC_SET_MIN_GPS_WEEK_NUMBER_RESP_V02 0x00D4
#define QMI_LOC_SET_MIN_GPS_WEEK_NUMBER_IND_V02 0x00D4
#define QMI_LOC_GET_MIN_GPS_WEEK_NUMBER_REQ_V02 0x00D5
#define QMI_LOC_GET_MIN_GPS_WEEK_NUMBER_RESP_V02 0x00D5
#define QMI_LOC_GET_MIN_GPS_WEEK_NUMBER_IND_V02 0x00D5
#define QMI_LOC_EVENT_QUERY_XTRA_INFO_REQ_IND_V02 0x00D6
#define QMI_LOC_SET_PARAMETER_REQ_V02 0x00D7
#define QMI_LOC_SET_PARAMETER_RESP_V02 0x00D7
#define QMI_LOC_SET_PARAMETER_IND_V02 0x00D7
#define QMI_LOC_GET_PARAMETER_REQ_V02 0x00D8
#define QMI_LOC_GET_PARAMETER_RESP_V02 0x00D8
#define QMI_LOC_GET_PARAMETER_IND_V02 0x00D8
#define QMI_LOC_SET_STATISTICS_CONFIG_REQ_V02 0x00D9
#define QMI_LOC_SET_STATISTICS_CONFIG_RESP_V02 0x00D9
#define QMI_LOC_SET_STATISTICS_CONFIG_IND_V02 0x00D9
#define QMI_LOC_GET_STATISTICS_CONFIG_REQ_V02 0x00DA
#define QMI_LOC_GET_STATISTICS_CONFIG_RESP_V02 0x00DA
#define QMI_LOC_GET_STATISTICS_CONFIG_IND_V02 0x00DA
#define QMI_LOC_GNSS_STATISTICS_REPORT_IND_V02 0x00DB
#define QMI_LOC_SET_GNSS_PDR_MODE_REQ_V02 0x00DC
#define QMI_LOC_SET_GNSS_PDR_MODE_RESP_V02 0x00DC
#define QMI_LOC_SET_GNSS_PDR_MODE_IND_V02 0x00DC
#define QMI_LOC_GET_GNSS_PDR_MODE_REQ_V02 0x00DD
#define QMI_LOC_GET_GNSS_PDR_MODE_RESP_V02 0x00DD
#define QMI_LOC_GET_GNSS_PDR_MODE_IND_V02 0x00DD
#define QMI_LOC_GET_MAG_CAL_STATE_PDR_REQ_V02 0x00DE
#define QMI_LOC_GET_MAG_CAL_STATE_PDR_RESP_V02 0x00DE
#define QMI_LOC_GET_MAG_CAL_STATE_PDR_IND_V02 0x00DE
#define QMI_LOC_EVENT_SAP_INS_PARAMETERS_IND_V02 0x00DF
#define QMI_LOC_SET_MULTIBAND_CONFIG_REQ_V02 0x00E0
#define QMI_LOC_SET_MULTIBAND_CONFIG_RESP_V02 0x00E0
#define QMI_LOC_SET_MULTIBAND_CONFIG_IND_V02 0x00E0
#define QMI_LOC_GET_MULTIBAND_CONFIG_REQ_V02 0x00E1
#define QMI_LOC_GET_MULTIBAND_CONFIG_RESP_V02 0x00E1
#define QMI_LOC_GET_MULTIBAND_CONFIG_IND_V02 0x00E1
#define QMI_LOC_LATENCY_INFORMATION_IND_V02 0x00E2
/**
    @}
  */

/* Service Object Accessor */
/** @addtogroup wms_qmi_accessor
    @{
  */
/** This function is used internally by the autogenerated code.  Clients should use the
   macro loc_get_service_object_v02( ) that takes in no arguments. */
qmi_idl_service_object_type loc_get_service_object_internal_v02
 ( int32_t idl_maj_version, int32_t idl_min_version, int32_t library_version );

/** This macro should be used to get the service object */
#define loc_get_service_object_v02( ) \
          loc_get_service_object_internal_v02( \
            LOC_V02_IDL_MAJOR_VERS, LOC_V02_IDL_MINOR_VERS, \
            LOC_V02_IDL_TOOL_VERS )
/**
    @}
  */


#ifdef __cplusplus
}
#endif
#endif

