/* Copyright (c) 2020 The Linux Foundation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *     * Neither the name of The Linux Foundation nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// ============================================================================
// LocationApiDataTypes.proto
// Common location data types definitions, enums, structs
// ============================================================================

syntax = "proto3";

// ============================================================================
// Proto file versioning
// ============================================================================
enum LocationApiDataTypesVersion {
    LOCAPI_DATA_TYPES_VER_INVALID = 0;
    // Major changes - compatibility breakage. Bump the first byte of version i.e. 1.x to 2.0
    LOCAPI_DATA_TYPES_VER_MAJOR = 1;
    // Minor - New features / API addition, new message/elemtent addition.
    // Bump the last byte of version i.e. x.2 to x.3
    // Minor version 6: Add glonass frequency in GnssSv
    LOCAPI_DATA_TYPES_VER_MINOR = 6;
}

// ============================================================================
// Enumerations and Masks
// ============================================================================

enum PBGnssSuplMode {
    PB_GNSS_SUPL_MODE_STANDALONE = 0;
    PB_GNSS_SUPL_MODE_MSB = 1;
    PB_GNSS_SUPL_MODE_MSA = 2;
}

/** GNSS Signal Type and RF Band */
enum PBGnssSignalTypeMask {
    PB_GNSS_SIGNAL_TYPE_MASK_INVALID = 0;
    /** GPS L1CA Signal */
    PB_GNSS_SIGNAL_GPS_L1CA_BIT            = 1;
    /** GPS L1C Signal */
    PB_GNSS_SIGNAL_GPS_L1C_BIT             = 2;
    /** GPS L2 RF Band */
    PB_GNSS_SIGNAL_GPS_L2_BIT              = 4;
    /** GPS L5 RF Band */
    PB_GNSS_SIGNAL_GPS_L5_BIT              = 8;
    /** GLONASS G1 (L1OF) RF Band */
    PB_GNSS_SIGNAL_GLONASS_G1_BIT          = 16;
    /** GLONASS G2 (L2OF) RF Band */
    PB_GNSS_SIGNAL_GLONASS_G2_BIT          = 32;
    /** GALILEO E1 RF Band */
    PB_GNSS_SIGNAL_GALILEO_E1_BIT          = 64;
    /** GALILEO E5A RF Band */
    PB_GNSS_SIGNAL_GALILEO_E5A_BIT         = 128;
    /** GALILEO E5B RF Band */
    PB_GNSS_SIGNAL_GALILEO_E5B_BIT         = 256;
    /** BEIDOU B1 RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B1_BIT           = 512;
    /** BEIDOU B2 RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B2_BIT           = 1024;
    /** QZSS L1CA RF Band */
    PB_GNSS_SIGNAL_QZSS_L1CA_BIT           = 2048;
    /** QZSS L1S RF Band */
    PB_GNSS_SIGNAL_QZSS_L1S_BIT            = 4096;
    /** QZSS L2 RF Band */
    PB_GNSS_SIGNAL_QZSS_L2_BIT             = 8192;
    /** QZSS L5 RF Band */
    PB_GNSS_SIGNAL_QZSS_L5_BIT             = 16384;
    /** SBAS L1 RF Band */
    PB_GNSS_SIGNAL_SBAS_L1_BIT             = 32768;
    /** BEIDOU B1I RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B1I_BIT          = 65536;
    /** BEIDOU B1C RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B1C_BIT          = 131072;
    /** BEIDOU B2I RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B2I_BIT          = 262144;
    /** BEIDOU B2AI RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B2AI_BIT         = 524288;
    /** NAVIC L5 RF Band */
    PB_GNSS_SIGNAL_NAVIC_L5_BIT            = 1048576;
    /** BEIDOU B2A_Q RF Band */
    PB_GNSS_SIGNAL_BEIDOU_B2AQ_BIT         = 2097152;
}

enum PBLocApiGnss_LocSvSystemEnumType {
    PB_GNSS_LOC_SV_SYSTEM_INVALID = 0;
    /** SV is of GPS constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_GPS     = 1;
    /**  SV is of GALILEO constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_GALILEO = 2;
    /**  SV is of SBAS sconstellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_SBAS    = 3;
    /**  SV is of GLONASS constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_GLONASS = 4;
    /**  SV is of BDS constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_BDS     = 5;
    /**  SV is of QZSS constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_QZSS    = 6;
    /** SV is of NAVIC constellation. <br/>   */
    PB_GNSS_LOC_SV_SYSTEM_NAVIC   = 7;
}

enum PBLocApiOutputEngineType {
    PB_LOC_OUTPUT_ENGINE_FUSED  = 0;
    /** This is the GNSS fix from modem */
    PB_LOC_OUTPUT_ENGINE_SPE    = 1;
    /** This is the GNSS fix with correction PPP/RTK correction */
    PB_LOC_OUTPUT_ENGINE_PPE    = 2;
    PB_LOC_OUTPUT_ENGINE_COUNT  = 3;
}

enum PBLocationReliability {
    PB_LOCATION_RELIABILITY_NOT_SET = 0;
    PB_LOCATION_RELIABILITY_VERY_LOW = 1;
    PB_LOCATION_RELIABILITY_LOW = 2;
    PB_LOCATION_RELIABILITY_MEDIUM = 3;
    PB_LOCATION_RELIABILITY_HIGH = 4;
}

enum PBGnssLocationInfoFlagMask {
    PB_GNSS_LOCATION_INFO_INVALID                          = 0;
    PB_GNSS_LOCATION_INFO_ALTITUDE_MEAN_SEA_LEVEL_BIT      = 1; // valid altitude mean sea level
    PB_GNSS_LOCATION_INFO_DOP_BIT                          = 2; // valid pdop, hdop, and vdop
    PB_GNSS_LOCATION_INFO_EXT_DOP_BIT                      = 4; // valid gdop, tdop
    PB_GNSS_LOCATION_INFO_MAGNETIC_DEVIATION_BIT           = 8; // valid magnetic deviation
    PB_GNSS_LOCATION_INFO_HOR_RELIABILITY_BIT              = 16; // valid horizontal reliability
    PB_GNSS_LOCATION_INFO_VER_RELIABILITY_BIT              = 32; // valid vertical reliability
    PB_GNSS_LOCATION_INFO_HOR_ACCURACY_ELIP_SEMI_MAJOR_BIT = 64; // valid elipsode semi major
    PB_GNSS_LOCATION_INFO_HOR_ACCURACY_ELIP_SEMI_MINOR_BIT = 128; // valid elipsode semi minor
    PB_GNSS_LOCATION_INFO_HOR_ACCURACY_ELIP_AZIMUTH_BIT    = 256; // valid accuracy elipsode
                                                                  // azimuth
    PB_GNSS_LOCATION_INFO_GNSS_SV_USED_DATA_BIT            = 512; // valid svUsedInPosition,
                                                                  //       numOfMeasReceived
                                                                  //       and measUsageInfo
    PB_GNSS_LOCATION_INFO_NAV_SOLUTION_MASK_BIT            = 1024; // valid navSolutionMask
    PB_GNSS_LOCATION_INFO_POS_DYNAMICS_DATA_BIT            = 2048; // valid position dynamics data
                                                                   // and Position Dynamics Ext
    PB_GNSS_LOCATION_INFO_NORTH_STD_DEV_BIT                = 4096; // valid North standard
                                                                   // deviation
    PB_GNSS_LOCATION_INFO_EAST_STD_DEV_BIT                 = 8192; // valid East standard deviation
    PB_GNSS_LOCATION_INFO_NORTH_VEL_BIT                    = 16384; // valid North Velocity
    PB_GNSS_LOCATION_INFO_EAST_VEL_BIT                     = 32768; // valid East Velocity
    PB_GNSS_LOCATION_INFO_UP_VEL_BIT                       = 65536; // valid Up Velocity
    PB_GNSS_LOCATION_INFO_NORTH_VEL_UNC_BIT                = 131072; // valid North Velocity
                                                                     // Uncertainty
    PB_GNSS_LOCATION_INFO_EAST_VEL_UNC_BIT                 = 262144; // valid East Velocity
                                                                     // Uncertainty
    PB_GNSS_LOCATION_INFO_UP_VEL_UNC_BIT                   = 524288; // valid Up Velocity
                                                                     // Uncertainty
    PB_GNSS_LOCATION_INFO_LEAP_SECONDS_BIT                 = 1048576; // valid leap seconds
    PB_GNSS_LOCATION_INFO_TIME_UNC_BIT                     = 2097152; // valid time uncertainty
    PB_GNSS_LOCATION_INFO_NUM_SV_USED_IN_POSITION_BIT      = 4194304; // number of SV used in
                                                                      // position
    PB_GNSS_LOCATION_INFO_CALIBRATION_CONFIDENCE_PERCENT_BIT = 8388608; // valid sensor cal
                                                                        // confidence
    PB_GNSS_LOCATION_INFO_CALIBRATION_STATUS_BIT           = 16777216; // valid sensor cal status
    PB_GNSS_LOCATION_INFO_OUTPUT_ENG_TYPE_BIT              = 33554432; // valid output engine type
    PB_GNSS_LOCATION_INFO_OUTPUT_ENG_MASK_BIT              = 67108864; // valid output engine mask
    PB_GNSS_LOCATION_INFO_CONFORMITY_INDEX_BIT             = 134217728; // valid conformity index
    PB_GNSS_LOCATION_INFO_LLA_VRP_BASED_BIT                = 268435456; // valid VRP-based
                                                                        // lat/long/alt
    PB_GNSS_LOCATION_INFO_ENU_VELOCITY_VRP_BASED_BIT       = 536870912; // VRP-based east/north/up
                                                                        // velocity
    PB_GNSS_LOCATION_INFO_DR_SOLUTION_STATUS_MASK_BIT      = 1073741824; // DR solution status
}

enum PBGnssLocationInfoExtFlagMask {
    PB_GNSS_LOCATION_INFO_EXT_INVALID          = 0;
    PB_GNSS_LOCATION_INFO_ALTITUDE_ASSUMED_BIT = 0x1; // valid altitude mean sea level
    PB_GNSS_LOCATION_INFO_SESSION_STATUS_BIT   = 0x2; // valid altitude mean sea level
};

enum PBGnssLocationNavSolutionMask {
    PB_LOCATION_NAV_SOLUTION_MASK_INVALID = 0;
    PB_LOCATION_SBAS_CORRECTION_IONO_BIT  = 1; // SBAS ionospheric correction is used
    PB_LOCATION_SBAS_CORRECTION_FAST_BIT  = 2; // SBAS fast correction is used
    PB_LOCATION_SBAS_CORRECTION_LONG_BIT  = 4; // SBAS long-tem correction is used
    PB_LOCATION_SBAS_INTEGRITY_BIT        = 8; // SBAS integrity information is used
    PB_LOCATION_NAV_CORRECTION_DGNSS_BIT  = 16; // Position Report is DGNSS corrected
    PB_LOCATION_NAV_CORRECTION_RTK_BIT    = 32; // Position Report is RTK corrected
    PB_LOCATION_NAV_CORRECTION_PPP_BIT    = 64; // Position Report is PPP corrected
    PB_LOCATION_NAV_CORRECTION_RTK_FIXED_BIT  = 128; // Posiiton Report is RTF fixed corrected
    PB_LOCATION_NAV_CORRECTION_ONLY_SBAS_CORRECTED_SV_USED_BIT = 256; // Position report is computed with only SBAS corrected SVs
}

/* Mask indicating enabled or disabled constellations */
enum PBGnssSvTypesMask {
    PB_GNSS_SV_TYPES_MASK_INVALID  = 0;
    PB_GNSS_SV_TYPES_MASK_GLO_BIT  = 1;
    PB_GNSS_SV_TYPES_MASK_BDS_BIT  = 2;
    PB_GNSS_SV_TYPES_MASK_QZSS_BIT = 4;
    PB_GNSS_SV_TYPES_MASK_GAL_BIT  = 8;
    PB_GNSS_SV_TYPES_MASK_NAVIC_BIT = 16;
    PB_GNSS_SV_TYPES_MASK_GPS_BIT = 32;
}

enum PBLocApiGnssSvOptionsMask {
    PB_GNSS_SV_OPTIONS_INVALID                     = 0;
    PB_GNSS_SV_OPTIONS_HAS_EPHEMER_BIT             = 1;
    PB_GNSS_SV_OPTIONS_HAS_ALMANAC_BIT             = 2;
    PB_GNSS_SV_OPTIONS_USED_IN_FIX_BIT             = 4;
    PB_GNSS_SV_OPTIONS_HAS_CARRIER_FREQUENCY_BIT   = 8;
    PB_GNSS_SV_OPTIONS_HAS_GNSS_SIGNAL_TYPE_BIT    = 16;
}

enum PBGnssGloTimeStructTypeFlags {
    PB_GNSS_CLO_TIME_UNKNOWN                   = 0;
    PB_GNSS_GLO_FOUR_YEAR_VALID                = 1;
    PB_GNSS_CLO_DAYS_VALID                     = 2;
    PB_GNSS_GLO_MSEC_VALID                     = 4;
    PB_GNSS_GLO_CLK_TIME_BIAS_VALID            = 8;
    PB_GNSS_GLO_CLK_TIME_BIAS_UNC_VALID        = 16;
    PB_GNSS_GLO_REF_FCOUNT_VALID               = 32;
    PB_GNSS_GLO_NUM_CLOCK_RESETS_VALID         = 64;
}

enum PBGnssMeasurementsClockFlagsMask {
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_INVALID                          = 0;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_LEAP_SECOND_BIT                  = 1;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_TIME_BIT                         = 2;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_TIME_UNCERTAINTY_BIT             = 4;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_FULL_BIAS_BIT                    = 8;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_BIAS_BIT                         = 16;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_BIAS_UNCERTAINTY_BIT             = 32;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_DRIFT_BIT                        = 64;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_DRIFT_UNCERTAINTY_BIT            = 128;
    PB_GNSS_MEASUREMENTS_CLOCK_FLAGS_HW_CLOCK_DISCONTINUITY_COUNT_BIT = 256;
}

enum PBLocApiGnssSystemTimeStructTypeFlags {
    PB_GNSS_SYSTEM_TIME_FLAG_INVALID        = 0;
    PB_GNSS_SYSTEM_TIME_WEEK_VALID          = 1;
    PB_GNSS_SYSTEM_TIME_WEEK_MS_VALID       = 2;
    PB_GNSS_SYSTEM_CLK_TIME_BIAS_VALID      = 4;
    PB_GNSS_SYSTEM_CLK_TIME_BIAS_UNC_VALID  = 8;
    PB_GNSS_SYSTEM_REF_FCOUNT_VALID         = 16;
    PB_GNSS_SYSTEM_NUM_CLOCK_RESETS_VALID   = 32;
}

// Specify the valid mask for robust location configure
// defined in GnssConfigRobustLocation.
enum PBGnssConfigRobustLocationValidMask {
    PB_GNSS_CONFIG_ROBUST_LOCATION_INVALID                    = 0;
    // GnssConfigRobustLocation has valid enabled field.
    PB_GNSS_CONFIG_ROBUST_LOCATION_ENABLED_VALID_BIT          = 1;
    // GnssConfigRobustLocation has valid enabledForE911 field.
    PB_GNSS_CONFIG_ROBUST_LOCATION_ENABLED_FOR_E911_VALID_BIT = 2;
    // GnssConfigRobustLocation has valid version field.
    PB_GNSS_CONFIG_ROBUST_LOCATION_VERSION_VALID_BIT          = 4;
}

enum PBLocationSystemInfoMask {
    PB_LOCATION_SYS_INFO_INVALID = 0;
    // contains current leap second or leap second change info
    PB_LOCATION_SYS_INFO_LEAP_SECOND = 1;
}

enum PBLocApiDrCalibrationStatusMask {
    PB_DR_CALIBRATION_INVALID      = 0;
    // Indicate that roll calibration is needed. Need to take more turns on level ground
    PB_DR_ROLL_CALIBRATION_NEEDED  = 1;
    // Indicate that pitch calibration is needed. Need to take more turns on level ground
    PB_DR_PITCH_CALIBRATION_NEEDED = 2;
    // Indicate that yaw calibration is needed. Need to accelerate in a straight line
    PB_DR_YAW_CALIBRATION_NEEDED   = 4;
    // Indicate that odo calibration is needed. Need to accelerate in a straight line
    PB_DR_ODO_CALIBRATION_NEEDED   = 8;
    // Indicate that gyro calibration is needed. Need to take more turns on level ground
    PB_DR_GYRO_CALIBRATION_NEEDED  = 16;
}

enum PBLeapSecondSysInfoMask {
    PB_LEAP_SECOND_SYS_INFO_INVALID = 0;
    // current leap second info is available. This info will only
    // be available if the leap second change info is not available.
    //
    // If leap second change info is avaiable, to figure out
    // the current leap second info, compare current gps time with
    // the gps timestamp of leap second change to know whether to choose
    // leapSecondBefore or leapSecondAfter as current leap second.
    PB_LEAP_SECOND_SYS_INFO_CURRENT_LEAP_SECONDS_BIT = 1;
    // the last known leap change event is available.
    // The info can be available on two scenario:
    // 1: this leap second change event has been scheduled and yet to happen
    // 2: this leap second change event has already happened and next
    //    leap second change event has not yet been scheduled.
    PB_LEAP_SECOND_SYS_INFO_LEAP_SECOND_CHANGE_BIT = 2;
}

enum PBTerrestrialTechMask {
    PB_TERRESTRIAL_TECH_INVALID = 0;
    PB_TERRESTRIAL_TECH_GTP_WWAN = 1;
};

enum PBLocApiGnssLocationPosDataMask {
    PB_LOCATION_NAV_DATA_INVALID             = 0;
    // Navigation data has Forward Acceleration
    PB_LOCATION_NAV_DATA_HAS_LONG_ACCEL_BIT  = 1;
    // Navigation data has Sideward Acceleration
    PB_LOCATION_NAV_DATA_HAS_LAT_ACCEL_BIT   = 2;
    // Navigation data has Vertical Acceleration
    PB_LOCATION_NAV_DATA_HAS_VERT_ACCEL_BIT  = 4;
    // Navigation data has Heading Rate
    PB_LOCATION_NAV_DATA_HAS_YAW_RATE_BIT    = 8;
    // Navigation data has Heading Rate uncertainty
    PB_LOCATION_NAV_DATA_HAS_YAW_RATE_UNC_BIT = 16;
    // Navigation data has body yaw
    PB_LOCATION_NAV_DATA_HAS_YAW_BIT          = 32;
    // Navigation data has body roll uncertainty
    PB_LOCATION_NAV_DATA_HAS_YAW_UNC_BIT      = 64;
    // Navigation data has Body pitch
    PB_LOCATION_NAV_DATA_HAS_PITCH_BIT        = 128;
    // Navigation data has Body pitch uncertainty
    PB_LOCATION_NAV_DATA_HAS_PITCH_UNC_BIT    = 256;
    // Navigation data has pitch rate
    PB_LOCATION_NAV_DATA_HAS_PITCH_RATE_BIT   = 512;
    // Navigation data has body pitch rate uncertainty
    PB_LOCATION_NAV_DATA_HAS_PITCH_RATE_UNC_BIT = 1024;
    // Navigation data has Forward Acceleration uncertainty
    PB_LOCATION_NAV_DATA_HAS_LONG_ACCEL_UNC_BIT = 2048;
    // Navigation data has Sideward Acceleration uncertainty
    PB_LOCATION_NAV_DATA_HAS_LAT_ACCEL_UNC_BIT  = 4096;
    // Navigation data has Vertical Acceleration uncertainty
    PB_LOCATION_NAV_DATA_HAS_VERT_ACCEL_UNC_BIT = 8192;
    // Navigation data has body roll
    PB_LOCATION_NAV_DATA_HAS_ROLL_BIT           = 16384;
    // Navigation data has body roll uncertainty
    PB_LOCATION_NAV_DATA_HAS_ROLL_UNC_BIT       = 32768;
    // Navigation data has body rate roll
    PB_LOCATION_NAV_DATA_HAS_ROLL_RATE_BIT      = 65536;
    // Navigation data has body roll rate uncertainty
    PB_LOCATION_NAV_DATA_HAS_ROLL_RATE_UNC_BIT  = 131072;
}

enum PBBatchingMode {
    // positions are reported when batched positions memory is full
    PB_BATCHING_MODE_ROUTINE = 0;
    // positions are reported when a certain distance is covered
    PB_BATCHING_MODE_TRIP = 1;
    // no report of positions automatically, instead queried on demand
    PB_BATCHING_MODE_NO_AUTO_REPORT = 2;
}

enum PBBatchingStatus {
    PB_BATCHING_STATUS_TRIP_COMPLETED = 0;
    PB_BATCHING_STATUS_POSITION_AVAILABE = 1;
    PB_BATCHING_STATUS_POSITION_UNAVAILABLE = 2;
}

enum PBLocationError {
    PB_LOCATION_ERROR_SUCCESS = 0;
    PB_LOCATION_ERROR_INVALID_PARAMETER = 1;
    PB_LOCATION_ERROR_NOT_SUPPORTED = 2;
    PB_LOCATION_ERROR_GENERAL_FAILURE = 3;
    PB_LOCATION_ERROR_TIMEOUT = 4;
}

enum PBLocReqEngineTypeMask {
    PB_LOC_REQ_ENGINE_INVALID   = 0;
    PB_LOC_REQ_ENGINE_FUSED_BIT = 1;
    PB_LOC_REQ_ENGINE_SPE_BIT   = 2;
    PB_LOC_REQ_ENGINE_PPE_BIT   = 4;
}

enum PBLocApiPositioningEngineMask {
    PB_POS_ENG_MASK_INVALID        = 0;
    PB_STANDARD_POSITIONING_ENGINE = 1;
    PB_DEAD_RECKONING_ENGINE       = 2;
    PB_PRECISE_POSITIONING_ENGINE  = 4;
}

enum PBLocEngineRunState {
    PB_LOC_ENGINE_RUN_STATE_INVALID = 0;
    PB_LOC_ENGINE_RUN_STATE_PAUSE   = 1;
    PB_LOC_ENGINE_RUN_STATE_RESUME  = 2;
};

enum PBDrEngineAidingDataMask {
    PB_DR_ENGINE_AIDING_DATA_INVALID = 0;
    // Calibration data for DRE engine
    PB_DR_ENGINE_AIDING_DATA_CALIBRATION_BIT = 1;
}

enum PBGnssMeasurementsAdrStateMask {
    PB_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN         = 0;
    PB_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_VALID_BIT       = 1;
    PB_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_RESET_BIT       = 2;
    PB_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_CYCLE_SLIP_BIT  = 4;
}

enum PBGnssMeasurementsDataFlagsMask {
    PB_GNSS_MEASUREMENTS_DATA_INVALID                          = 0x00000000;
    PB_GNSS_MEASUREMENTS_DATA_SV_ID_BIT                        = 0x00000001;
    PB_GNSS_MEASUREMENTS_DATA_SV_TYPE_BIT                      = 0x00000002;
    PB_GNSS_MEASUREMENTS_DATA_STATE_BIT                        = 0x00000004;
    PB_GNSS_MEASUREMENTS_DATA_RECEIVED_SV_TIME_BIT             = 0x00000008;
    PB_GNSS_MEASUREMENTS_DATA_RECEIVED_SV_TIME_UNCERTAINTY_BIT = 0x00000010;
    PB_GNSS_MEASUREMENTS_DATA_CARRIER_TO_NOISE_BIT             = 0x00000020;
    PB_GNSS_MEASUREMENTS_DATA_PSEUDORANGE_RATE_BIT             = 0x00000040;
    PB_GNSS_MEASUREMENTS_DATA_PSEUDORANGE_RATE_UNCERTAINTY_BIT = 0x00000080;
    PB_GNSS_MEASUREMENTS_DATA_ADR_STATE_BIT                    = 0x00000100;
    PB_GNSS_MEASUREMENTS_DATA_ADR_BIT                          = 0x00000200;
    PB_GNSS_MEASUREMENTS_DATA_ADR_UNCERTAINTY_BIT              = 0x00000400;
    PB_GNSS_MEASUREMENTS_DATA_CARRIER_FREQUENCY_BIT            = 0x00000800;
    PB_GNSS_MEASUREMENTS_DATA_CARRIER_CYCLES_BIT               = 0x00001000;
    PB_GNSS_MEASUREMENTS_DATA_CARRIER_PHASE_BIT                = 0x00002000;
    PB_GNSS_MEASUREMENTS_DATA_CARRIER_PHASE_UNCERTAINTY_BIT    = 0x00004000;
    PB_GNSS_MEASUREMENTS_DATA_MULTIPATH_INDICATOR_BIT          = 0x00008000;
    PB_GNSS_MEASUREMENTS_DATA_SIGNAL_TO_NOISE_RATIO_BIT        = 0x00010000;
    PB_GNSS_MEASUREMENTS_DATA_AUTOMATIC_GAIN_CONTROL_BIT       = 0x00020000;
    PB_GNSS_MEASUREMENTS_DATA_FULL_ISB_BIT                     = 0x00040000;
    PB_GNSS_MEASUREMENTS_DATA_FULL_ISB_UNCERTAINTY_BIT         = 0x00080000;
    PB_GNSS_MEASUREMENTS_DATA_CYCLE_SLIP_COUNT_BIT             = 0x00100000;
}

enum PBGnssMeasurementsStateMask {
    PB_GNSS_MEASUREMENTS_STATE_UNKNOWN_BIT               = 0;
    PB_GNSS_MEASUREMENTS_STATE_CODE_LOCK_BIT             = 1;
    PB_GNSS_MEASUREMENTS_STATE_BIT_SYNC_BIT              = 2;
    PB_GNSS_MEASUREMENTS_STATE_SUBFRAME_SYNC_BIT         = 4;
    PB_GNSS_MEASUREMENTS_STATE_TOW_DECODED_BIT           = 8;
    PB_GNSS_MEASUREMENTS_STATE_MSEC_AMBIGUOUS_BIT        = 16;
    PB_GNSS_MEASUREMENTS_STATE_SYMBOL_SYNC_BIT           = 32;
    PB_GNSS_MEASUREMENTS_STATE_GLO_STRING_SYNC_BIT       = 64;
    PB_GNSS_MEASUREMENTS_STATE_GLO_TOD_DECODED_BIT       = 128;
    PB_GNSS_MEASUREMENTS_STATE_BDS_D2_BIT_SYNC_BIT       = 256;
    PB_GNSS_MEASUREMENTS_STATE_BDS_D2_SUBFRAME_SYNC_BIT  = 512;
    PB_GNSS_MEASUREMENTS_STATE_GAL_E1BC_CODE_LOCK_BIT    = 1024;
    PB_GNSS_MEASUREMENTS_STATE_GAL_E1C_2ND_CODE_LOCK_BIT = 2048;
    PB_GNSS_MEASUREMENTS_STATE_GAL_E1B_PAGE_SYNC_BIT     = 4096;
    PB_GNSS_MEASUREMENTS_STATE_SBAS_SYNC_BIT             = 8192;
}

enum PBGnssMeasurementsMultipathIndicator {
    PB_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN = 0;
    PB_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_PRESENT = 1;
    PB_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_NOT_PRESENT = 2;
}

enum PBLocApiGnssAidingDataSvMask {
    // GnssAidingDataSvMask
    PB_AIDING_DATA_SV_MASK_INVALID     = 0;
    // supports delete only ephemeris or delt all
    PB_AIDING_DATA_SV_EPHEMERIS_BIT    = 1; // ephemeris
}

// Flags to indicate which values are valid in a Location
enum PBLocationFlagsMask {
    PB_LOCATION_FLAGS_INVALID             = 0;
    // location has valid latitude and longitude
    PB_LOCATION_HAS_LAT_LONG_BIT          = 1;
    // location has valid altitude
    PB_LOCATION_HAS_ALTITUDE_BIT          = 2;
    // location has valid speed
    PB_LOCATION_HAS_SPEED_BIT             = 4;
    // location has valid bearing
    PB_LOCATION_HAS_BEARING_BIT           = 8;
    // location has valid accuracy
    PB_LOCATION_HAS_ACCURACY_BIT          = 16;
    // location has valid vertical accuracy
    PB_LOCATION_HAS_VERTICAL_ACCURACY_BIT = 32;
    // location has valid speed accuracy
    PB_LOCATION_HAS_SPEED_ACCURACY_BIT    = 64;
    // location has valid bearing accuracy
    PB_LOCATION_HAS_BEARING_ACCURACY_BIT  = 128;
    // location has valid valid Location::timestamp
    PB_LOCATION_HAS_TIMESTAMP_BIT         = 256;
}

enum PBLocationTechnologyMask {
    PB_LOCATION_TECHNOLOGY_INVALID      = 0x00000000;
    // location was calculated using GNSS
    PB_LOCATION_TECHNOLOGY_GNSS_BIT     = 0x00000001;
    // location was calculated using Cell
    PB_LOCATION_TECHNOLOGY_CELL_BIT     = 0x00000002;
    // location was calculated using WiFi
    PB_LOCATION_TECHNOLOGY_WIFI_BIT     = 0x00000004;
    // location was calculated using Sensors
    PB_LOCATION_TECHNOLOGY_SENSORS_BIT  = 0x00000008;
    // using reference location
    PB_LOCATION_TECHNOLOGY_REFERENCE_LOCATION_BIT   = 0x00000010;
    // using CPI
    PB_LOCATION_TECHNOLOGY_INJECTED_COARSE_POSITION_BIT = 0x00000020;
    // AFLT
    PB_LOCATION_TECHNOLOGY_AFLT_BIT     = 0x00000040;
    // HYBRID
    PB_LOCATION_TECHNOLOGY_HYBRID_BIT   = 0x00000080;
    // PPE
    PB_LOCATION_TECHNOLOGY_PPE_BIT      = 0x000000100;
    // Vehicular data
    PB_LOCATION_TECHNOLOGY_VEH_BIT      = 0x000000200;
    // Visual data
    PB_LOCATION_TECHNOLOGY_VIS_BIT      = 0x000000400;
}

enum PBLocationCapabilitiesMask {
    PB_LOCATION_CAPS_INVALID                           = 0;
    /** LocationClientApi can support time-based tracking session
     *  via LocationClientApi::startPositionSession(uint32_t,
     *  LocReqEngineTypeMask, const EngineReportCbs&, ResponseCb)
     *  and LocationClientApi::startPositionSession(uint32_t, const
     *  GnssReportCbs&, ResponseCb) and
     *  LocationClientApi::startPositionSession(uint32_t, uint32_t,
     *  LocationCb, ResponseCb) with distanceInMeters set to 0.
     *  <br/> */
    PB_LOCATION_CAPS_TIME_BASED_TRACKING_BIT           = 1;
    /** LocationClientApi can support time-based batching session
     *  via LocationClientApi::startRoutineBatchingSession() with
     *  minInterval specified. <br/> */
    PB_LOCATION_CAPS_TIME_BASED_BATCHING_BIT           = 2;
    /** LocationClientApi can support distance based tracking
     *  session via
     *  LocationClientApi::startPositionSession(uint32_t, uint32_t,
     *  LocationCb, ResponseCb) with distanceInMeters specified.
     *  <br/> */
    PB_LOCATION_CAPS_DISTANCE_BASED_TRACKING_BIT       = 4;
    /** LocationClientApi can support distance-based batching via
     *  LocationClientApi::startRoutineBatchingSession() with
     *  minDistance set to none-zero value. <br/> */
    PB_LOCATION_CAPS_DISTANCE_BASED_BATCHING_BIT       = 8;
    /** LocationClientApi can support geo fence via
     *  LocationClientApi::addGeofences(). <br/>   */
    PB_LOCATION_CAPS_GEOFENCE_BIT                      = 16;
    /** LocationClientApi can support trip batching via
     *  LocationClientApi::startTripBatchingSession(). <br/>   */
    PB_LOCATION_CAPS_OUTDOOR_TRIP_BATCHING_BIT         = 32;
    /** LocationClientApi can support receiving GnssMeasurements
     *  data in GnssMeasurementsCb when LocationClientApi is in
     *  a positioning session.. <br/>   */
    PB_LOCATION_CAPS_GNSS_MEASUREMENTS_BIT             = 64;
    /** LocationIntegrationApi can support configure constellations
     *  via LocationIntegrationApi::configConstellations.  <br/>   */
    PB_LOCATION_CAPS_CONSTELLATION_ENABLEMENT_BIT      = 128;
    /** Modem supports Carrier Phase for Precise Positioning
     *  Measurement Engine (PPME).
     *  This is a Standalone Feature.  <br/>   */
    PB_LOCATION_CAPS_QWES_CARRIER_PHASE_BIT                 = 256;
    /** Modem supports SV Polynomial for tightly coupled
     *  external DR support.
     *  This is a Standalone Feature.  <br/>   */
    PB_LOCATION_CAPS_QWES_SV_POLYNOMIAL_BIT                 = 512;
    /** Modem supports GNSS Single Frequency feature.
     *  This is a Standalone Feature.  <br/>   */
    PB_LOCATION_CAPS_QWES_GNSS_SINGLE_FREQUENCY        = 1024;
    /** Modem supports GNSS Multi Frequency feature. Multi
     *  Frequency enables Single frequency also.  <br/>   */
    PB_LOCATION_CAPS_QWES_GNSS_MULTI_FREQUENCY         = 2048;
    /** This mask indicates VEPP license bundle is enabled.
     *  VEPP bundle include Carrier Phase and SV Polynomial
     *  features.  <br/>   */
    PB_LOCATION_CAPS_QWES_VPE                          = 4096;
    /** This mask indicates support for CV2X Location basic
     *  features. This bundle includes features for GTS Time
     *  & Freq, C-TUNC (Constrained Time uncertainity.
     *  LocationIntegrationApi can support setting of C-TUNC
     *  via configConstrainedTimeUncertainty. <br/> */
    PB_LOCATION_CAPS_QWES_CV2X_LOCATION_BASIC          = 8192;
    /** This mask indicates support for CV2X Location premium
     *  features. This bundle includes features for CV2X Location
     *  Basic features, QDR3 feature, and PACE. (Position
     *  Assisted Clock Estimator.
     *  LocationIntegrationApi can support setting of C-TUNC
     *  via configPositionAssistedClockEstimator. <br/> */
    PB_LOCATION_CAPS_QWES_CV2X_LOCATION_PREMIUM        = 16384;
    /** This mask indicates that PPE (Precise Positioning Engine)
     *  library is enabled or Precise Positioning Framework (PPF)
     *  is available. This bundle includes features for Carrier
     *  Phase and SV Ephermeris.  <br/>   */
    PB_LOCATION_CAPS_QWES_PPE                          = 32768;
    /** This mask indicates QDR2_C license bundle is enabled.
     *  This bundle includes features for SV Polynomial. <br/> */
    PB_LOCATION_CAPS_QWES_QDR2                         = 65536;
    /** This mask indicates QDR3_C license bundle is enabled.
     *  This bundle includes features for SV Polynomial. <br/> */
    PB_LOCATION_CAPS_QWES_QDR3                         = 131072;
}

enum PBGnssDataMask {
    PB_GNSS_LOC_DATA_INVALID    = 0;
    // Jammer Indicator is available
    PB_GNSS_LOC_DATA_JAMMER_IND_BIT = 1;
    // AGC is available
    PB_GNSS_LOC_DATA_AGC_BIT = 2;
}

enum PBLIALeverArmTypeMask {
    PB_LEVER_ARM_TYPE_INVALID = 0;
    // Lever arm regarding the VRP (Vehicle Reference Point) w.r.t
    // the origin (at the GPS Antenna)
    PB_LEVER_ARM_TYPE_GNSS_TO_VRP_BIT = 1;
    // Lever arm regarding GNSS Antenna w.r.t the origin at the IMU
    // e.g.: inertial measurement unit for DR (dead reckoning
    // engine)
    PB_LEVER_ARM_TYPE_DR_IMU_TO_GNSS_BIT = 2;
    // Lever arm regarding GNSS Antenna w.r.t the origin at the
    // IMU (inertial measurement unit) for VEPP (vision enhanced
    // precise positioning engine)
    PB_LEVER_ARM_TYPE_VEPP_IMU_TO_GNSS_BIT = 4;
}

enum PBDrSolutionStatusMask {
    PB_VEHICLE_DRSOLUTION_INVALID = 0;
    PB_VEHICLE_SENSOR_SPEED_INPUT_DETECTED = 1;
    PB_VEHICLE_SENSOR_SPEED_INPUT_USED = 2;
}

enum PBLocationSessionStatus {
    PB_LOCATION_SESS_SUCCESS = 0;
    PB_LOCATION_SESS_INTERMEDIATE = 1;
    PB_LOCATION_SESS_FAILURE = 2;
};

// Specify the valid mask for the configuration paramters of
// dead reckoning position engine.
enum PBDeadReckoningEngineConfigValidMask {
    PB_DR_RECKON_ENGINE_CONFIG_INVALID    = 0;
    // DeadReckoningEngineConfig has valid
    // DeadReckoningEngineConfig::DeadReckoningEngineConfig.
    PB_BODY_TO_SENSOR_MOUNT_PARAMS_BIT    = 1;
    // DeadReckoningEngineConfig has valid
    //  DeadReckoningEngineConfig::vehicleSpeedScaleFactor.
    PB_VEHICLE_SPEED_SCALE_FACTOR_BIT     = 2;
    // DeadReckoningEngineConfig has valid
    //  DeadReckoningEngineConfig::vehicleSpeedScaleFactorUnc.
    PB_VEHICLE_SPEED_SCALE_FACTOR_UNC_BIT = 4;
    // DeadReckoningEngineConfig has valid
    //  DeadReckoningEngineConfig::gyroScaleFactor.
    PB_GYRO_SCALE_FACTOR_BIT              = 8;
    // DeadReckoningEngineConfig has valid
    // DeadReckoningEngineConfig::gyroScaleFactorUnc.
    PB_GYRO_SCALE_FACTOR_UNC_BIT          = 16;
}

// ============================================================================
// Messages
// ============================================================================

message PBLocation {
    /** Bitwise OR of PBLocationFlagsMask to specify the valid
     *  fields.    */
    uint32 flags = 1;
    /** UTC timestamp for location fix since January 1, 1970, in
     *  unit of milliseconds.    */
    uint64 timestamp = 2;
    /** Latitude, in unit of degrees, range [-90.0, 90.0].   */
    double latitude = 3;
    /** Longitude, in unit of degrees, range [-180.0, 180.0].
     *   */
    double longitude = 4;
    /** Altitude above the WGS 84 reference ellipsoid, in unit of
     *  meters.    */
    double altitude = 5;
    /** Horizontal speed, in meters/second.    */
    float speed = 6;
    /** Bearing, in unit of degrees, range [0, 360)    */
    float bearing = 7;
    /** Horizontal accuracy, in unit of meters.    */
    float horizontalAccuracy = 8;
    /** Vertial accuracy, in uint of meters.    */
    float verticalAccuracy = 9;
    /** Speed uncertainty, in unit meters/second.    */
    float speedAccuracy = 10;
    /** Bearing uncertainty, in unit of degrees, range (0 to
     *  359.999).    */
    float bearingAccuracy = 11;
    /** Sets of technology that contributed to the fix. bitwise OR of PBLocationTechnologyMask    */
    uint32 techMask = 12;
}

message PBLocationOptions {
    // in milliseconds
    uint32 minInterval = 1;
    // in meters. if minDistance > 0, gnssSvCallback/gnssNmeaCallback/
    // gnssMeasurementsCallback may not be called
    uint32 minDistance = 2;
    // Standalone/MS-Based/MS-Assisted
    PBGnssSuplMode mode = 3;
    // bitwise OR of PBLocReqEngineTypeMask
    // behavior when this field is 0:
    //  if engine hub is running, this will be fused fix,
    //  if engine hub is not running, this will be SPE fix
    uint32 locReqEngTypeMask = 4;
}

message PBAidingData {
    // if true, delete all aiding data and ignore other params
    bool deleteAll  = 1;
    // SV specific aiding data - bitwise OR of PBLocApiGnssAidingDataSvMask
    uint32 gnssAidingDataSvMask = 2;
    // aiding data mask for dr engine - PBDrEngineAidingDataMask
    uint32 dreAidingDataMask = 3;
    // engines to perform the delete operation on
    // Masks from - PBLocApiPositioningEngineMask
    uint32 posEngineMask = 4;
}

message PBLocApiGnssSv {
    /** Unique SV Identifier. This field is always valid.
     *   SV Range for supported constellation is specified as below:
     *
     *    - For GPS:     1 to 32
     *    - For GLONASS: 65 to 96
     *    - For SBAS:    120 to 158 and 183 to 191
     *    - For QZSS:    193 to 197
     *    - For BDS:     201 to 237
     *    - For GAL:     301 to 336
     *    - For NAVIC:   401 to 414    */
    uint32 svId = 1;     // Unique Identifier
    /** Constellation type of the SV (GPS, SBAS, GLONASS, QZSS,
     *  BEIDOU, GALILEO). */
    /* Use Gnss_LocSvSystemEnumType instead of GnssSvType */
    PBLocApiGnss_LocSvSystemEnumType type = 2;   // type of SV (GPS, SBAS, GLONASS, QZSS, BEIDOU, GALILEO)
     /** Signal-to-noise ratio at antenna of the SV, in unit of dB-Hz. */
    float cN0Dbhz = 3;     // signal strength
    /** Elevation of the SV, in unit of degrees.  This field is always valid.   */
    float elevation = 4;   // elevation of SV (in degrees)
    /** Azimuth of the SV, in unit of degrees.  This field is
     *  always valid.   */
    float azimuth = 5;     // azimuth of SV (in degrees)
    uint32 gnssSvOptionsMask = 6; // Bitwise OR of PBLocApiGnssSvOptionsMask
    float carrierFrequencyHz = 7; // carrier frequency of the signal tracked
    uint32 gnssSignalTypeMask = 8; // Specifies GNSS signal type - PBGnssSignalTypeMask
    double basebandCarrierToNoiseDbHz = 9; // Baseband signal strength Db Hz.
    uint32 gloFrequency = 10; // GLONASS Frequency number.
}

message PBLocApiGnssSvNotification {
    bool gnssSignalTypeMaskValid = 1;
    // information on a number of SVs
    repeated PBLocApiGnssSv gnssSvs = 2;
}

message PBGnssMeasurementsClock {
    // bitwise OR of PBGnssMeasurementsClockFlagsMask
    uint32 flags = 1;
    int32 leapSecond = 2;
    int64 timeNs = 3;
    double timeUncertaintyNs = 4;
    int64 fullBiasNs = 5;
    double biasNs = 6;
    double biasUncertaintyNs = 7;
    double driftNsps = 8;
    double driftUncertaintyNsps = 9;
    uint32 hwClockDiscontinuityCount= 10;
}

message PBGnssMeasurementsData {
    // bitwise OR of PBGnssMeasurementsDataFlagsMask
    uint32 flags = 1;
    // Unique SV Identifier
    // For SV Range of supported constellation,
    // please refer to the comment section of svId in GnssSv.
    int32 svId = 2;
    /* Use Gnss_LocSvSystemEnumType instead of GnssSvType */
    PBLocApiGnss_LocSvSystemEnumType svType = 3;
    double timeOffsetNs = 4;
    // bitwise OR of PBGnssMeasurementsStateMask
    uint32 stateMask = 5;
    int64 receivedSvTimeNs = 6;
    int64 receivedSvTimeUncertaintyNs = 7;
    double carrierToNoiseDbHz = 8;
    double pseudorangeRateMps = 9;
    double pseudorangeRateUncertaintyMps = 10;
    // bitwise OR of PBGnssMeasurementsAdrStateMask
    uint32 adrStateMask = 11;
    double adrMeters = 12;
    double adrUncertaintyMeters = 13;
    float carrierFrequencyHz = 14;
    int64 carrierCycles = 15;
    double carrierPhase = 16;
    double carrierPhaseUncertainty = 17;
    PBGnssMeasurementsMultipathIndicator multipathIndicator = 18;
    double signalToNoiseRatioDb = 19;
    double agcLevelDb = 20;
    double basebandCarrierToNoiseDbHz = 21;
    // bitwise OR of  PBGnssSignalTypeMask
    uint32 gnssSignalType = 22;
    double fullInterSignalBiasNs = 23;
    double fullInterSignalBiasUncertaintyNs = 24;
    uint32 cycleSlipCount = 25;
}

message PBLocApiGnssLocationPositionDynamics {
    /** Bitwise OR of PBLocApiGnssLocationPosDataMask to specify the
     *  valid fields in GnssLocationPositionDynamics.    */
    uint32  bodyFrameDataMask = 1;
    /** Forward acceleration in body frame, in unit of
     *  meters/second^2.    */
    float           longAccel = 2;
    /** Sideward acceleration in body frame, in unit of
     *  meters/second^2.    */
    float           latAccel = 3;
    /** Vertical acceleration in body frame, in unit of
     *  meters/second^2.    */
    float           vertAccel = 4;
    /** Uncertainty of forward acceleration in body frame, in unit
     *  of meters/second^2.    */
    float           longAccelUnc = 5;
    /** Uncertainty of side-ward acceleration in body frame, in unit
     *  of meters/second^2.    */
    float           latAccelUnc = 6;
    /** Uncertainty of vertical acceleration in body frame, in unit
     *  of meters/second^2.    */
    float           vertAccelUnc = 7;
    /** Body pitch, in unit of radians.    */
    float           pitch = 8;
    /** Uncertainty of body pitch, in unit of radians.    */
    float           pitchUnc = 9;
    /** Body pitch rate, in unit of radians/second.   */
    float           pitchRate = 10;
    /** Uncertainty of pitch rate, in unit of radians/second.   */
    float           pitchRateUnc = 11;
    /** Roll of body frame, clockwise is positive, in unit of
     *  radian.   */
    float           roll = 12;
    /** Uncertainty of roll, 68% confidence level, in unit of
    radian.   */
    float           rollUnc = 13;
    /** Roll rate of body frame, clockwise is
    positive, in unit of radian/second.  */
    float           rollRate = 14;
    /** Uncertainty of roll rate, 68% confidence level, in unit of
     *  radian/second.   */
    float           rollRateUnc = 15;
    /** Yaw of body frame, clockwise is positive, in unit of
     *  radian.  */
    float           yaw = 16;
    /** Uncertainty of yaw, 68% confidence level, in unit of radian.
     *   */
    float           yawUnc = 17;
    /** Heading rate, in unit of radians/second.    */
    float           yawRate = 18;
    /** Uncertainty of heading rate, in unit of radians/second. */
    float           yawRateUnc = 19;
}

message PBLocApiSystemTimeStructUnion {
    oneof sysTimeUnion {
        /** System time info from GPS constellation.    */
        PBLocApiGnssSystemTimeStructType gpsSystemTime = 1;
        /** System time info from GALILEO constellation.    */
        PBLocApiGnssSystemTimeStructType galSystemTime = 2;
        /** System time info from BEIDOU constellation.    */
        PBLocApiGnssSystemTimeStructType bdsSystemTime = 3;
        /** System time info from QZSS constellation.    */
        PBLocApiGnssSystemTimeStructType qzssSystemTime = 4;
        /** System time info from GLONASS constellation.    */
        PBLocApiGnssGloTimeStructType gloSystemTime = 5;
        /** System time info from NAVIC constellation.    */
        PBLocApiGnssSystemTimeStructType navicSystemTime = 6;
    }
}

/** Time applicability of PVT report */
message PBLocApiGnssSystemTime {
    /** Specifies GNSS system time reported. Mandatory field */
    PBLocApiGnss_LocSvSystemEnumType gnssSystemTimeSrc = 1;
    /** Reporting of GPS system time is recommended.
      If GPS time is unknown & other satellite system time is known,
      it should be reported.
      Mandatory field
     */
    PBLocApiSystemTimeStructUnion u = 2;
}

message PBGnssLocationSvUsedInPosition {
        /** Specify the set of SVs from GPS constellation that are used
     *  to compute the position.  Bit 0 to Bit 31 corresponds
     *  to GPS SV id 1 to 32.    */
    uint64 gpsSvUsedIdsMask = 1;
    /** Specify the set of SVs from GLONASS constellation that are
     *  used to compute the position.
     *  Bit 0 to Bit 31 corresponds to GLO SV id 65 to 96.  */
    uint64 gloSvUsedIdsMask = 2;
    /** Specify the set of SVs from GALILEO constellation that are
     *  used to compute the position.
     *  Bit 0 to Bit 35 corresponds to GAL SV id 301 to 336.
     *   */
    uint64 galSvUsedIdsMask = 3;
    /** ISpecify the set of SVs from BEIDOU constellation that are
     *  used to compute the position.
     *  Bit 0 to Bit 36 corresponds to BDS SV id 201 to 237.
     *   */
    uint64 bdsSvUsedIdsMask = 4;
    /** Specify the set of SVs from QZSS constellation that are used
     *  to compute the position.
     *  Bit 0 to Bit 4 corresponds to QZSS SV id 193 to 197.
     *   */
    uint64 qzssSvUsedIdsMask = 5;
    /** Specify the set of SVs from NAVIC constellation that are used
     *  to compute the position.
     *  Bit 0 to Bit 13 corresponds to NAVIC SV id 401 to 414.
     *   */
    uint64 navicSvUsedIdsMask = 6;
}

message PBGnssMeasUsageInfo {
    /** Specify GNSS Constellation Type for the SV. */
    PBLocApiGnss_LocSvSystemEnumType gnssConstellation = 1;
    /** Specify satellite vehicle ID number.
     *  For SV id range of each supported constellations, refer to
     *  documentation section in GnssSv::svId.
     */
    uint32 gnssSvId = 2;
    /** Specify the signal type mask of the SV. - bitwise OR of PBGnssSignalTypeMask  */
    uint32 gnssSignalType = 3;
}

message PBGnssLocationInfoNotification {
    PBLocation location = 1;                  // basic locaiton info, latitude, longitude, and etc
    /** Contains PBGnssLocationInfoFlagMask bits. */
    uint32 flags = 2;     // bitwise OR of PBGnssLocationInfoFlagMask for param validity
    float altitudeMeanSeaLevel = 3;         // altitude wrt mean sea level
    float pdop = 4;                         // position dilusion of precision
    float hdop = 5;                         // horizontal dilusion of precision
    float vdop = 6;                         // vertical dilusion of precision
    float gdop = 7;                         // geometric  dilution of precision
    float tdop = 8;                         // time dilution of precision
    float magneticDeviation = 9;            // magnetic deviation
    PBLocationReliability horReliability = 10; // horizontal reliability
    PBLocationReliability verReliability = 11; // vertical reliability
    float horUncEllipseSemiMajor = 12;       // horizontal elliptical accuracy semi-major axis
    float horUncEllipseSemiMinor = 13;       // horizontal elliptical accuracy semi-minor axis
    float horUncEllipseOrientAzimuth = 14;   // horizontal elliptical accuracy azimuth
    float northStdDeviation = 15;            // North standard deviation Unit: Meters
    float eastStdDeviation = 16;             // East standard deviation. Unit: Meters
    float northVelocity = 17;                // North Velocity.Unit: Meters/sec
    float eastVelocity = 18;                 // East Velocity Unit Meters/sec
    float upVelocity = 19;                   // Up Velocity. Unit Meters/sec
    float northVelocityStdDeviation = 20;
    float eastVelocityStdDeviation = 21;
    float upVelocityStdDeviation = 22;
    uint32 numSvUsedInPosition = 23;
    PBGnssLocationSvUsedInPosition svUsedInPosition = 24;  // Gnss sv used in position data
    uint32 navSolutionMask = 25;  // Nav solution mask to indicate sbas corrections
                                  // bitwise OR of PBGnssLocationNavSolutionMask
    PBLocApiGnssLocationPositionDynamics bodyFrameData = 26; // Body Frame Dynamics:
                                                 // 4wayAcceleration and pitch set with validity
    PBLocApiGnssSystemTime gnssSystemTime = 27;            // GNSS System Time
    uint32 numOfMeasReceived = 28;  // Number of measurements received for use in fix.
    repeated PBGnssMeasUsageInfo measUsageInfo = 29; // GNSS Measurement Usage info.
    uint32 leapSeconds = 30;                       // leap second
    float timeUncMs = 31;                         // Time uncertainty in milliseconds
    uint32 calibrationConfidence = 32;            // Sensor calibration confidence percent,
                                                  // in range of [0, 100]
    uint32 calibrationStatus = 33;    // Sensor calibration status. PBLocApiDrCalibrationStatusMask
    // location engine type. When the fix. when the type is set to
    // LOC_ENGINE_SRC_FUSED, the fix is the propagated/aggregated
    // reports from all engines running on the system (e.g.:
    // DR/SPE/PPE). To check which location engine contributes to
    // the fused output, check for locOutputEngMask.
    PBLocApiOutputEngineType locOutputEngType = 34;
    // when loc output eng type is set to fused, this field
    // indicates the set of engines contribute to the fix.
    // bitwise OR of PBLocApiPositioningEngineMask
    uint32 locOutputEngMask = 35;
    // When robust location is enabled, this field
    // will how well the various input data considered for
    // navigation solution conform to expectations.
    // Range: 0 (least conforming) to 1 (most conforming)
    float conformityIndex = 36;
    // VRR-based latitude/longitude/altitude
    PBLLAInfo llaVRPBased = 37;
    // VRR-based east, north, and up velocity  - Max array length 3
    repeated float enuVelocityVRPBased = 38;
    // PBDrSolutionStatusMask
    uint32 drSolutionStatusMask = 39;
    // Contains PBGnssLocationInfoExtFlagMask bits.
    // Bitwise OR of PBGnssLocationInfoExtFlagMask for param validity
    // for fields 41: e.g.:altitudeAssumed and onwards
    uint32 extFlags = 40;
    // PBAltitudeAssumed, validity is set via extFlags
    bool altitudeAssumed = 41;
    // PBLocationSessionStatus, validity is set via extFlags
    PBLocationSessionStatus sessionStatus = 42;
}

message PBGnssDataNotification {
    // Number of signal types - GNSS_LOC_MAX_NUMBER_OF_SIGNAL_TYPES
    uint32 numberSignalTypes = 1;
    // bitwise OR of GnssDataMask.
    repeated uint64  gnssDataMask = 2;
    // Jammer Indication.
    repeated double     jammerInd = 3;
    // Automatic gain control.
    repeated double     agc = 4;
}

message PBGnssMeasurementsNotification {
    // number of items in GnssMeasurements array
    // Max array len - GNSS_MEASUREMENTS_MAX
    repeated PBGnssMeasurementsData measurements = 1;
    // clock
    PBGnssMeasurementsClock clock = 2;
}

message PBLocApiGnssSystemTimeStructType {
    /** Validity mask for below fields PBLocApiGnssSystemTimeStructTypeFlags */
    uint32 validityMask = 1;
    /** Extended week number at reference tick.
    Unit: Week.
    Set to 65535 if week number is unknown.
    For GPS:
      Calculated from midnight, Jan. 6, 1980.
      OTA decoded 10 bit GPS week is extended to map between:
      [NV6264 to (NV6264 + 1023)].
      NV6264: Minimum GPS week number configuration.
      Default value of NV6264: 1738
    For BDS:
      Calculated from 00:00:00 on January 1, 2006 of Coordinated Universal Time (UTC).
    For GAL:
      Calculated from 00:00 UT on Sunday August 22, 1999 (midnight between August 21 and August 22).
   */
    uint32 systemWeek = 2;
    /** Time in to the current week at reference tick.
       Unit: Millisecond. Range: 0 to 604799999.
       Check for systemClkTimeUncMs before use */
    uint32 systemMsec = 3;
    /** System clock time bias (sub-millisecond)
        Units: Millisecond
        Note: System time (TOW Millisecond) = systemMsec - systemClkTimeBias.
        Check for systemClkTimeUncMs before use. */
    float systemClkTimeBiasMs = 4;
    /** Single sided maximum time bias uncertainty
        Units: Millisecond */
    float systemClkTimeBiasUncMs = 5;
    /** FCount (free running HW timer) value. Don't use for relative time purpose
        due to possible discontinuities.
        Unit: Millisecond */
    uint32 refFCount = 6;
    /** Number of clock resets/discontinuities detected,
        affecting the local hardware counter value. */
    uint32 numClockResets = 7;
}

message PBLocApiGnssGloTimeStructType {
    /** Bitwise OR of PBGnssGloTimeStructTypeFlags to specify the
     *  valid fields in GnssGloTimeStructType.    */
    uint32 validityMask = 1;
    /** GLONASS four year number from 1996. Refer to GLONASS ICD.
     *  Applicable only for GLONASS and shall be ignored for
     * other constellations.   */
    uint32 gloFourYear = 2;
    /** GLONASS day number in four years. Refer to GLONASS ICD.
     *
     * If unknown shall be set to 65535.  */
    uint32 gloDays = 3;
    /** GLONASS time of day in unit of millisecond. Refer to GLONASS
     *  ICD.   */
    uint32 gloMsec = 4;
    /** GLONASS clock time bias, in unit of millisecond.
     *  Note: GLO time (TOD Millisecond) = gloMsec -
     *  gloClkTimeBias.
     *  Check for gloClkTimeUncMs before use.  */
    float gloClkTimeBias = 5;
    /** Single sided maximum time bias uncertainty, in unit of
     *  milliseconds.   */
    float gloClkTimeUncMs = 6;
    /** FCount (free running HW timer) value, in unit of
     *  milliseconds.
     *  Don't use for relative time purpose due to possible
     *  discontinuities.  */
    uint32  refFCount = 7;
    /** Number of clock resets/discontinuities detected,
     *  affecting the local hardware counter value.  */
    uint32 numClockResets = 8;
}

message PBLLAInfo {
    // Latitude, in unit of degrees, range [-90.0, 90.0]
    double latitude = 1;
    // Longitude, in unit of degrees, range [-180.0, 180.0]
    double longitude = 2;
    // altitude wrt to ellipsoid WGS 84 reference ellipsoid, in unit of meters.
    float altitude = 3;
}

message PBLeapSecondSystemInfo {
    // bitwise OR of PBLeapSecondSysInfoMask
    uint32  leapSecondInfoMask = 1;
    // Current leap seconds, in unit of seconds.
    // This info will only be available if the leap second change
    // info is not available.
    uint32  leapSecondCurrent = 2;
    /** Leap second change event info. The info can be available on
        two scenario:
        1: this leap second change event has been scheduled and yet
           to happen
        2: this leap second change event has already happened and
           next leap second change event has not yet been scheduled.
        If leap second change info is avaiable, to figure out the
        current leap second info, compare current gps time with
        LeapSecondChangeInfo::gpsTimestampLsChange to know whether
        to choose leapSecondBefore or leapSecondAfter as current
        leap second.  */
    PBLeapSecondChangeInfo  leapSecondChangeInfo = 3;
}

message PBLeapSecondChangeInfo {
    // GPS timestamp that corrresponds to the last known
    // leap second change event.
    //
    // The info can be available on two scenario:
    // 1: this leap second change event has been scheduled and yet to happen
    // 2: this leap second change event has already happened and next
    //    leap second change event has not yet been scheduled.
    PBLocApiGnssSystemTimeStructType gpsTimestampLsChange = 1;
    // Number of leap seconds prior to the leap second change event
    // that corresponds to the timestamp at gpsTimestampLsChange.
    uint32 leapSecondsBeforeChange = 2;
    // Number of leap seconds after the leap second change event
    // that corresponds to the timestamp at gpsTimestampLsChange.
    uint32 leapSecondsAfterChange = 3;
}

message PBLocationSystemInfo {
    // bitwise OR of PBLocationSystemInfoMask
    uint32 systemInfoMask = 1;
    // Current leap second and leap second info
    PBLeapSecondSystemInfo   leapSecondSysInfo = 2;
}

message PBGnssConfigRobustLocationVersion {
    // Major version number
    uint32 major = 1;
    // Minor version number
    uint32 minor = 2;
}

message PBGnssConfigRobustLocation {
   // bitwise OR of PBGnssConfigRobustLocationValidMask
   uint32 validMask = 1;
   bool enabled = 2;
   bool enabledForE911 = 3;
   PBGnssConfigRobustLocationVersion version = 4;
}

/* This SV Type config is injected directly to GNSS Adapter
 * bypassing Location API */
message PBGnssSvTypeConfig {
    // Enabled Constellations - bitwise OR of PBGnssSvTypesMask
    uint64 enabledSvTypesMask = 1;
    // Disabled Constellations - bitwise OR of PBGnssSvTypesMask
    uint64 blacklistedSvTypesMask = 2;
}

message PBGnssSvIdConfig {
    // GLONASS - SV 65 maps to bit 0.
    uint64 gloBlacklistSvMask = 1;

    // BEIDOU - SV 201 maps to bit 0.
    uint64 bdsBlacklistSvMask = 2;

    // QZSS - SV 193 maps to bit 0.
    uint64 qzssBlacklistSvMask = 3;

    // GAL - SV 301 maps to bit 0.
    uint64 galBlacklistSvMask = 4;

    // SBAS - SV 120 to 158, maps to 0 to 38
    //        SV 183 to 191, maps to 39 to 47
    uint64 sbasBlacklistSvMask = 5;

    //Navic - SV 401 maps to bit 0
    uint64 navicBlacklistSvMask = 6;
}

message PBLIALeverArmParams {
    // Offset along the vehicle forward axis, in unit of meters
    float forwardOffsetMeters = 1;
    // Offset along the vehicle starboard axis, in unit of meters
    float sidewaysOffsetMeters = 2;
    // Offset along the vehicle up axis, in unit of meters
    float upOffsetMeters = 3;
}

message PBLIALeverArmConfigInfo {
    // Valid mask for the types of lever arm parameters provided
    // PBLIALeverArmTypeMask
    uint32 leverArmValidMask = 1;
    // Lever arm regarding the VRP (Vehicle Reference Point) w.r.t the origin
    // (at the GPS Antenna)
    PBLIALeverArmParams   gnssToVRP = 2;
    // Lever arm parameters regarding GNSS Antenna w.r.t the origin at the IMU
    // (inertial measurement unit) for DR (dead reckoning engine)
    PBLIALeverArmParams   drImuToGnss = 3;
    // Lever arm regarding GNSS Antenna w.r.t the origin at the IMU
    // (inertial measurement unit) for VEPP (vision enhanced precise position engine)
    PBLIALeverArmParams   veppImuToGnss = 4;
}

// Specify vehicle body-to-Sensor mount parameters to be used
// by dead reckoning positioning engine.
message PBLIABodyToSensorMountParams {
    // The misalignment of the sensor board along the
    // horizontal plane of the vehicle chassis measured looking
    // from the vehicle to forward direction. In unit of degree.
    float rollOffset = 1;
    // The misalignment along the horizontal plane of the vehicle
    // chassis measured looking from the vehicle to the right
    // side. Positive pitch indicates vehicle is inclined such
    // that forward wheels are at higher elevation than rear
    // wheels. In unit of degree.
    float yawOffset = 2;
    // The angle between the vehicle forward direction and the
    // sensor axis as seen from the top of the vehicle, and
    // measured in counterclockwise direction. In unit of degree.
    float pitchOffset = 3;
    // Single uncertainty number that may be the largest of the
    // roll, pitch and yaw offset uncertainties.
    float offsetUnc = 4;
}

// Specify the configuration parameters for the dead reckoning
//  position engine
message PBDeadReckoningEngineConfig {
    // Specify the valid fields in the config.
    // Bitwise OR mask of PBDeadReckoningEngineConfigValidMask
    uint64    validMask = 1;

    // Body to sensor mount parameters for use by dead reckoning
    //  positioning engine
    PBLIABodyToSensorMountParams bodyToSensorMountParams = 2;

    // Vehicle Speed Scale Factor configuration input for the dead
    // reckoning positioning engine. The multiplicative scale
    // factor is applied to received Vehicle Speed value (in m/s)
    // to obtain the true Vehicle Speed.
    //
    // Range is [0.9 to 1.1].
    //
    // Note: The scale factor is specific to a given vehicle
    // make & model.
    float vehicleSpeedScaleFactor = 3;

    // Vehicle Speed Scale Factor Uncertainty (68% confidence)
    // configuration input for the dead reckoning positioning
    // engine.
    //
    // Range is [0.0 to 0.1].
    //
    // Note: The scale factor unc is specific to a given vehicle
    // make & model.
    float vehicleSpeedScaleFactorUnc = 4;

    // Gyroscope Scale Factor configuration input for the dead
    // reckoning positioning engine. The multiplicative scale
    // factor is applied to received gyroscope value to obtain the
    // true value.
    //
    // Range is [0.9 to 1.1].
    //
    // Note: The scale factor is specific to the Gyroscope sensor
    // and typically derived from either sensor data-sheet or
    // from actual calibration.
    float gyroScaleFactor = 5;

    // Gyroscope Scale Factor uncertainty (68% confidence)
    // configuration input for the dead reckoning positioning
    // engine.
    //
    // Range is [0.0 to 0.1].
    // engine.
    //
    // Note: The scale factor unc is specific to the make & model
    // of Gyroscope sensor and typically derived from either
    // sensor data-sheet or from actual calibration.
    float gyroScaleFactorUnc = 6;
}
